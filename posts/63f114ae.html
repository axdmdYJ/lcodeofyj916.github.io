<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="总之岁月漫长,然而值得等待"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>JVM垃圾回收入门（爱上JVM！！） | Lorain's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lorain's Blog" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">Lorain's Blog</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">JVM垃圾回收入门（爱上JVM！！）</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/posts/63f114ae.html">2024-01-30</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/JVM/">JVM</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><meta name="referrer" content="no-referrer" /><meta name="referrer" content="no-referrer" />

<h1 id="如何判断对象可回收"><a href="#如何判断对象可回收" class="headerlink" title="如何判断对象可回收"></a>如何判断对象可回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>如果一个对象被其他变量所引用，则让该对象的引用计数+1，如果该对象被引用2次则其引用计数为2，依次类推。<br>某个变量不再引用该对象，则让该对象的引用计数-1，当该对象的引用计数变为0时，则表示该对象没用被其他变量所引用，这时候该对象就可以被作为垃圾进行回收。<br>引用计数法弊端：循环引用时，两个对象的引用计数都为1，导致两个对象都无法被释放回收。最终就会造成内存泄漏！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706285104990-31a78b77-2fa1-4cdf-95ed-5796e62cca6f.png#averageHue=%23f8f8f7&clientId=u30874917-ba43-4&from=paste&height=173&id=ua318ec17&originHeight=346&originWidth=718&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41902&status=done&style=none&taskId=u5e50c46c-531b-4b80-8438-a79c782602a&title=&width=359" alt="image.png"></p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法：就是JVM中判断对象是否是垃圾的算法：该算法首先要确定GC Root(根对象，就是肯定不会被当成垃圾回收的对象)。<br>在垃圾回收之前，JVM会先对堆中的所有对象进行扫描，判断每一个对象是否能被GC Root直接或者间接的引用，如果能被根对象直接或间接引用则表示该对象不能被垃圾回收，反之则表示该对象可以被回收：<br>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象。<br>扫描堆中的对象，看能否沿着GC Root为起点的引用链找到该对象，如果找不到，则表示可以回收，否则就可以回收。<br>可以作为GC Root的对象：<br>虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象<br>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
<blockquote>
<p>可以理解成一个葡萄，从根出发能到达各个葡萄的位置。</p>
</blockquote>
<p>案例演示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286510162-965b841c-3f1b-4c05-90cc-da4fb616d941.png#averageHue=%23faf9f9&clientId=u9964b7dd-f54e-4&from=paste&height=636&id=uca5ea950&originHeight=1272&originWidth=2810&originalType=binary&ratio=2&rotation=0&showTitle=false&size=721676&status=done&style=none&taskId=u1b2faba7-4158-476c-b9ea-706e1393da6&title=&width=1405" alt="image.png"><br>这里在list1有无值两方面抓取快照。<br>然后通过eclipse提供的MAT工具来 <code>GCRoot</code>，哪些可以作为<code>GCRoot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286861093-06406389-103f-4a01-abf0-dad164d4f4de.png#averageHue=%23ece9e2&clientId=u9964b7dd-f54e-4&from=paste&height=262&id=u1d8e0269&originHeight=524&originWidth=1204&originalType=binary&ratio=2&rotation=0&showTitle=false&size=234129&status=done&style=none&taskId=ua9ee7593-c0ac-404a-9ca8-c06fc092092&title=&width=602" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286775480-81f7544c-d99f-44e1-aa5b-e186d932bc12.png#averageHue=%23eae8e2&clientId=u9964b7dd-f54e-4&from=paste&height=467&id=u08ab5f86&originHeight=934&originWidth=2308&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1147449&status=done&style=none&taskId=u7c022eb1-cce0-48fe-863b-fe141f1e59f&title=&width=1154" alt="image.png"><br>这些都可以作为<code>gcroot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287024040-9700c11d-1fcb-41df-9314-24ab95d9f363.png#averageHue=%23edede8&clientId=u9964b7dd-f54e-4&from=paste&height=761&id=u2aa131a4&originHeight=1522&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1286962&status=done&style=none&taskId=uefd0b948-48df-401f-84cc-eb2f1f850b0&title=&width=1273" alt="image.png"></p>
<ul>
<li>所以以后我们查看跟对象就可以通过MAT工具啦。</li>
</ul>
<h1 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341743263-6f3e11ef-731f-4948-9b2a-92758904999c.png#averageHue=%23dedad4&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=gTuV2&originHeight=1288&originWidth=2066&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1168397&status=done&style=none&taskId=u6b208f64-cea3-4c93-bf18-e96e793340f&title=&width=1033" alt="image.png"></p>
<h2 id="强软弱"><a href="#强软弱" class="headerlink" title="强软弱"></a>强软弱</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287702315-3b3cbca2-5e11-48e5-b188-6afc037d3d97.png#averageHue=%23f9f7f0&clientId=u9964b7dd-f54e-4&from=paste&height=614&id=u969b987b&originHeight=1228&originWidth=2376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=580538&status=done&style=none&taskId=u7a15e292-5bcc-4dc6-9b5a-2e578847c76&title=&width=1188" alt="image.png"></p>
<ul>
<li>强引用：对于A1对象，只有两个<code>GC Root</code>都不在引用它，才会释放。</li>
<li>软引用和弱引用，当内存不够的时候，看你就会释放A2,A3对象，之后软引用和弱引用就会进入到引用队列，如果要释放二者，就需要通过引用队列遍历，然后释放两个引用（因为它们俩也是对象）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287970236-c1deb335-9fff-415c-b008-8eb8b173eef1.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=583&id=ud2beb0e6&originHeight=1166&originWidth=2348&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472767&status=done&style=none&taskId=u18d56396-e792-44ca-8363-a3ffbab3f01&title=&width=1174" alt="image.png"></p>
<h2 id="虚终"><a href="#虚终" class="headerlink" title="虚终"></a>虚终</h2><ul>
<li>虚引用和终引用必须配合引用队列使 用</li>
</ul>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340580486-818f346a-e34f-4cad-8e88-343a2b7460d2.png#averageHue=%23f9f7f3&clientId=u9964b7dd-f54e-4&from=paste&height=339&id=u8641f669&originHeight=678&originWidth=1480&originalType=binary&ratio=2&rotation=0&showTitle=false&size=221705&status=done&style=none&taskId=ucca23a33-d880-46b3-80cc-d1963d16cf8&title=&width=740" alt="image.png"><br>当引用的对于ByteBuffer被回收以后，直接内存还没有被回收，虚引用对象（Cleaner)就会被放入到引用队列中，<br>然后就会由线程<code>ReferencHandler</code>定时去引用队列寻找是否有<code>Cleaner</code>对象，如果有，就会调用Cleaner对象的clean方法，而clean方法就会根据前面记录的直接内存地址，调用Unsafe.freeMemory()方法，来释放直接内存。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340798493-29f35654-5f12-4f6c-88e9-5b03b2f1eb25.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=316&id=u2f462385&originHeight=632&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=208623&status=done&style=none&taskId=uae20db02-e918-45e7-8dbc-ddc52855982&title=&width=754" alt="image.png"><br>总之虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存。<br>根据上面的图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用 队列中，然后调用它的clean方法来释放直接内存。</p>
<blockquote>
<p>可以回顾一下之前学的直接内存，和Cleaner底层原理。</p>
</blockquote>
<h3 id="终引用"><a href="#终引用" class="headerlink" title="终引用"></a>终引用</h3><p>所有的类都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341322729-5dbafcfd-a4af-4ee5-968a-f77ed1995c06.png#averageHue=%23faf8f6&clientId=u9964b7dd-f54e-4&from=paste&height=500&id=u1816a410&originHeight=1000&originWidth=2268&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275505&status=done&style=none&taskId=ub155ae2c-26a6-48c6-a24a-14e8f67e575&title=&width=1134" alt="image.png"><br>当一个对象重写了finalize方法，肯定是希望通过终结器应用释放。<br>例如上图，当A4对象没有强引用的时候，这时候会进行垃圾回收，虚拟机会对这个对象创建终结器引用，终结器应用会进入到引用队列，但这时候A4对象还没有被释放！！<br>只有当优先级很低的FinallizeHandler线程来应用队列寻找是否有终结器应用，然后调用A4对象的finallize()方法，在下一次垃圾回收的时候A4对象才会得到释放。</p>
<blockquote>
<p>所以也就有一个弊端，因为FinallizeHandler线程优先级很低，而且第一次内存回收的时候并不能完全释放。所以有时候对象迟迟得不到释放，内存就会一直被占用，所以这个终结器应用在日常用的并不多。</p>
</blockquote>
<hr>
<h2 id="软引用案例"><a href="#软引用案例" class="headerlink" title="软引用案例"></a>软引用案例</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347165062-a9a75e54-7b71-42cc-9407-bfccde1f4fc9.png#averageHue=%23f0ecdf&clientId=u9964b7dd-f54e-4&from=paste&height=508&id=u63d2e236&originHeight=1016&originWidth=2220&originalType=binary&ratio=2&rotation=0&showTitle=false&size=648652&status=done&style=none&taskId=u136180f6-a625-4acd-af36-d0755c7acb8&title=&width=1110" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347325360-08e2b093-3ff1-4595-9702-44c59b9ebafb.png#averageHue=%23fafaf8&clientId=u9964b7dd-f54e-4&from=paste&height=664&id=u7ab57e66&originHeight=1328&originWidth=2672&originalType=binary&ratio=2&rotation=0&showTitle=false&size=801552&status=done&style=none&taskId=u7e118bab-2526-4e05-906c-19afdfbf113&title=&width=1336" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347369906-fac8d4c4-76e5-4680-9be5-3f7a95d827ad.png#averageHue=%23fcfbfb&clientId=u9964b7dd-f54e-4&from=paste&height=551&id=u1923440c&originHeight=1102&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=439484&status=done&style=none&taskId=uaaff3dc5-e4fa-4dcc-948c-5d857a752d7&title=&width=1153" alt="image.png"><br>让我们细看一下细节。打印gc详情<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347638207-0bf901a4-88df-454f-90e1-857b6149be68.png#averageHue=%23e1dfd8&clientId=u9964b7dd-f54e-4&from=paste&height=473&id=u1690702f&originHeight=946&originWidth=2880&originalType=binary&ratio=2&rotation=0&showTitle=false&size=994686&status=done&style=none&taskId=uc35aa18b-e351-4c35-85db-91a4d54e303&title=&width=1440" alt="image.png"><br>所以在处理一些不重要的对象的时候，就可以通过软引用来降低内存压力。</p>
<h2 id="软引用-引用队列"><a href="#软引用-引用队列" class="headerlink" title="软引用_引用队列"></a>软引用_引用队列<img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348021334-2093d593-def0-49e1-81eb-2b2c3efa9a7b.png#averageHue=%23edece6&clientId=u9964b7dd-f54e-4&from=paste&height=446&id=u641eca1e&originHeight=892&originWidth=1680&originalType=binary&ratio=2&rotation=0&showTitle=false&size=524549&status=done&style=none&taskId=ucba936bc-e745-4ee3-86fe-70ef89a69d9&title=&width=840" alt="image.png"></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347973037-6d201545-2b9b-467c-b5e2-000e71b58f26.png#averageHue=%23f1eee1&clientId=u9964b7dd-f54e-4&from=paste&height=605&id=uc14935a2&originHeight=1210&originWidth=2628&originalType=binary&ratio=2&rotation=0&showTitle=false&size=635074&status=done&style=none&taskId=u6478809c-8762-44e2-bd04-5b2c42d8562&title=&width=1314" alt="image.png"></p>
<h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348447712-e4db3f90-ab7a-4edc-9622-a70b6db345fa.png#averageHue=%23eeece3&clientId=u9964b7dd-f54e-4&from=paste&height=600&id=u7b445252&originHeight=1200&originWidth=2416&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1236319&status=done&style=none&taskId=u9773bbed-0dbb-41ca-8e06-23ff6565402&title=&width=1208" alt="image.png"><br>弱引用一般会发生在垃圾回收的时候，当内存紧张时，就会回收弱引用对象，同时也会回收弱引用自身。</p>
<h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>首先有两步</p>
<ul>
<li>先标记哪些对象可以是垃圾</li>
<li>然后清除垃圾回收对象（这里的腾出内存空间并不是将内存空间的字节清 0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。）</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349164883-994f2c35-6859-427d-8ddd-5453e0629fba.png#averageHue=%23f8f8f6&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=ua8b12acc&originHeight=1288&originWidth=1782&originalType=binary&ratio=2&rotation=0&showTitle=false&size=295572&status=done&style=none&taskId=ua30e9cb0-4773-46f5-9471-13046710775&title=&width=891" alt="image.png"></p>
<h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349501497-21a252ea-cc5b-467e-a68f-b982d7752814.png#averageHue=%23f8f8f7&clientId=ud1c445ad-4364-4&from=paste&height=510&id=u69fd961f&originHeight=1020&originWidth=2166&originalType=binary&ratio=2&rotation=0&showTitle=false&size=383709&status=done&style=none&taskId=u5d3ff6a0-6269-496a-8da3-286446eb84e&title=&width=1083" alt="image.png">会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是牵扯到对象的整理移动，需要消耗一定的时间，所以效率较低。 </p>
<h2 id="复制回收"><a href="#复制回收" class="headerlink" title="复制回收"></a>复制回收</h2><ul>
<li>第一步，分两个区，From区和 To区</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349661483-d9b3176e-5827-49f4-bdf9-0b4b679c3ccc.png#averageHue=%23faf9f8&clientId=ud1c445ad-4364-4&from=paste&height=204&id=uc1ec8f95&originHeight=408&originWidth=1534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128470&status=done&style=none&taskId=uceee1eac-d330-46ba-9fad-52660c0ff8a&title=&width=767" alt="image.png"></p>
<ul>
<li>第二步，将From区存活的对象复制到To区，完成碎片的整理</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349713486-70ce3114-9d57-4f04-b3ad-67d6f577fcad.png#averageHue=%23f6f6f6&clientId=ud1c445ad-4364-4&from=paste&height=200&id=uffb1c45b&originHeight=400&originWidth=1430&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126655&status=done&style=none&taskId=uecf4a7da-fbf5-4b88-a812-41e5cd0df2a&title=&width=715" alt="image.png"></p>
<ul>
<li>第三步，交换From区和To区，使To区总是空闲的一块空间</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349723740-6b5d89dd-5c39-447d-9858-49eeb46cf6c7.png#averageHue=%23f9f9f8&clientId=ud1c445ad-4364-4&from=paste&height=183&id=u0fec0796&originHeight=366&originWidth=1472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128196&status=done&style=none&taskId=u8c7d6052-9e5f-4483-8d43-b9b7fe02819&title=&width=736" alt="image.png"><br>复制算法：将内存分为等大小的两个区域，<strong>FROM</strong>和<strong>TO</strong>（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。<strong>这样也可以避免内存碎片的问题，但是会占用双倍的内存空间</strong>。</p>
<h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><p>长时间使用的对象放在老年代中（长时间回收一次，回收花费时间久），在内存不足的时候也可能回收，用完即可丢弃的对象放在新生代中（频繁需要回收，回收速度相对较快）：</p>
<h2 id="堆内存大致分为两块："><a href="#堆内存大致分为两块：" class="headerlink" title="堆内存大致分为两块："></a>堆内存大致分为两块：</h2><p>新生代、老年代；新生代又划分为伊甸园、幸存区from、幸存区to。<br>长时间使用的对象放在老年代中，用完了就丢弃的对象放在新生代中。根据对象生命周期的不同特点，采用不同的垃圾回收算法，老年代发生次数少，新生代比较频繁。不同区域采用不同算法，更有效的对垃圾回收进行管理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881007627-58238735-ea09-46ba-8a18-eb949359a3d5.png#averageHue=%23f8f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=287&id=uc287fade&originHeight=359&originWidth=1575&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68146&status=done&style=none&taskId=u7422b092-03c8-4cc3-ba33-46651a1163b&title=&width=1260" alt="image.png"></p>
<h2 id="分代垃圾回收怎么工作："><a href="#分代垃圾回收怎么工作：" class="headerlink" title="分代垃圾回收怎么工作："></a>分代垃圾回收怎么工作：</h2><p>java虚拟机本身就是一个小的操作系统吧？</p>
<ul>
<li>新创建的对象首先分配在 伊甸园 区；</li>
<li>伊甸园 区空间不足时，触发 minor gc ，使用可达性分析算法沿着GC root引用链去找，进行标记的动作；</li>
<li>采用复制算法将 伊甸园 区 和幸存区from 区存活的对象复制到幸存区to 中，存活的对象年龄加一，然后交换 from to（这里很细节，实际变的不是两块物理地址，而是指针引用）；</li>
<li>minor gc 会引发 stop the world，因为垃圾回收的时候对象地址发生改变，如果其他线程也在运行，会造成混乱。暂停其他线程，等垃圾回收结束后，恢复用户线程运行；</li>
<li>新生代触发的STW的时间较短  </li>
<li>每次minorGC后，eden和from对象都清除干净了 </li>
<li>每次都把不需要回收和幸存区from留下的移到To中，然后交换From和To的位置</li>
<li>当幸存区to对象的寿命超过阈值时，会晋升到老年代，最大寿命是15（4bit）</li>
<li>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li>
<li>如果老年代空间不足时，会先尝试触发 minor gc，如果空间仍然不足，那么就触发 full fc ，STW停止的时间更长！</li>
<li>from和to每次都要留一个空的，空间不足就触发gc，还不足就会触发提前晋升老年代，老年代如果放不下先触发full gc 然后再尝试提前晋升，还不行就Java heap space outofmemoryerror异常</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881771672-021f9d70-7ed1-45bb-a8b4-669bee5ffa8f.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=638&id=uc808cb5a&originHeight=798&originWidth=1573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161287&status=done&style=none&taskId=u8cb047b9-4dfd-4147-ac34-1ff98b7e2ec&title=&width=1258.4" alt="image.png"></p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><p>**含义	 **                                      <strong>参数</strong><br>堆初始大小	                      -Xms<br>堆最大大小	                      -Xmx 或 -XX:MaxHeapSize&#x3D;size<br>新生代大小	                      -Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )<br>幸存区比例（动态）	       -XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy<br>幸存区比例	                      -XX:SurvivorRatio&#x3D;ratio<br>晋升阈值	                              -XX:MaxTenuringThreshold&#x3D;threshold<br>晋升详情	                              -XX:+PrintTenuringDistribution<br>GC详情	                             -XX:+PrintGCDetails -verbose:gc<br>FullGC 前 MinorGC	              -XX:+ScavengeBeforeFullGC</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>程序刚加载时的堆内存情况：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648887378100-37e3a00f-3c41-43d5-8c39-92f11622161a.png#averageHue=%23dfdfd7&clientId=u64d6ddc7-8e02-4&from=paste&height=215&id=a9BI9&originHeight=269&originWidth=1365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=285016&status=done&style=none&taskId=udf81d81a-5c97-47f1-8349-81474096d8f&title=&width=1092" alt="image.png"></p>
<ul>
<li>代码分析</li>
</ul>
<p>通过如下代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，什么时候 幸存区放不下，直接晋升老年代，使用前需要设置 jvm 参数。</p>
<pre><code class="java">public class Code_10_GCTest &#123;

    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    public static void main(String[] args) &#123;
        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_6MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_6MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_6MB]);
    &#125;
&#125;
</code></pre>
<ul>
<li>大对象处理策略：</li>
</ul>
<p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371753545-75535f45-80d2-489c-8f35-d314afe78f87.png#averageHue=%23e8e5db&clientId=uf95f9f13-d64b-4&from=paste&height=553&id=u38548cc0&originHeight=1106&originWidth=2760&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1337545&status=done&style=none&taskId=u54c391be-757f-44d5-8341-db97e939c9a&title=&width=1380" alt="image.png"></p>
<ul>
<li>线程内存溢出：</li>
</ul>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行<br>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371871415-adbf0b45-1eca-4777-b023-54ef6b489891.png#averageHue=%23e9e6dc&clientId=uf95f9f13-d64b-4&from=paste&height=440&id=ufb6758c1&originHeight=880&originWidth=2612&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1083308&status=done&style=none&taskId=u9cfd524a-0556-40ac-9981-6ac5abb0606&title=&width=1306" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371900932-82995376-8d3f-41fe-bd9a-ca5458dec7aa.png#averageHue=%23edeae1&clientId=uf95f9f13-d64b-4&from=paste&height=505&id=u0aa26855&originHeight=1010&originWidth=2768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1449389&status=done&style=none&taskId=u4d7acb62-58d5-4aa4-b142-34e636f4208&title=&width=1384" alt="image.png"></p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706404931105-79675091-00d1-4596-afff-336934f7f63b.png#averageHue=%23fcfcfc&clientId=uf95f9f13-d64b-4&from=paste&height=350&id=u11683edb&originHeight=700&originWidth=1396&originalType=binary&ratio=2&rotation=0&showTitle=false&size=178508&status=done&style=none&taskId=u3728362f-4a56-439f-85b8-564cf624063&title=&width=698" alt="image.png"> </p>
<h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p> 在谈论垃圾收集器的上下文语境中， 它们可以理解为：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>并行（Parallel） ：<br>并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>并发（Concurrent） ：<br> 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行（不一定是并行的可能会交替执行）。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。 </p>
<h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><p>即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p>
<h2 id="1）串行"><a href="#1）串行" class="headerlink" title="1）串行"></a>1）串行</h2><p>单线程<br>适用于堆内存较小，如个人电脑（CPU核数较少也可以，因为单线程）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648902517820-ef16f7d9-6770-4e5a-a046-a0e24fb4d5c5.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=405&id=ZMcbG&originHeight=506&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138942&status=done&style=none&taskId=u83ad8bce-fe92-4f80-9ae8-05716981832&title=&width=1027.2" alt="image.png"></p>
<pre><code class="java">-XX:+UseSerialGC=serial + serialOld
</code></pre>
<h3 id="安全点："><a href="#安全点：" class="headerlink" title="安全点："></a>安全点：</h3><p>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p>
<h3 id="Serial-收集器："><a href="#Serial-收集器：" class="headerlink" title="Serial 收集器："></a>Serial 收集器：</h3><p>Serial 收集器是最基本的、发展历史最悠久的收集器<br>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p>
<h3 id="ParNew-收集器："><a href="#ParNew-收集器：" class="headerlink" title="ParNew 收集器："></a>ParNew 收集器：</h3><ul>
<li>ParNew 收集器其实就是 Serial 收集器的多线程版本</li>
<li>除了Serial收集器外， 目前只有它能与CMS收集器配合工作。 </li>
<li>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</li>
</ul>
<h3 id="Serial-Old-收集器："><a href="#Serial-Old-收集器：" class="headerlink" title="Serial Old 收集器："></a>Serial Old 收集器：</h3><p>Serial Old 是 Serial 收集器的老年代版本<br>特点：同样是单线程收集器，采用标记-整理算法</p>
<p>在服务端模式下，它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用</p>
<h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><p><strong>parallel：并行的   Pause：停顿</strong></p>
<ul>
<li>多线程</li>
<li>适合堆内存较大，需要多核 cpu支持</li>
<li>让单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li>JDK1.8默认使用的垃圾回收器</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648905756956-5700f0dd-4a7a-4a73-b0b2-844407cd7d14.png#averageHue=%23fbfafa&clientId=u64d6ddc7-8e02-4&from=paste&height=633&id=UuKmC&originHeight=791&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=332475&status=done&style=none&taskId=u7778844b-e4a1-4067-b788-23755ea24c4&title=&width=1096.8" alt="image.png"></p>
<pre><code class="java">//第一个是新生代的垃圾回收器,复制算法；第二个是老年代的垃圾回收器，标记整理算法
//都是多线程的，只要开启一个，另外一个就会开启
//工作开启的回收线程数目，与cpu核数有关。回收时，cpu占有率100%
-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC  
-XX:+UseAdaptiveSizePolicy   //GC自适应调节策略，伊甸园和幸存区占比
-XX:GCTimeRatio=ratio  // 垃圾回收和总时间占比 1/(1+radio)
-XX:MaxGCPauseMillis=ms  //  垃圾回收暂停200ms
-XX:ParallelGCThreads=n   //回收线程数 控制
</code></pre>
<h3 id="Parallel-Scavenge-收集器："><a href="#Parallel-Scavenge-收集器：" class="headerlink" title="Parallel Scavenge 收集器："></a>Parallel Scavenge 收集器：</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值 。</p>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器<br>特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）</p>
<h3 id="GC自适应调节策略："><a href="#GC自适应调节策略：" class="headerlink" title="GC自适应调节策略："></a>GC自适应调节策略：</h3><p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、<br>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p>
<h3 id="Parallel-Scavenge-收集器使用两个参数控制吞吐量："><a href="#Parallel-Scavenge-收集器使用两个参数控制吞吐量：" class="headerlink" title="Parallel Scavenge 收集器使用两个参数控制吞吐量："></a>Parallel Scavenge 收集器使用两个参数控制吞吐量：</h3><p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）：<br><strong>回收器一般会让堆变小，减少每次停顿的时间</strong><br>XX:GCTimeRatio&#x3D;radio 垃圾收集时间占总时间的比率，相当于吞吐量的倒数<br><strong>回收器一般会让堆变大，去减少垃圾回收次数，从而减少时间</strong></p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本<br>特点：多线程，采用标记-整理算法</p>
<h2 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h2><ul>
<li>CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 </li>
<li>CMS作为老年代的收集器，新生代只能选择ParNew或者Serial收集器中的一个来配合工作。</li>
<li>多线程</li>
<li>适合堆内存较大，需要多核 cpu支持</li>
<li>面向并发设计的程序都对处理器资源比较敏感。 在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648890886592-6db2f622-b3fb-443a-b8fd-7e7f4a023df6.png#averageHue=%23f9f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=485&id=u5ffb9327&originHeight=606&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347954&status=done&style=none&taskId=u34ec76e5-2f38-4258-b48f-49a9f14f81a&title=&width=1040" alt="image.png"></p>
<h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><pre><code class="java">//第一个CMS是并发标记清除算法，用户线程与垃圾回收线程并发进行，老年代浮动垃圾过多，退化为 SerialOld
//第二个是parnew新生代多线程回收器
-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld

//第一个是并行的垃圾回收线程数，一般跟cpu核数一样；第二个是并发的垃圾回收线程数,一般设置为并行线程数的四分之一
//比如：核数为4，那就占用一个cpu核进行垃圾回收。其他用于用户线程
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads

//同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。
//设置得太高将会很容易导致大量的并发失败产生，性能反而降低;
//设置太低将导致内存回收频率增加，性能降低
-XX:CMSInitiatingOccupancyFraction=percent

//重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力
-XX:+CMSScavengeBeforeRemark
</code></pre>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器<br>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片<br>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p>
<h3 id="CMS-收集器的运行过程分为下列4步："><a href="#CMS-收集器的运行过程分为下列4步：" class="headerlink" title="CMS 收集器的运行过程分为下列4步："></a>CMS 收集器的运行过程分为下列4步：</h3><h4 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h4><p>标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</p>
<h4 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h4><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p>
<h4 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h4><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题，这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短。</p>
<h4 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h4><p>并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的 </p>
<h3 id="浮动垃圾："><a href="#浮动垃圾：" class="headerlink" title="浮动垃圾："></a>浮动垃圾：</h3><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。 </p>
<h3 id="并发失败："><a href="#并发失败：" class="headerlink" title="并发失败："></a>并发失败：</h3><h4 id="浮动垃圾过多："><a href="#浮动垃圾过多：" class="headerlink" title="浮动垃圾过多："></a>浮动垃圾过多：</h4><p>如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p>
<h4 id="内存碎片过多："><a href="#内存碎片过多：" class="headerlink" title="内存碎片过多："></a>内存碎片过多：</h4><p>CMS是一款基于“标记-清除”算法实现的收集器， 这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。 退化为SerialOld，进行标记整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。  </p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410637194-2dbc95a7-b84c-402d-874b-57919eb1efd7.png#averageHue=%23f9f9f8&clientId=ub86ce6bc-f0e5-4&from=paste&height=668&id=u7218fd82&originHeight=1336&originWidth=1768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=544533&status=done&style=none&taskId=ufe5e1cb2-722f-4b3f-bc4b-a6f653613a2&title=&width=884" alt="image.png"><br><strong>相关参数</strong>：JDK8 并不是默认开启的，需要参数开启：</p>
<pre><code class="java">// G1开关
-XX:+UseG1GC
// 所划分的每个堆内存大小：
-XX:G1HeapRegionSize=size
// 垃圾回收最大停顿时间
-XX:MaxGCPauseMillis=time
</code></pre>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410858075-d732e623-989c-4cc7-8178-1b6b1c57cd1b.png#averageHue=%23faf8f4&clientId=ub86ce6bc-f0e5-4&from=paste&height=548&id=u5ca16fdb&originHeight=1096&originWidth=1560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=379155&status=done&style=none&taskId=ud0fa9d8a-81b3-498e-a14f-4875a606ea3&title=&width=780" alt="image.png"><br><strong>新生代伊甸园垃圾回收</strong>—–&gt;<strong>内存不足，新生代回收+并发标记</strong>—–&gt;<strong>回收新生代伊甸园、幸存区、老年代内存</strong>——&gt;<strong>新生代伊甸园垃圾回收</strong>(重新开始)。</p>
<h3 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706426885157-a745faef-0948-4621-b83d-0196c3b9fa80.png#averageHue=%23f2efec&clientId=u27dd8642-2384-4&from=paste&height=686&id=ud84899dd&originHeight=1372&originWidth=1934&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472988&status=done&style=none&taskId=u3c3bd328-bfb4-45ed-87d2-3a283a1a749&title=&width=967" alt="image.png"></p>
<h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>会对E、S 、O 进行<strong>全面的回收</strong>。</p>
<ul>
<li>最终标记</li>
<li><strong>拷贝</strong>存活</li>
</ul>
<pre><code class="java">//  用于指定GC最长的停顿时间
-XX:MaxGCPauseMillis=ms
</code></pre>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？<br>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的最大停顿时间，会根据最大停顿时间，有选择的<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）。<br>G1在老年代内存不足时（老年代所占内存超过阈值）：</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理。</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC。</li>
</ul>
<h3 id="FullGC概念解析"><a href="#FullGC概念解析" class="headerlink" title="FullGC概念解析"></a>FullGC概念解析</h3><p><strong>SerialGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>ParallelGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>CMS</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍<br><strong>G1</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Lorain</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/posts/63f114ae.html">https://blog.lorainjay.icu/posts/63f114ae.html</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://blog.lorainjay.icu">Lorain的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">如何判断对象可回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">五种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%BD%AF%E5%BC%B1"><span class="toc-number">2.1.</span> <span class="toc-text">强软弱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%88"><span class="toc-number">2.2.</span> <span class="toc-text">虚终</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">终引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">软引用案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">软引用_引用队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">弱引用对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%9B%9E%E6%94%B6"><span class="toc-number">3.3.</span> <span class="toc-text">复制回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.</span> <span class="toc-text">分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E8%87%B4%E5%88%86%E4%B8%BA%E4%B8%A4%E5%9D%97%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">堆内存大致分为两块：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">分代垃圾回收怎么工作：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC"><span class="toc-number">5.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">相关参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">相关概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">6.1.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9A"><span class="toc-number">6.1.3.</span> <span class="toc-text">吞吐量：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E4%B8%B2%E8%A1%8C"><span class="toc-number">6.2.</span> <span class="toc-text">1）串行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9A"><span class="toc-number">6.2.1.</span> <span class="toc-text">安全点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">Serial 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">6.2.3.</span> <span class="toc-text">ParNew 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">6.2.4.</span> <span class="toc-text">Serial Old 收集器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">6.3.</span> <span class="toc-text">吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">6.3.1.</span> <span class="toc-text">Parallel Scavenge 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E8%8A%82%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">6.3.2.</span> <span class="toc-text">GC自适应调节策略：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%8E%A7%E5%88%B6%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9A"><span class="toc-number">6.3.3.</span> <span class="toc-text">Parallel Scavenge 收集器使用两个参数控制吞吐量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.3.4.</span> <span class="toc-text">Parallel Old 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">6.4.</span> <span class="toc-text">响应时间优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">6.4.1.</span> <span class="toc-text">参数设置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.2.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E4%B8%BA%E4%B8%8B%E5%88%974%E6%AD%A5%EF%BC%9A"><span class="toc-number">6.4.3.</span> <span class="toc-text">CMS 收集器的运行过程分为下列4步：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">初始标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">并发标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">6.4.3.3.</span> <span class="toc-text">重新标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4%EF%BC%9A"><span class="toc-number">6.4.3.4.</span> <span class="toc-text">并发清除：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%EF%BC%9A"><span class="toc-number">6.4.4.</span> <span class="toc-text">浮动垃圾：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%B1%E8%B4%A5%EF%BC%9A"><span class="toc-number">6.4.5.</span> <span class="toc-text">并发失败：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%E8%BF%87%E5%A4%9A%EF%BC%9A"><span class="toc-number">6.4.5.1.</span> <span class="toc-text">浮动垃圾过多：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E8%BF%87%E5%A4%9A%EF%BC%9A"><span class="toc-number">6.4.5.2.</span> <span class="toc-text">内存碎片过多：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1"><span class="toc-number">6.5.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">6.5.1.</span> <span class="toc-text">回收阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-number">6.5.2.</span> <span class="toc-text">Young Collection + CM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixed-Collection"><span class="toc-number">6.5.3.</span> <span class="toc-text">Mixed Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FullGC%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">6.5.4.</span> <span class="toc-text">FullGC概念解析</span></a></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/posts/20748c35.html">&lt; 泛型在项目中不怎么用？这次结合实战！</a><a class="next" href="/posts/e614237b.html">JVM内存结构 &gt;</a></div></section><footer><p>Copyright © 2016 - 2024 <a href="/." rel="nofollow">Lorain's Blog</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>