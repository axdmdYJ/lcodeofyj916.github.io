<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>点评项目实战 | Lorain's Blog</title><meta name="author" content="Lorain"><meta name="copyright" content="Lorain"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="短信登录发送验证码     @Override     public Result sendCode(String phone, HttpSession session) &amp;#123;        &#x2F;&#x2F; 1. 检验手机号码是否有效         if (RegexUtils.isPhoneInvalid(phone))&amp;#123;             return Result.fai">
<meta property="og:type" content="article">
<meta property="og:title" content="点评项目实战">
<meta property="og:url" content="https://axdmdyj.github.io/posts/6bd5204f.html">
<meta property="og:site_name" content="Lorain&#39;s Blog">
<meta property="og:description" content="短信登录发送验证码     @Override     public Result sendCode(String phone, HttpSession session) &amp;#123;        &#x2F;&#x2F; 1. 检验手机号码是否有效         if (RegexUtils.isPhoneInvalid(phone))&amp;#123;             return Result.fai">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tse1-mm.cn.bing.net/th/id/OIP-C.ggP8vzkJJJUluo3rx6Ul2gHaEo?rs=1&pid=ImgDetMain">
<meta property="article:published_time" content="2023-11-20T11:17:34.000Z">
<meta property="article:modified_time" content="2024-03-05T03:26:51.030Z">
<meta property="article:author" content="Lorain">
<meta property="article:tag" content="点评项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tse1-mm.cn.bing.net/th/id/OIP-C.ggP8vzkJJJUluo3rx6Ul2gHaEo?rs=1&pid=ImgDetMain"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://axdmdyj.github.io/posts/6bd5204f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '点评项目实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-05 11:26:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/menu_center.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lorain's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='https://unpkg.com/plasx@1.0.3/img/bj.webp'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tse1-mm.cn.bing.net/th/id/OIP-C.ggP8vzkJJJUluo3rx6Ul2gHaEo?rs=1&amp;pid=ImgDetMain')"><nav id="nav"><span id="blog-info"><a href="/" title="Lorain's Blog"><span class="site-name">Lorain's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">点评项目实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-20T11:17:34.000Z" title="发表于 2023-11-20 19:17:34">2023-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-05T03:26:51.030Z" title="更新于 2024-03-05 11:26:51">2024-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="点评项目实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801356928-1038c401-76d3-4029-9ade-1af6e5c0280f.png#averageHue=%23e9e9e6&clientId=u023eb198-87b4-4&from=paste&height=538&id=u539f0ea2&originHeight=673&originWidth=300&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94508&status=done&style=none&taskId=ub2bffcf8-da03-4137-8da5-73895a1347d&title=&width=240" alt="image.png"></p>
<pre><code class="java">    @Override
    public Result sendCode(String phone, HttpSession session) &#123;
       // 1. 检验手机号码是否有效
        if (RegexUtils.isPhoneInvalid(phone))&#123;
            return Result.fail(&quot;手机号码无效&quot;);
        &#125;
        //2. 生成验证码
        String code = RandomUtil.randomNumbers(6);

        // 3. 保存到session中
        session.setAttribute(&quot;code&quot;, code);

        //4. 发送验证码
        log.debug(&quot;发送验证码成功, 验证码是:&#123;&#125;&quot;, code);

        // 5. 返回成功
        return Result.ok();
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801410162-5c8e46f4-74f7-42f6-8895-eef95eed91e9.png#averageHue=%23fcf6f5&clientId=u023eb198-87b4-4&from=paste&height=474&id=ufa498d0e&originHeight=593&originWidth=1366&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58225&status=done&style=none&taskId=u603ec55b-759d-49f3-8cbb-8911b4f3cac&title=&width=1092.8" alt="image.png"><br>将生成的验证码根据key-value的形式存入redis</p>
<blockquote>
<p>这里有一个小细节：<br><strong>这里虽然后端配置的端口时8081，但这里的请求仍然时8080，是因为前端使用nginx，反向代理，请求先发送到了nginx服务，然后反向代理再去请求tomcat服务器</strong></p>
</blockquote>
<p>补充：</p>
<blockquote>
<p>@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。<br>@Autowired只根据type进行注入，不会去匹配name</p>
</blockquote>
<h2 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825277887-0fd5dc23-0660-4ee6-b1dc-3bc7caa0ae8e.png#averageHue=%23eeeaea&clientId=u8fd209ed-60a0-4&from=paste&height=500&id=u90d93351&originHeight=500&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61551&status=done&style=none&taskId=ub8f396b4-717d-45a7-94b3-93c30f8ce35&title=&width=400" alt="image.png"></p>
<pre><code class="java"> @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;
        // 检验手机格式
        String phone = loginForm.getPhone();
        if(RegexUtils.isPhoneInvalid(phone))&#123;
            return Result.fail(&quot;手机号格式错误&quot;);
        &#125;
        // 2. 校验验证码
        String code = loginForm.getCode();
        if (code==null  || !code.equals(session.getAttribute(&quot;code&quot;)))&#123;
            // 3. 校验验证码失败
            Result.fail(&quot;验证码错误&quot;);
        &#125;
        // 3. 根据手机号查询用户
        User user =  query().eq(&quot;phone&quot;, phone).one();
        // 用户不存在
        if (user == null)&#123;
           user =  createUserWithPhone(phone);
        &#125;
        // 4. 用户存在, 保存到session中
        session.setAttribute(&quot;user&quot;, user);

        return Result.ok();
    &#125;
</code></pre>
<h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825445004-a6016290-a7e2-4fe7-9ad2-5baf4d03322f.png#averageHue=%23f5f4f4&clientId=u8fd209ed-60a0-4&from=paste&height=936&id=ubc9ca8c3&originHeight=936&originWidth=2111&originalType=binary&ratio=1&rotation=0&showTitle=false&size=390396&status=done&style=none&taskId=u281196a9-354a-4025-af73-c4739038dc8&title=&width=2111" alt="image.png"><br>这么做有问题, 当Controller层多的时候, 这样的业务逻辑就都得重写,<br>&#x3D;&gt; 可以加一个拦截器来解决<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825629609-6369cd15-7ea9-4cdf-ba2c-80283907b44e.png#averageHue=%23f2ebea&clientId=u8fd209ed-60a0-4&from=paste&height=785&id=uc48a18cc&originHeight=981&originWidth=2229&originalType=binary&ratio=1&rotation=0&showTitle=false&size=299850&status=done&style=none&taskId=u74fe0f76-4930-4709-9978-758d1c82770&title=&width=1783.2" alt="image.png"><br>每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<pre><code class="java">package com.hmdp.utils;

import com.hmdp.dto.Result;
import com.hmdp.dto.UserDTO;
import com.hmdp.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import com.hmdp.utils.UserHolder;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
@Slf4j
public class LoginInterceptor implements HandlerInterceptor &#123;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
       Object user = request.getSession().getAttribute(&quot;user&quot;);
       if (user == null)&#123;
          response.setStatus(401);
          return false;
       &#125;
        UserHolder.saveUser((UserDTO) user);
        return true;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
       UserHolder.removeUser();
    &#125;
&#125;
</code></pre>
<p>配置:</p>
<pre><code class="java">package com.hmdp.config;


import com.hmdp.utils.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new  LoginInterceptor()).excludePathPatterns(
                &quot;/shop/**&quot;,
                &quot;/voucher/**&quot;,
                &quot;/shop-type/**&quot;,
                &quot;/blog/hot&quot;,
                &quot;/user/code&quot;,
                &quot;/user/login&quot;,
                &quot;/upload/**&quot;
        );
    &#125;
&#125;
</code></pre>
<p>注意隐藏信息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828563629-a0f2d4c2-f931-4571-995d-dca9ebd7cd72.png#averageHue=%232c2b2b&clientId=u8fd209ed-60a0-4&from=paste&height=192&id=u967c724b&originHeight=192&originWidth=1256&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22166&status=done&style=none&taskId=u27b2f1ae-fd8f-4669-bf8c-0d819eefc48&title=&width=1256" alt="image.png"></p>
<blockquote>
<p>注意BeanUtil和BeanUtils区别</p>
</blockquote>
<p>使用ThreadLocal</p>
<blockquote>
<p><strong>ThreadLocal</strong>：为每个线程提供一份单独存储空间，只有在线程内才能获取对应的值</p>
</blockquote>
<pre><code class="java">package com.hmdp.utils;

import com.hmdp.dto.UserDTO;

public class UserHolder &#123;
    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();

    public static void saveUser(UserDTO userId)&#123;
        tl.set(userId);
    &#125;

    public static UserDTO getUser()&#123;
        return tl.get();
    &#125;

    public static void removeUser()&#123;
        tl.remove();
    &#125;
&#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828260112-414e2510-ddfd-49e5-984f-097b13fee144.png#averageHue=%23fcfaf9&clientId=u8fd209ed-60a0-4&from=paste&height=667&id=u63ffab52&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34061&status=done&style=none&taskId=udb64cb68-f96c-40d8-9d43-adfa17565b0&title=&width=375" alt="image.png"></p>
<h2 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h2><p>多台tomcat服务器之间并不共享数据, 容易造成切换服务器数据丢失的问题<br>session的替代方案应满足:</p>
<ul>
<li>数据共享</li>
<li>内存存储</li>
<li>key value结构</li>
</ul>
<p>解决办法 &#x3D;&gt; redis</p>
<h2 id="基于redis实现session共享登录"><a href="#基于redis实现session共享登录" class="headerlink" title="基于redis实现session共享登录"></a>基于redis实现session共享登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698829850748-a6352f14-367c-419a-abb1-32da0047725d.png#averageHue=%23c5918e&clientId=u8fd209ed-60a0-4&from=paste&height=1053&id=ueaf61fbb&originHeight=1053&originWidth=1799&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391683&status=done&style=none&taskId=ue0eea36f-38a4-41fc-9fd2-1f329f33447&title=&width=1799" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698846050148-bff23449-9187-4ead-8533-d7f57e910afd.png#averageHue=%23efeae9&clientId=u5a170d56-888a-4&from=paste&height=1108&id=u1c766697&originHeight=1108&originWidth=2089&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496399&status=done&style=none&taskId=u9056657b-38a3-48ca-8a27-07f62fd1dcb&title=&width=2089" alt="image.png"></p>
<h2 id="基于redis实现短信登录"><a href="#基于redis实现短信登录" class="headerlink" title="基于redis实现短信登录"></a>基于redis实现短信登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699027861571-80106832-60b3-4bee-a610-0de8c9ccd0b1.png#averageHue=%23ece6e6&clientId=uc77679ca-2224-4&from=paste&height=751&id=u5e8e06ac&originHeight=939&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208747&status=done&style=none&taskId=u69fc68a2-4a66-4abc-ba34-971cb892e11&title=&width=504" alt="image.png"><br>先生成UUID<br>转换成HashMap存储<br>存储token<br>设置有效期</p>
<pre><code class="java">//        // 4. 用户存在, 保存到session中
//        session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));
        // 保存用户信息到Redis中
        String token = UUID.randomUUID().toString();
        log.debug(&quot;token:&#123;&#125;&quot;,token);

        // 转换HashMap存储
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);

        Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO);

        String tokenKey = LOGIN_USER_KEY+token;
        stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);
        //设置token有效期  
        stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);
        return Result.ok(token);
</code></pre>
<p><strong>但这段代码没有更新token有效期:</strong><br>在preHandle中实现;</p>
<pre><code class="java">    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
       String token =  request.getHeader(&quot;authorization&quot;);
       //判断用户是否存在
       if (StrUtil.isBlank(token))&#123;
          response.setStatus(401);
          return false;
       &#125;
       // 基于token获取Hash数据的用户
        String tokenKey = RedisConstants.LOGIN_USER_KEY+token;
        Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);
        // 判断用户是否存在
        if (userMap.isEmpty())&#123;
            response.setStatus(401);
            return false;
        &#125;
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(),false);

        //保存
        UserHolder.saveUser(userDTO);
        // 刷新token有效期
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        //放行
        return true;
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031051581-9951aaef-bd4b-4f9d-9379-a1a44e51acfe.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=758&id=ub014d843&originHeight=947&originWidth=1814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146553&status=done&style=none&taskId=ua7d97c5d-ce29-44e6-a456-623f2a888f5&title=&width=1451.2" alt="image.png"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq3434569/article/details/113940767">使用Hutool的BeanUtil优雅的讲Map转为javaBean_beanutil map转对象-CSDN博客</a><br>但是会报错服务器异常<br>解决:<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031558738-b9faeca0-1063-41b7-9d18-c10d1aeb77bc.png#averageHue=%232d2c2c&clientId=uc77679ca-2224-4&from=paste&height=561&id=u94138825&originHeight=701&originWidth=1708&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118546&status=done&style=none&taskId=u0b8c18e8-4e47-446b-b156-004339a07a6&title=&width=1366.4" alt="image.png"></p>
<pre><code class="java"> Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(),
                CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((filename, fileValue)-&gt; fileValue.toString())
                );
</code></pre>
<h2 id="拦截器优化"><a href="#拦截器优化" class="headerlink" title="拦截器优化"></a>拦截器优化</h2><p><strong>问题: 如果用户访问一些不需要登录的界面, 那么过期时间到了之后, 就会自动退出登录</strong><br>**解决办法: **</p>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698916213005-332df564-3b55-43a9-a60f-74d549dcbbbf.png#averageHue=%23e8d7d4&clientId=uc0c97467-78c9-4&from=paste&height=611&id=ud9121bae&originHeight=1222&originWidth=2366&originalType=binary&ratio=2&rotation=0&showTitle=false&size=671865&status=done&style=none&taskId=u1b7bf3be-3c11-424d-9b49-642a36aac1d&title=&width=1183" alt="image.png"></p>
<pre><code class="java">public class RefreshIntercepter implements HandlerInterceptor &#123;
    private StringRedisTemplate stringRedisTemplate;

    public RefreshIntercepter(StringRedisTemplate stringRedisTemplate)&#123;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        String token =  request.getHeader(&quot;authorization&quot;);
        //判断用户是否存在
        if (StrUtil.isBlank(token))&#123;`
            return true;
        &#125;
        // 基于token获取Hash数据的用户
        String tokenKey = RedisConstants.LOGIN_USER_KEY+token;
        Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);
        // 判断用户是否存在
        if (userMap.isEmpty())&#123;
            return true;
        &#125;
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(),false);

        //保存
        UserHolder.saveUser(userDTO);
        // 刷新token有效期
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        //放行
        return true;
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033166224-6b311249-d8ac-4919-8bfb-01fde2904928.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=460&id=u7eeb875c&originHeight=575&originWidth=1535&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85465&status=done&style=none&taskId=u5687a791-fddf-43ee-82f9-4c29ac5ba08&title=&width=1228" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033178566-858b9d04-7fa0-40c5-b495-538b8e77d349.png#averageHue=%232c2c2b&clientId=uc77679ca-2224-4&from=paste&height=382&id=u40b497e8&originHeight=478&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56335&status=done&style=none&taskId=uc9b1de4c-840a-493c-9bf1-1db531df6cb&title=&width=1007.2" alt="image.png"></p>
<h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>临时存储数据的地方<br><strong>缓存的作用: 降低后端负载,降低响应时间, 应对更多的并发请求</strong><br><strong>缓存的成本: 数据一致性成本, 代码维护下成本, 运维成本</strong></p>
<h2 id="添加用户缓存"><a href="#添加用户缓存" class="headerlink" title="添加用户缓存"></a>添加用户缓存</h2><pre><code>  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/38717174/1699082099728-62ad2f9e-259c-4e25-9e18-fcdce88f80cc.png#averageHue=%23f2f1f1&amp;clientId=u603f9972-ee0f-4&amp;from=paste&amp;height=826&amp;id=uec12dec0&amp;originHeight=1032&amp;originWidth=2120&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=398838&amp;status=done&amp;style=none&amp;taskId=u16271973-331e-47ac-b1d3-c7926ef6e65&amp;title=&amp;width=1696)
</code></pre>
<pre><code class="java">  @Resource
    StringRedisTemplate stringRedisTemplate;
    @Override
    public Result queryById(Long id) &#123;
        String key  = CACHE_SHOP_KEY +id;
        // 从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);

        // 判断是否存在

        //如果存在, 返回商铺信息
        if(StrUtil.isNotBlank(shopJson))&#123;
            Shop shop = JSONUtil.toBean(shopJson,Shop.class);
            return  Result.ok(shop);
        &#125;
        //如果不存在, 查询数据库
        Shop shop = getById(id);
        // 判断数据库信息是否存在

        //不存在则返回404
        if (shop == null)&#123;
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;
        // 存在, 则将商品信息写入redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));
        return Result.ok(shop);
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699084036007-5f956627-b2b8-44ae-9dcb-cb15421c3fe5.png#averageHue=%23a3a2a2&clientId=uae1f6871-ad73-4&from=paste&height=500&id=ub61c05fe&originHeight=625&originWidth=1707&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=151609&status=done&style=none&taskId=uf1d67d00-ee1a-4615-a71f-20d43375455&title=&width=1365.6" alt="image.png"></p>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>由于数据库数据改变,而缓存中数据没有改变,造成用户从缓存中得到的数据与数据库中的数据不一致<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103143774-ea4905f1-7972-4462-a657-662e7c59b612.png#averageHue=%23e1cdcc&clientId=uae1f6871-ad73-4&from=paste&height=598&id=uc5a9af08&originHeight=748&originWidth=2065&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=272856&status=done&style=none&taskId=u4a9bfdfe-d102-4ff0-882b-fe301ffa8f4&title=&width=1652" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103259583-b9059fb3-2054-4d80-9340-ec3db709035e.png#averageHue=%23f0f0f0&clientId=uae1f6871-ad73-4&from=paste&height=199&id=ud4e5ebb2&originHeight=249&originWidth=1550&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137644&status=done&style=none&taskId=u733c391e-4a63-4269-868c-1d176ea5381&title=&width=1240" alt="image.png"><br>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。<br><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),但是当时间很长,缓存就不会被更新<br><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存<br>如果在设置的时间内,数据库发生变化,也会导致数据库不一致<br>**主动更新： 在修改数据库的同时,更新缓存 **我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题,<br><strong>主动更新业务实现:</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699108883261-845c3698-3df3-4bc3-af21-c6ee09a080bc.png#averageHue=%23f4f3f3&clientId=uae1f6871-ad73-4&from=paste&height=791&id=u99508fb0&originHeight=989&originWidth=2221&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=364799&status=done&style=none&taskId=ueb35e8bf-0e9a-4a31-a62a-732f7099e79&title=&width=1776.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109050443-3b914bfa-4354-40e2-a38e-e6c7188835bd.png#averageHue=%23f5f4f4&clientId=uae1f6871-ad73-4&from=paste&height=751&id=u932f7a09&originHeight=939&originWidth=2206&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=545799&status=done&style=none&taskId=u93e3d3fa-f060-4ce1-b661-eaa94b08374&title=&width=1764.8" alt="image.png"></p>
<p><strong>缓存安全问题</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109457009-b58327fb-1853-4230-8fae-c80c6d23bf87.png#averageHue=%23f3f2f2&clientId=uae1f6871-ad73-4&from=paste&height=828&id=u65c2a515&originHeight=1035&originWidth=2001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357984&status=done&style=none&taskId=ub9fec107-412a-436c-8def-1419a45a991&title=&width=1600.8" alt="image.png"><br>方案二相对来说发生概率低一些, 同时也可以加入超时时间, 万一发生旧数据进入 缓存,也可以进行清除<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109497850-cc021bf3-3261-4972-af61-43df6990d8fa.png#averageHue=%23f1f1f1&clientId=uae1f6871-ad73-4&from=paste&height=563&id=uc77f74fc&originHeight=704&originWidth=1252&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276299&status=done&style=none&taskId=uf8d14cb0-461a-40f3-b58f-de404a6a33a&title=&width=1001.6" alt="image.png"></p>
<h2 id="实现商品缓存和数据库一致"><a href="#实现商品缓存和数据库一致" class="headerlink" title="实现商品缓存和数据库一致"></a>实现商品缓存和数据库一致</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150811280-843ac537-e79d-4bef-9afa-eacc07858936.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=550&id=u454baf3b&originHeight=687&originWidth=1805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106945&status=done&style=none&taskId=udb5f5a95-64d9-4f70-b5fa-552a75064d5&title=&width=1444" alt="image.png"></p>
<pre><code class="java">  @Override
    @Transactional
    public Result update(Shop shop) &#123;
        if (shop.getId()==null)&#123;
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;
        // 更新数据库
        updateById(shop);
        //删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());

        return Result.ok();
    &#125;
</code></pre>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150935337-7bba4650-cf0c-4b03-8c06-936b79a49b78.png#averageHue=%23fbfbfb&clientId=u8a7806e8-b16d-4&from=paste&height=716&id=u6d0ceee5&originHeight=895&originWidth=2130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170185&status=done&style=none&taskId=uea060b02-c509-4ab6-ab89-910cf0bcb89&title=&width=1704" alt="image.png"><br>如果通过并发,无限到达数据库, 就容易给数据库弄垮<br><strong>解决办法</strong></p>
<ol>
<li><strong>数据库返回NUll对象,缺点是有额外的内存消耗(可以设置TTL解决)</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151041627-5b3c3aea-5d04-4717-8afc-d6622bd35dc9.png#averageHue=%23fafafa&clientId=u8a7806e8-b16d-4&from=paste&height=576&id=uab32b173&originHeight=720&originWidth=1646&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172693&status=done&style=none&taskId=u32000052-6e1e-429a-b628-48817bc2525&title=&width=1316.8" alt="image.png"></p>
<ol start="2">
<li><strong>布隆过滤器</strong></li>
</ol>
<p>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151188719-0e6360f7-7e8f-4ef4-b388-f2f880690a5a.png#averageHue=%23f7f4f2&clientId=u8a7806e8-b16d-4&from=paste&height=589&id=u8698caf1&originHeight=736&originWidth=641&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143003&status=done&style=none&taskId=u5dfcd73b-9d0f-4f28-a98c-ee4dc90faa2&title=&width=512.8" alt="image.png"><br>通过哈希算法,将计算出来的放到布隆过滤器, 但有一点的穿透风险</p>
<h2 id="编码解决缓存穿透问题"><a href="#编码解决缓存穿透问题" class="headerlink" title="编码解决缓存穿透问题"></a>编码解决缓存穿透问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151426970-975a19c5-190a-4cbc-9cb8-7730a4e0eeae.png#averageHue=%23eeeceb&clientId=u8a7806e8-b16d-4&from=paste&height=724&id=ufd2bf6d2&originHeight=905&originWidth=2216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=489525&status=done&style=none&taskId=ud00847b5-9d3d-4995-92a5-3208ec8b719&title=&width=1772.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699152411753-22724bfd-50be-4397-a9d3-de819dfb08c6.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=821&id=ueccd8b74&originHeight=1026&originWidth=1725&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=182832&status=done&style=none&taskId=ucfa5cf87-6015-449d-abdb-63ddb17a991&title=&width=1380" alt="image.png"></p>
<pre><code class="java">  public Result queryById(Long id) &#123;
        String key  = CACHE_SHOP_KEY +id;
        // 从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);

        // 判断是否存在

        //如果存在, 返回商铺信息
        if(StrUtil.isNotBlank(shopJson))&#123;
            Shop shop = JSONUtil.toBean(shopJson,Shop.class);
            return  Result.ok(shop);
        &#125;
        // 判断命中的是否是空值
        if (shopJson != null)&#123;
            Result.fail(&quot;店铺不存在&quot;);
        &#125;
        //如果不存在, 查询数据库
        Shop shop = getById(id);
        // 判断数据库信息是否存在

        //不存在则返回404
        if (shop == null)&#123;
            stringRedisTemplate.opsForValue().set(key, null, CACHE_NULL_TTL,TimeUnit.MINUTES);
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;
        // 存在, 则将商品信息写入redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return Result.ok(shop);
    &#125;
</code></pre>
<p>shopJson !&#x3D; null改成shopJson&#x3D;&#x3D;”” 会好理解一些<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151837524-18fef19d-e4f4-44a6-9d1b-59bd831ed3b5.png#averageHue=%23f3f3f3&clientId=u8a7806e8-b16d-4&from=paste&height=606&id=ua6e3adc9&originHeight=757&originWidth=1159&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=258097&status=done&style=none&taskId=u63150d66-1512-4adc-8e89-cde31dd00fd&title=&width=927.2" alt="image.png"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时段大量的缓存key同时失效或者redis服务宕机, 导致大量请求数据库, 带来巨大的压力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699156133884-03a9e60a-e486-4753-855f-cb3d665e4f55.png#averageHue=%23f4f1f1&clientId=u8a7806e8-b16d-4&from=paste&height=708&id=u21bd2e8b&originHeight=885&originWidth=2131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=428063&status=done&style=none&taskId=ud80e8200-7410-4930-a7a7-94d2a5fff06&title=&width=1704.8" alt="image.png"></p>
<h2 id="2-8-缓存击穿"><a href="#2-8-缓存击穿" class="headerlink" title="2.8 缓存击穿"></a>2.8 缓存击穿</h2><p>某一个key在同一时间内被多次访问,这个key突然失效了, 就会在这个时间给数据库带来巨大的冲击力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699164935235-f9e69e3a-9839-4988-bcf3-05fcc8bbe7e5.png#averageHue=%23eee7e0&clientId=u8a7806e8-b16d-4&from=paste&height=634&id=uedae8863&originHeight=792&originWidth=1375&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=184549&status=done&style=none&taskId=u07604b7c-d211-4032-a2fb-2c54e505ba2&title=&width=1100" alt="image.png"><br>线程1 本来是想查询数据库载入缓存, 但这时候同时又线程2, 3, 4 同时访问缓存, 都没有查到数据, 那么就会造成多个线程同时访问数据的情况 , 从而给数据带来巨大的压力.<br><strong>解决办法</strong></p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165112699-f82c55bc-80d4-4901-93de-d12a6cc22f19.png#averageHue=%23f0efee&clientId=u8a7806e8-b16d-4&from=paste&height=885&id=u2a142e12&originHeight=1106&originWidth=858&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237978&status=done&style=none&taskId=ua33f7dbc-07cd-42f0-ba18-f5706ab877c&title=&width=686.4" alt="image.png"></p>
<ul>
<li>缓存过期</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165423813-dc9dfe19-82d4-4c5f-be78-48ffd666753d.png#averageHue=%23eae4e3&clientId=u4e51b1c4-2b80-4&from=paste&height=850&id=u953941fc&originHeight=1062&originWidth=1273&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=295603&status=done&style=none&taskId=ucbf9f236-40c4-4475-ac4c-726224769e3&title=&width=1018.4" alt="image.png"><br>返回的是过期的数据<br><strong>对比</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165463393-d285571e-7568-4c7e-9424-8f549a8680ba.png#averageHue=%23e5cecd&clientId=u4e51b1c4-2b80-4&from=paste&height=741&id=uedc66771&originHeight=926&originWidth=2075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=217678&status=done&style=none&taskId=u83a615ea-ced1-49ae-8338-90263514659&title=&width=1660" alt="image.png"></p>
<h2 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699171874898-e4083975-1612-4c7b-b4e8-9ffb2336aa1f.png#averageHue=%23faf7f7&clientId=uad14f619-a4eb-4&from=paste&height=655&id=ud00ad32f&originHeight=819&originWidth=1703&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266694&status=done&style=none&taskId=uc956f7fb-48f5-4dfc-8727-1924bce78e9&title=&width=1362.4" alt="image.png">在多个线程并行执行的时候需要达到一个效果, 一个成功, 其他失败的效果<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699172055792-65c7c469-65fa-41f5-92dc-60fef825831e.png#averageHue=%230b2138&clientId=uad14f619-a4eb-4&from=paste&height=526&id=u02efe0ef&originHeight=657&originWidth=998&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=379673&status=done&style=none&taskId=ue71c7007-c3ba-448e-8a7a-5540e3405fc&title=&width=798.4" alt="image.png"></p>
<pre><code class="java"> public boolean  tryLock(String key)&#123;
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10L, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    &#125;
    private   void delLock(String key)&#123;
        stringRedisTemplate.delete(key);
    &#125;
</code></pre>
<pre><code class="java"> public Shop queryWithMutex(Long id)&#123;
        String key  = CACHE_SHOP_KEY +id;
        // 从redis查询商铺缓存 	
        String shopJson = stringRedisTemplate.opsForValue().get(key);

        // 判断是否存在

        //如果存在, 返回商铺信息
        if(StrUtil.isNotBlank(shopJson))&#123;
            Shop shop = JSONUtil.toBean(shopJson,Shop.class);
            return shop;
        &#125;
        // 判断命中的是否是空值
        if (shopJson == &quot;&quot;)&#123;
            Result.fail(&quot;店铺不存在&quot;);
        &#125;
        //1.如果不存在, 尝试获取互斥锁
        String lock_key = &quot;lock:shop&quot;+key;
        boolean flag = tryLock(lock_key);
        // 1.1 判断是否获取锁
        //1.2 没有获得互斥锁=&gt;  休眠
        Shop shop = null;
        try &#123;
            if (!flag)&#123;
                Thread.sleep(50);
                return queryWithMutex(id);
            &#125;
            //1.3 获得互斥锁=&gt; 根据id查询数据库
            shop = getById(id);
            // 判断数据库信息是否存在

            //不存在则返回错误信息
            if (shop == null)&#123;
                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);
                return null;
            &#125;
            //1.4 将商铺数据写入redis
            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //1.5 释放互斥锁
            delLock(key);
        &#125;

        return shop;
    &#125;
</code></pre>
<h2 id="利用逻辑过期方式解决缓存击穿问题"><a href="#利用逻辑过期方式解决缓存击穿问题" class="headerlink" title="利用逻辑过期方式解决缓存击穿问题"></a>利用逻辑过期方式解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699193223625-18f4022d-72dd-473e-86e0-ab6d318323eb.png#averageHue=%23f8f4f4&clientId=uad14f619-a4eb-4&from=paste&height=707&id=u720bf9b2&originHeight=884&originWidth=1892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=451704&status=done&style=none&taskId=uc3f96aaf-10d2-4b74-a921-dae73e262f4&title=&width=1513.6" alt="image.png"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012448904/article/details/84292821">https://blog.csdn.net/u012448904/article/details/84292821</a></p>
<pre><code class="java"> private void saveShop2RedisData(Long id, Long expireTime)&#123;
        // 查询店铺数据
        Shop shop = getById(id);
        //封装逻辑过期时间
        RedisData redisData = new RedisData();
        redisData.setData(shop);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireTime));
        // 将数据写入redis, 并设置过期时间
       stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));

    &#125;
</code></pre>
<pre><code class="java">  private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
</code></pre>
<pre><code class="java">  public Shop queryWithLogicalExpire(Long id)&#123;
        String key  = CACHE_SHOP_KEY +id;
        // 从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);

        // 1.判断是否存在

        //1.1 如果不存在
        if (StrUtil.isBlank(shopJson))&#123;
            return null;
        &#125;
        //1.2如果命中, 先把Json反序列化为对象
        RedisData redisData =  JSONUtil.toBean(shopJson, RedisData.class);
        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);
        LocalDateTime expireTime = redisData.getExpireTime();
        //2. 判断缓存是否过期
        // 2.1 如果没有过期, 返回商品信息
       if (expireTime.isAfter(LocalDateTime.now()))&#123;
           return shop;
       &#125;
       // 3. 如果过期, 则需要缓存重建
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 3.1 如果获取到了互斥锁
        try &#123;
            if (isLock)&#123;
                //开启独立线程, 实现缓存重建
                CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;
                    //重建缓存
                    this.saveShop2RedisData(id,20L);
                &#125;);
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            // 释放锁
            delLock(lockKey);
        &#125;
        // 如果过期, 则直接返回商品信息
        return shop;
    &#125;
</code></pre>
<h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699232522556-19d223a8-d12d-4403-85b3-b930bfb9f710.png#averageHue=%23ebebeb&clientId=ud845c73b-0205-4&from=paste&height=336&id=cd6f7&originHeight=672&originWidth=2300&originalType=binary&ratio=2&rotation=0&showTitle=false&size=362660&status=done&style=none&taskId=u169a78f1-9a1c-491f-9414-b91bb3abcdd&title=&width=1150" alt="image.png"><br>封装后的<code>CacheClient</code></p>
<pre><code class="java">package com.hmdp.utils;

import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSONObject;
import cn.hutool.json.JSONUtil;
import com.hmdp.dto.Result;
import com.hmdp.entity.Shop;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.yaml.snakeyaml.events.Event;

import java.time.LocalDateTime;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import static com.hmdp.utils.RedisConstants.*;

@Slf4j
@Component
public class CacheClient &#123;
     private StringRedisTemplate stringRedisTemplate;
     private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
     public CacheClient(StringRedisTemplate stringRedisTemplate)&#123;
          this.stringRedisTemplate = stringRedisTemplate;
     &#125;
     public void set(String key, Object value, Long time, TimeUnit timeUnit)&#123;
          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);
     &#125;
     // 设置逻辑过期时间
     public void  setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit)&#123;

          RedisData redisData = new RedisData();
          redisData.setData(value);
          redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
          // 写入redis
          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value));
     &#125;
     public &lt;R,ID&gt; R queryWithThrough(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack
     ,Long time, TimeUnit timeUnit)&#123;
          String key  = prefix +id;
          // 从redis查询商铺缓存
          String json = stringRedisTemplate.opsForValue().get(key);

          // 判断是否存在

          //如果存在, 返回商铺信息
          if(StrUtil.isNotBlank(json))&#123;
          // 存在, 直接返回
               return JSONUtil.toBean(json, type);
          &#125;
          // 判断命中的是否是空值
          if (json == &quot;&quot;)&#123;
               Result.fail(&quot;店铺不存在&quot;);
          &#125;
          //如果不存在, 查询数据库
          R r = dbFailBack.apply(id);
          // 判断数据库信息是否存在

          //不存在则返回错误信息
          if (r == null)&#123;
               stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);
               return null;
          &#125;
          // 存在, 则将商品信息写入redis
         this.set(key,r, time, timeUnit);
          return r;
     &#125;
     // 逻辑过期解决缓存击穿
     public &lt;R,ID&gt;R queryWithLogicalExpire(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack
             ,Long time, TimeUnit timeUnit)&#123;
          String key  = prefix +id;
          // 从redis查询商铺缓存
          String json = stringRedisTemplate.opsForValue().get(key);
          // 1.判断是否存在
          //1.1 如果不存在
          if (StrUtil.isBlank(json))&#123;
               return null;
          &#125;
          //1.2如果命中, 先把Json反序列化为对象
          RedisData redisData =  JSONUtil.toBean(json, RedisData.class);
          R r = JSONUtil.toBean((JSONObject)redisData.getData(), type);
          LocalDateTime expireTime = redisData.getExpireTime();
          //2. 判断缓存是否过期
          // 2.1 如果没有过期, 返回商品信息
          if (expireTime.isAfter(LocalDateTime.now()))&#123;
               return r;
          &#125;
          // 3. 如果过期, 则需要缓存重建
          String lockKey = LOCK_SHOP_KEY + id;
          boolean isLock = tryLock(lockKey);
          // 3.1 如果获取到了互斥锁
          try &#123;
               if (isLock)&#123;
                    R r1 = dbFailBack.apply(id);
                    //开启独立线程, 实现缓存重建
                    CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;
                         //重建缓存
                         this.setWithLogicalExpire(key,r1,time,timeUnit);
                    &#125;);
               &#125;
          &#125; catch (Exception e) &#123;
               throw new RuntimeException(e);
          &#125; finally &#123;
               // 释放锁
               delLock(lockKey);
          &#125;
          // 如果过期, 则直接返回商品信息
          return r;
     &#125;
     public boolean  tryLock(String key)&#123;
          Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10L, TimeUnit.SECONDS);
          return BooleanUtil.isTrue(flag);
     &#125;
     private  void delLock(String key)&#123;
          stringRedisTemplate.delete(key);
     &#125;

&#125;
</code></pre>
<dl><dt>里面分别封装了解决缓存穿透和逻辑过期解决缓存击穿的两个函数<br>在通过逻辑过期解决缓存击穿问题中遇到入<code>   R r = JSONUtil.toBean((JSONObject)redisData.getData(), type);</code>  <code>redisData</code>为空的情况</dt><dd>解决办法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/uiguion/article/details/106047677">JSONObject.toBean()方法转成对象报错，或者bean属性全为null-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372507632-4139d56e-787c-4399-a44d-abc6640a24fb.png#averageHue=%239c7544&clientId=u03392ae4-edfa-4&from=paste&height=325&id=uaa40b9c8&originHeight=325&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53374&status=done&style=none&taskId=uc57e265d-757a-444a-8936-5e6c833c53c&title=&width=1401" alt="image.png"><br>不要小写</dd></dl><p>使用Redis工具类:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372542710-3d357c3b-7365-49fd-9a33-4f850fb63e14.png#averageHue=%232d2c2c&clientId=u03392ae4-edfa-4&from=paste&height=374&id=u87a92367&originHeight=374&originWidth=1629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57706&status=done&style=none&taskId=u4d0ee664-0235-4b98-9707-755d8d45d63&title=&width=1629" alt="image.png"></p>
<blockquote>
<p>在逻辑过期中,封装了<code>RedisData</code>是为了将数据和其对应的过期时间封装到一起处理 	</p>
</blockquote>
<h2 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h2><h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而 订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>当把表进行拆分, 也会破坏这种唯一性<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699426255848-40136d31-4503-444f-9155-5fafaf1a0bdc.png#averageHue=%23fbf2f2&clientId=u03392ae4-edfa-4&from=paste&height=166&id=u64d05cd3&originHeight=208&originWidth=1134&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19066&status=done&style=none&taskId=ucef96a17-421f-4ead-98a3-0f7b4f44969&title=&width=907.2" alt="image.png"><br>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p> 时间戳：31bit，以秒为单位，可以使用69年<br>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<pre><code class="java">@Component
public class RedisWorker &#123;
    /**
     * 开始时间戳
     */
    private static final long BEGIN_TIMESTAMP = 1640995200L;
    /**
     * 序列号的位数
     */
    private static final int COUNT_BITS = 32;
    StringRedisTemplate stringRedisTemplate;
    public RedisWorker(StringRedisTemplate stringRedisTemplate)&#123;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;


    public  long nextId(String prefix)&#123;
        //1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        //2. 生成序列号,精确到天,确保序列号不会被占满
        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));

        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot;+prefix+&quot;:&quot;+date);
        //拼接并返回
        return timestamp&lt;&lt;COUNT_BITS|  ;
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699451963201-96d090a8-10c9-45e5-a77d-09a80bc9bb70.png#averageHue=%23f3f7f1&clientId=u03392ae4-edfa-4&from=paste&height=464&id=u92c542a6&originHeight=580&originWidth=2065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=372721&status=done&style=none&taskId=u9b6d7e2b-ddcc-439b-8c70-4f17bf917b9&title=&width=1652" alt="image.png"></p>
<pre><code class="java"> @Test
    void testIdWorker() throws InterruptedException &#123;
        CountDownLatch latch = new CountDownLatch(300);

        Runnable task = () -&gt; &#123;
            for (int i = 0; i &lt; 100; i++) &#123;
                long id = redisWorker.nextId(&quot;order&quot;);
                System.out.println(&quot;id = &quot; + id);
            &#125;
            latch.countDown();
        &#125;;
        long begin = System.currentTimeMillis();
        for (int i = 0; i &lt; 300; i++) &#123;
            es.submit(task);
        &#125;
        latch.await();
        long end = System.currentTimeMillis();
        System.out.println(&quot;time = &quot; + (end - begin));
    &#125;
</code></pre>
<h2 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h2><p>平价券<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453018061-98e0c0ec-7b51-47c7-804a-3ad046f592e0.png#averageHue=%23f6f8f6&clientId=u03392ae4-edfa-4&from=paste&height=394&id=u52d9c459&originHeight=493&originWidth=1525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=584380&status=done&style=none&taskId=u68370840-18ab-4403-9307-b8ec30147fc&title=&width=1220" alt="image.png"><br><strong>秒杀券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453049584-e0e2bbd2-5e0f-4db2-a0b7-300f056d5300.png#averageHue=%23eef0ed&clientId=u03392ae4-edfa-4&from=paste&height=301&id=ude83893e&originHeight=376&originWidth=1463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=406404&status=done&style=none&taskId=u307cfd87-d489-4177-a9b4-6bdc1093625&title=&width=1170.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699452886736-1cc3a40d-139d-4581-a74a-c8c5686c823b.png#averageHue=%23f1ecea&clientId=u03392ae4-edfa-4&from=paste&height=837&id=udf628ffe&originHeight=1046&originWidth=1904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557282&status=done&style=none&taskId=uf05654fe-beef-48a5-9b31-98eb188f656&title=&width=1523.2" alt="image.png"></p>
<h2 id="实现优惠券秒杀的下单功能"><a href="#实现优惠券秒杀的下单功能" class="headerlink" title="实现优惠券秒杀的下单功能"></a>实现优惠券秒杀的下单功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699491830080-d020dec5-6734-4da9-b359-0d0d60d22824.png#averageHue=%23faf8f8&clientId=u62c8c1ac-49eb-4&from=paste&height=718&id=ue1b324d1&originHeight=898&originWidth=1497&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=239141&status=done&style=none&taskId=uaacbd06a-3e0a-4874-bab7-52087d33fd3&title=&width=1197.6" alt="image.png"></p>
<h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512912475-448ad530-a79a-493a-9a1b-6ff8dd9c0d1b.png#averageHue=%23ddded5&clientId=ua529897f-17be-4&from=paste&height=143&id=ua95713de&originHeight=286&originWidth=1642&originalType=binary&ratio=2&rotation=0&showTitle=false&size=211099&status=done&style=none&taskId=u58c38c8c-22d1-47c6-893c-b66827e1164&title=&width=821" alt="image.png"><br>在高并发的场景下， 库存变成了负数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512954758-1083414b-371d-4821-8cee-70cde0636ffa.png#averageHue=%23637aa8&clientId=ua529897f-17be-4&from=paste&height=396&id=u4af4cf38&originHeight=792&originWidth=1996&originalType=binary&ratio=2&rotation=0&showTitle=false&size=471026&status=done&style=none&taskId=u99d7ebdc-d14a-4f3a-ad94-da9355b9a8f&title=&width=998" alt="image.png"><br>说明这一块的逻辑是有问题的<br>先查询-&gt;判断-&gt;减库存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513390567-d0602fd3-5f64-43a2-8adc-94ad44a21d21.png#averageHue=%23f5f5f5&clientId=ua529897f-17be-4&from=paste&height=612&id=ue45a8fd8&originHeight=1224&originWidth=2534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=309881&status=done&style=none&taskId=u5b1e322d-15c6-4a68-a1b6-66f01a9da12&title=&width=1267" alt="image.png"><br><strong>解决方案：</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513646487-c306a577-0758-45bb-aae4-9e238dee5241.png#averageHue=%23f4f3f3&clientId=uaa6d1fb2-8a9a-4&from=paste&height=505&id=u4f34f58b&originHeight=1010&originWidth=2378&originalType=binary&ratio=2&rotation=0&showTitle=false&size=584418&status=done&style=none&taskId=uf944ddba-4b79-47a7-80de-6a14b5bab2b&title=&width=1189" alt="image.png"><br>乐观锁不用去加锁，而是在执行时才做判断，因此性能高</p>
<p><strong>乐观锁：</strong></p>
<ul>
<li>**版本号法： **</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513930001-21760dc2-af8c-4d02-a702-e3c765847dd6.png#averageHue=%23fafafa&clientId=uaa6d1fb2-8a9a-4&from=paste&height=511&id=u581002a7&originHeight=1022&originWidth=2538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=406163&status=done&style=none&taskId=u03c7ed5e-fb7d-47f6-854d-24371d40d2c&title=&width=1269" alt="image.png"><br>通过版本号来查是否需要-1，来避免超卖问题  </p>
<ul>
<li><strong>CAS</strong>优化版本号</li>
</ul>
<p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699514621548-7c59ea00-55dc-4562-a416-74a211905a37.png#averageHue=%23fbfbfb&clientId=uaa6d1fb2-8a9a-4&from=paste&height=540&id=ubb7b39b4&originHeight=1080&originWidth=2496&originalType=binary&ratio=2&rotation=0&showTitle=false&size=373639&status=done&style=none&taskId=u0ffb655f-ec53-4e13-899d-3537570f4bd&title=&width=1248" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517224445-eea01797-f3b5-4895-a5f9-3e793409fd3d.png#averageHue=%23f2f7ef&clientId=u757ca0cc-a2af-4&from=paste&height=444&id=u6a5ec8e4&originHeight=888&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=739428&status=done&style=none&taskId=u690bc5ae-1e68-435d-9b63-fd67f80d615&title=&width=1273" alt="image.png"><br> <strong>但是这样就会有一个问题：当stock不为1的时候， 看stock来确定扣不扣减，就会造成更多人抢不到优惠券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517619198-ba7b27ab-fea1-41bc-a470-87d9fcf71017.png#averageHue=%23f8f8f8&clientId=u757ca0cc-a2af-4&from=paste&height=204&id=u30b15279&originHeight=408&originWidth=1876&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44498&status=done&style=none&taskId=ua120d0fb-d33f-4f68-b8c5-5ffd2253dc6&title=&width=938" alt="image.png">** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517538369-c1b3a1cc-e780-4aec-a3ac-9d7096938cf4.png#averageHue=%23f0f5eb&clientId=u757ca0cc-a2af-4&from=paste&height=140&id=ua90beb84&originHeight=280&originWidth=1962&originalType=binary&ratio=2&rotation=0&showTitle=false&size=277162&status=done&style=none&taskId=ue5bae5be-56b8-45d4-9984-881f5a5c952&title=&width=981" alt="image.png"><br>如果<code>stock&gt;0</code>,就可以购买优惠券</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517838400-7ed70785-bf23-4533-a7c6-fae87940f329.png#averageHue=%23efefef&clientId=u757ca0cc-a2af-4&from=paste&height=333&id=u09d910b9&originHeight=666&originWidth=1222&originalType=binary&ratio=2&rotation=0&showTitle=false&size=232094&status=done&style=none&taskId=u3f41d4e9-e1f4-4df0-a6a8-270e463319b&title=&width=611" alt="image.png"></p>
<blockquote>
<p>对于更高并发的场景下， 光这样使用乐观锁是远远不够的， 需要进行进一步优化，</p>
</blockquote>
<h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699518088817-4d0d4240-ae7d-479a-bec9-a4e3bf28bd6f.png#averageHue=%23fbf9f9&clientId=u757ca0cc-a2af-4&from=paste&height=562&id=ufa5d2047&originHeight=1124&originWidth=2036&originalType=binary&ratio=2&rotation=0&showTitle=false&size=361555&status=done&style=none&taskId=ueffa5321-5918-4f42-966e-a1d7dbe937d&title=&width=1018" alt="image.png"><br>事务失效的情况:<br>加锁<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699693153645-12717c5e-49c8-4d75-92f6-ce805fa03602.png#averageHue=%23f0f5ef&clientId=u2b828817-5288-4&from=paste&height=842&id=u873f76a6&originHeight=842&originWidth=1957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=512561&status=done&style=none&taskId=u89ad8637-7e27-4b78-b23e-60e3f15831a&title=&width=1957" alt="image.png"></p>
<pre><code class="java"> @Override
    @Transactional
    public Result seckillVoucher(Long voucherId) &#123;
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern())&#123;
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        &#125;
    &#125;
        public Result createVoucherOrder(Long voucherId)&#123;
            // 1. 提交优惠券id
            //2. 查询优惠券信息
            SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
            //3. 判断秒杀是否开始
            //3.1 如果没有开始, 返回异常结果
            if (voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;
                Result.fail(&quot;秒杀尚未开始&quot;);
            &#125;
            // 3.2 判断秒杀是否已经结束
            if (LocalDateTime.now().isAfter(voucher.getEndTime()))&#123;
                Result.fail(&quot;秒杀已经结束&quot;);
            &#125;
            // 4. 秒杀开始, 判断库存是否充足
            if (voucher.getStock() &lt; 1)&#123;
                //4.1 不足, 返回异常结果
                Result.fail(&quot;库存不足&quot;);
            &#125;
            // 实现一人一单
            Long userId = UserHolder.getUser().getId();
            int count = query().eq(&quot;user_id&quot;,userId).eq(&quot;voucher_id&quot;,voucherId).count();
            if (count &gt; 0)&#123;
                Result.fail(&quot;用户已经购买过一次&quot;);
            &#125;
            //4.2 充足, 扣减库存
            boolean isSuccess = seckillVoucherService.update().setSql(&quot;stock=stock-1&quot;)
                    .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;,0) // 如果大于0就能购买优惠券
                    .update();
            if (!isSuccess)&#123;
                return  Result.fail(&quot;库存不足&quot;);
            &#125;
            //4.3 创建订单
            VoucherOrder voucherOrder = new VoucherOrder();
            long orderId = redisWorker.nextId(&quot;order&quot;);
            voucherOrder.setId(orderId);

            voucherOrder.setUserId(userId);

            voucherOrder.setVoucherId(voucherId);
            save(voucherOrder);
            //4.4 返回订单id

            return Result.ok(orderId);
        &#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanjiaqian/article/details/120501741">【精选】spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常_hanjq_code的博客-CSDN博客</a></p>
<h2 id="一人一单并发安全问题"><a href="#一人一单并发安全问题" class="headerlink" title="一人一单并发安全问题"></a>一人一单并发安全问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699705699282-d6e5cfc6-d0b1-4692-9045-b3bd7c1752b0.png#averageHue=%23f0eded&clientId=u2b828817-5288-4&from=paste&height=990&id=u2b5403a6&originHeight=990&originWidth=2087&originalType=binary&ratio=1&rotation=0&showTitle=false&size=506190&status=done&style=none&taskId=u76807860-0e90-4ec5-ace9-4f40d89a0bc&title=&width=2087" alt="image.png"><br>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763384484-e83248bd-53cc-43e6-b5b2-1aa92f9982c2.png#averageHue=%23f4f2f2&clientId=u2b828817-5288-4&from=paste&height=864&id=ufa6eb578&originHeight=1080&originWidth=2262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=482845&status=done&style=none&taskId=uf703bade-d8ba-409f-ba8e-9c0101b0700&title=&width=1809.6" alt="image.png"><br>让多个JVM都能看到同一个锁监视器<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763801336-f81b5646-caff-4432-bfb4-7ddf5afaa5a9.png#averageHue=%23e4d5d5&clientId=u2b828817-5288-4&from=paste&height=1001&id=uc6a8dd14&originHeight=1001&originWidth=2209&originalType=binary&ratio=1&rotation=0&showTitle=false&size=366621&status=done&style=none&taskId=u9cb2dfa0-cdd0-4344-9431-950df9bda81&title=&width=2209" alt="image.png"></p>
<h2 id="Redis分布式锁实现思路"><a href="#Redis分布式锁实现思路" class="headerlink" title="Redis分布式锁实现思路"></a>Redis分布式锁实现思路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huo065000/article/details/119970629">【精选】redis分布式锁(一）set NX实现_心心念念的小鼠标的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764476731-6ac1814f-7f3f-4442-b0af-43405c724fd9.png#averageHue=%23102a3d&clientId=u2b828817-5288-4&from=paste&height=298&id=uadcf17e7&originHeight=298&originWidth=1888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235838&status=done&style=none&taskId=uea343540-7380-459c-bb72-201b12a7257&title=&width=1888" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764614586-e1387af2-56e8-4cc4-a022-c87c0a93bb55.png#averageHue=%23f9f8f8&clientId=u2b828817-5288-4&from=paste&height=1031&id=u34b6c92a&originHeight=1031&originWidth=2069&originalType=binary&ratio=1&rotation=0&showTitle=false&size=460353&status=done&style=none&taskId=u61d17e47-f8a8-43d1-84b2-2d401efb444&title=&width=2069" alt="image.png"></p>
<h2 id="实现分布式锁初级版本"><a href="#实现分布式锁初级版本" class="headerlink" title="实现分布式锁初级版本"></a>实现分布式锁初级版本</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771133816-3aa47901-f070-4aa4-924f-e0f8dc690bb4.png#averageHue=%23faf9f8&clientId=u2b828817-5288-4&from=paste&height=781&id=uace818c4&originHeight=859&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188710&status=done&style=none&taskId=u70b504e5-e6d1-4ed9-a8c6-5c9baa37a74&title=&width=699.0908939385221" alt="image.png"></p>
<ul>
<li><strong>锁的基本接口</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699770874269-dc390610-18b3-4234-8c58-280d2c2e64b4.png#averageHue=%23f0f3ee&clientId=u2b828817-5288-4&from=paste&height=415&id=u965c0e3d&originHeight=415&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117726&status=done&style=none&taskId=ubc19fde2-7ab1-4e2d-8c5c-37256633aa9&title=&width=1037" alt="image.png"></p>
<ul>
<li><strong>SimpleRedisLock</strong></li>
</ul>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<pre><code class="java">package com.hmdp.utils;

import org.springframework.data.redis.core.StringRedisTemplate;

import javax.annotation.Resource;
import java.util.concurrent.TimeUnit;

public class SimpleRedis implements ILock &#123;
    private String name;
    StringRedisTemplate stringRedisTemplate;

    public SimpleRedis(String name, StringRedisTemplate stringRedisTemplate) &#123;
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;

    private static final String KEY_PREFIX=&quot;lock :&quot;;
    @Override
    public boolean tryLock(long longTimeSec) &#123;

        //获取线程标识

        long id = Thread.currentThread().getId();
        //获取锁
        Boolean aBoolean = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, id + &quot;&quot;, longTimeSec, TimeUnit.SECONDS);
        // 避免自动拆箱
        return Boolean.TRUE.equals(aBoolean) ;
    &#125;

    @Override
    public void unLock() &#123;
        stringRedisTemplate.delete(KEY_PREFIX + name);
        return;
    &#125;
&#125;
</code></pre>
<ul>
<li>修改业务代码</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771107955-f9d0ac98-aad1-4920-a963-a22da1ace571.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1185&id=u17f30d65&originHeight=1304&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174600&status=done&style=none&taskId=uc3445396-9b6e-48fa-b184-5190fc14a44&title=&width=1099.9999761581425" alt="image.png"></p>
<h2 id="Redis分布式锁的误删问题"><a href="#Redis分布式锁的误删问题" class="headerlink" title="Redis分布式锁的误删问题"></a>Redis分布式锁的误删问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771472494-df7802e3-1e3e-48db-a2be-11d3466f206b.png#averageHue=%23fbfafa&clientId=u2b828817-5288-4&from=paste&height=781&id=u7f928350&originHeight=859&originWidth=2200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=326266&status=done&style=none&taskId=u96caefbb-0f03-4002-8df2-fafa9619487&title=&width=1999.9999566511683" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771503937-7b6b9c51-b148-4087-85f5-5e40d94de5a5.png#averageHue=%23edebeb&clientId=u2b828817-5288-4&from=paste&height=785&id=u69cf30e6&originHeight=864&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157135&status=done&style=none&taskId=u1afa3fa6-c0ca-4a34-a934-49729056b1e&title=&width=750.9090746335751" alt="image.png"><br>在释放锁之前增加一层判断逻辑</p>
<h2 id="解决锁的误删问题"><a href="#解决锁的误删问题" class="headerlink" title="解决锁的误删问题"></a>解决锁的误删问题</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jasonboren/p/12939852.html">java UUID的作用和使用 - jason小蜗牛 - 博客园</a><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771765473-775cddd0-965a-4408-9acc-934cbec110d0.png#averageHue=%23f3f2f2&clientId=u2b828817-5288-4&from=paste&height=498&id=u09492cfa&originHeight=548&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&size=240179&status=done&style=none&taskId=u64ef6819-7ec7-4225-bb5c-40c34a513c1&title=&width=1151.8181568531957" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699772446928-2bb328ee-e2f8-4e78-b3b8-1fe4f5b17083.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1118&id=u58788f34&originHeight=1230&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206341&status=done&style=none&taskId=u97a17e7e-6ba0-4459-9bfe-bc617761e6c&title=&width=1450.909059461484" alt="image.png"></p>
<h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699796424412-f2c361aa-52b8-4395-81ef-b1628281fd56.png#averageHue=%23f5f3f3&clientId=u24e974b6-b49d-4&from=paste&height=866&id=uf39233f4&originHeight=866&originWidth=2162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=504589&status=done&style=none&taskId=ud0a673e8-d152-4459-983c-188bfa3615a&title=&width=2162" alt="image.png"></p>
<h2 id="Lua解决多条命令原子性问题"><a href="#Lua解决多条命令原子性问题" class="headerlink" title="Lua解决多条命令原子性问题"></a>Lua解决多条命令原子性问题</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a><br>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。<br>可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699880933064-77dee115-28f2-45cc-9773-6f6a5e124376.png#averageHue=%23d3d4d2&clientId=u92f804e2-0ef3-4&from=paste&height=638&id=u99462bf3&originHeight=798&originWidth=1620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=374301&status=done&style=none&taskId=u506ee292-5250-4856-9db0-a03c13e6c4d&title=&width=1296" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881087375-df2ee1b5-d8de-4f04-95b3-f1f9f415392f.png#averageHue=%23d4d7ce&clientId=u92f804e2-0ef3-4&from=paste&height=631&id=u56132fa4&originHeight=789&originWidth=1980&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=450447&status=done&style=none&taskId=u711f0716-833b-4d54-abf2-1c92700e50a&title=&width=1584" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881108549-4fc8f91d-920a-4b92-abba-c1067984756c.png#averageHue=%230e283c&clientId=u92f804e2-0ef3-4&from=paste&height=438&id=ufa0cda3a&originHeight=548&originWidth=1831&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=424857&status=done&style=none&taskId=ucfaaba09-ac69-4b7f-9153-cd3d2cfb9c4&title=&width=1464.8" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881232331-845d5b44-b145-4e58-9fed-20a28245927a.png#averageHue=%238ac2a2&clientId=u92f804e2-0ef3-4&from=paste&height=275&id=u8841d17e&originHeight=344&originWidth=2182&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=316067&status=done&style=none&taskId=u4b4b0479-e121-4cc0-b8b7-79ba8438af2&title=&width=1745.6" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881493990-b8608b49-856e-48fd-8c89-fd9adab0eef6.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=556&id=u217bfdf2&originHeight=695&originWidth=1642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=460710&status=done&style=none&taskId=ucc2afb76-fb02-468e-8334-95ed95e25b7&title=&width=1313.6" alt="image.png"><br>优化后:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881563797-921e1dbf-f656-419e-b0f3-8f047a74ec57.png#averageHue=%23d3dcd0&clientId=u92f804e2-0ef3-4&from=paste&height=353&id=u409c8838&originHeight=441&originWidth=1908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=409800&status=done&style=none&taskId=ud7f2cc77-b11a-428e-961d-17caf406a5a&title=&width=1526.4" alt="image.png"></p>
<h2 id="再次改进Redis的分布式锁"><a href="#再次改进Redis的分布式锁" class="headerlink" title="再次改进Redis的分布式锁"></a>再次改进Redis的分布式锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881705712-7b360bee-7d40-4dbb-a339-9c6eaebe02a9.png#averageHue=%23ecefe7&clientId=u92f804e2-0ef3-4&from=paste&height=751&id=u9ae334e3&originHeight=939&originWidth=1913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=592210&status=done&style=none&taskId=u1225738a-2bcb-4bea-bb86-1caaf4d9339&title=&width=1530.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882174692-9e036f2c-ef32-4bea-a179-9bfea183a8e4.png#averageHue=%23f0f5ef&clientId=u92f804e2-0ef3-4&from=paste&height=871&id=u40b269f1&originHeight=1089&originWidth=1722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=518841&status=done&style=none&taskId=u4c0e6e69-a223-45fc-973e-3393b5e0bb7&title=&width=1377.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882344511-6207e555-2c39-4f2e-9bdf-ea38db59b776.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=427&id=ufd8c3a1b&originHeight=534&originWidth=1071&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223373&status=done&style=none&taskId=uad9dd949-1b2c-4817-8c6e-7dcdd58f793&title=&width=856.8" alt="image.png"></p>
<h2 id="Redisson功能介绍"><a href="#Redisson功能介绍" class="headerlink" title="Redisson功能介绍"></a>Redisson功能介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699979826880-5d8dda27-fa55-4c01-96aa-4b8a7b45ac1f.png#averageHue=%23fcfcfc&clientId=ub5bfeee0-49d7-4&from=paste&height=517&id=u83b9b5cf&originHeight=1034&originWidth=2120&originalType=binary&ratio=2&rotation=0&showTitle=false&size=600636&status=done&style=none&taskId=udc199d20-1fa7-4ced-9073-3f467d8844e&title=&width=1060" alt="image.png"></p>
<h2 id="Redisson可重入锁原理原理"><a href="#Redisson可重入锁原理原理" class="headerlink" title="Redisson可重入锁原理原理"></a>Redisson可重入锁原理原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018645762-279974a1-1dd6-45ca-9137-7d97dcf1722b.png#averageHue=%23f2f4ef&clientId=u581ad08b-35c6-4&from=paste&height=631&id=u985b8ce9&originHeight=1262&originWidth=2514&originalType=binary&ratio=2&rotation=0&showTitle=false&size=949703&status=done&style=none&taskId=u48284284-8e00-42df-b8e4-fd63c27ab94&title=&width=1257" alt="image.png"><br>通过执行任务完成减1来实现。<br>但这么复杂的逻辑。 需要通过Lua脚本来实现，确保原子性。<br>获取锁过程。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018849312-e6676ce5-f980-445b-995c-1946733368bf.png#averageHue=%23eff1eb&clientId=u581ad08b-35c6-4&from=paste&height=614&id=u9a7b9e93&originHeight=1228&originWidth=2530&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1223900&status=done&style=none&taskId=u4de41c11-5b16-4b1b-8219-d5138838503&title=&width=1265" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019201833-de25b267-f566-4248-b001-6b3219bc861d.png#averageHue=%23eef1eb&clientId=u581ad08b-35c6-4&from=paste&height=595&id=ua4c740d1&originHeight=1190&originWidth=2492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1177806&status=done&style=none&taskId=ue12f011f-611b-497c-9475-5d181fbae4d&title=&width=1246" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019729671-7907b6e9-3ce3-46f2-9c2f-15af55b0f90a.png#averageHue=%23e7eee5&clientId=u581ad08b-35c6-4&from=paste&height=538&id=ufe7345c9&originHeight=1076&originWidth=2676&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1379062&status=done&style=none&taskId=uecac0475-8044-4070-baae-172b3f09512&title=&width=1338" alt="image.png"><br>tryLock底层就是用了Lua脚本<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019806532-f028d6ff-e7b6-4d6a-8d84-bd814933273d.png#averageHue=%23eff5ec&clientId=u581ad08b-35c6-4&from=paste&height=509&id=u15053e07&originHeight=1018&originWidth=2654&originalType=binary&ratio=2&rotation=0&showTitle=false&size=917520&status=done&style=none&taskId=u0fb71384-75f0-4ea9-a6ff-8eb71718abb&title=&width=1327" alt="image.png"><br>核心就是通过Hash结构来记录锁的调用次数。<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700055978583-286839e3-3017-4406-90df-b6e930f55ab0.png#averageHue=%23f4f2f2&clientId=u50dd14e7-a648-4&from=paste&height=760&id=uca34f263&originHeight=760&originWidth=1843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=316805&status=done&style=none&taskId=u973abdad-f003-4415-a81a-05f0d2801d3&title=&width=1843" alt="image.png"></p>
<h2 id="基于redis分布式锁优化"><a href="#基于redis分布式锁优化" class="headerlink" title="基于redis分布式锁优化"></a>基于redis分布式锁优化</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056217601-0c6e7d65-7fab-45c1-9989-38132616d579.png#averageHue=%23f9f0ef&clientId=u50dd14e7-a648-4&from=paste&height=761&id=ub1c7888f&originHeight=951&originWidth=1840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=342512&status=done&style=none&taskId=uf5e10912-f68c-4b07-a9c1-5b60e80ea2a&title=&width=1472" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056481920-222e2d99-5e68-4a84-86d3-14bae28ffa37.png#averageHue=%23f5e6e5&clientId=u50dd14e7-a648-4&from=paste&height=782&id=u834d1a86&originHeight=977&originWidth=2234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496050&status=done&style=none&taskId=u16887b86-dff6-4f7c-a321-a688a0d78a0&title=&width=1787.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056738489-ecee9d44-ea43-4c3e-abd0-cb305af85adc.png#averageHue=%23f2f7f1&clientId=u50dd14e7-a648-4&from=paste&height=403&id=u87f6f193&originHeight=504&originWidth=1681&originalType=binary&ratio=1&rotation=0&showTitle=false&size=295692&status=done&style=none&taskId=ufa3ae324-8dce-4a6c-8ff7-33f9d1d079b&title=&width=1344.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700057236183-e8f70303-b73e-4043-ae37-5c1415ded4b6.png#averageHue=%23eeeeee&clientId=u50dd14e7-a648-4&from=paste&height=733&id=ua4c7a83f&originHeight=916&originWidth=1222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391430&status=done&style=none&taskId=ua38b47d1-6d94-4778-9c98-ba092437f32&title=&width=977.6" alt="image.png"></p>
<h1 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108211115-77067f67-a25b-48e4-8bc2-a573d82fb72d.png#averageHue=%23fbf8f7&clientId=u3efe4494-fe3d-4&from=paste&height=1055&id=u7b2571e0&originHeight=1055&originWidth=2165&originalType=binary&ratio=1&rotation=0&showTitle=false&size=393738&status=done&style=none&taskId=u57881431-e1b4-4e7f-a0f1-14fdc052a34&title=&width=2165" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108448724-60d6a6e1-e83c-4eda-bff2-8ce93f1286c1.png#averageHue=%23faf7f6&clientId=u3efe4494-fe3d-4&from=paste&height=1002&id=u58a39a79&originHeight=1002&originWidth=2181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=432047&status=done&style=none&taskId=u52738e3a-12a1-4fc3-8241-c320d24c34f&title=&width=2181" alt="image.png"><br>使用Lua脚本保证原子性<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108815144-7c7f9c4e-1e85-4a10-878f-e519097dbc39.png#averageHue=%23f4f0f0&clientId=u3efe4494-fe3d-4&from=paste&height=1037&id=u44050025&originHeight=1037&originWidth=2257&originalType=binary&ratio=1&rotation=0&showTitle=false&size=446673&status=done&style=none&taskId=ufd15cf1f-404c-4a32-b5b0-1350b67aec7&title=&width=2257" alt="image.png"><br>为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。<br>可以将耗时较短的两步操作放到 Redis 中，在 Redis 中处理对应的秒杀资格的判断。Redis 的性能是比 MySQL 要好的。此外，还需要引入异步队列记录相关的信息。<br>redis部分处理逻辑， Lua脚本封装操作保证原子性， redis这里选择的存储类型为set，因为key不能重复，而set恰好是无序不重复的<br><strong>基于Redis实现秒杀资格判断</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143137919-cce8210f-eb55-4cb3-bb70-da4607a4e40c.png#averageHue=%23f1efef&clientId=u3efe4494-fe3d-4&from=paste&height=524&id=u1b444d16&originHeight=524&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=275261&status=done&style=none&taskId=u9d3d2a8e-d869-43ab-b8c7-412b7836f55&title=&width=1353" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700142114007-8be488d5-8675-44a7-8b42-e48a81b29293.png#averageHue=%230f263c&clientId=u3efe4494-fe3d-4&from=paste&height=494&id=ubcf455b5&originHeight=494&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293776&status=done&style=none&taskId=u2a5cd725-d0d0-47cb-a1a6-437db6b30cd&title=&width=1488" alt="image.png"></p>
<ul>
<li>新增优惠券同时,将优惠券信息保存到Redis中</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143188577-2b7e916f-5102-4a7a-93e3-eb4ec45367b6.png#averageHue=%232c2c2b&clientId=u3efe4494-fe3d-4&from=paste&height=555&id=u4976e03b&originHeight=555&originWidth=1658&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74949&status=done&style=none&taskId=uf10ee419-96a5-4062-a0f5-89a0a83cfcd&title=&width=1658" alt="image.png"></p>
<ul>
<li>基于Lua脚本, 判断秒杀库存,一人一单,决定用户是否抢购成功</li>
</ul>
<pre><code class="lua">-- 1.1 订单id
local voucherId = ARGV[1]
-- 1.2 用户id
local useId = ARGV[2]

-- 数据key
-- 2.1 库存key
local stockKey = &#39;seckill:stock:&#39; .. voucherId
-- 2.2 订单key
local orderKey = &#39;seckill:order:&#39; .. voucherId

-- 3.脚本业务
-- 3.1 判断库存是否充足 get stockKey
if (tonumber(redis.call(&#39;get&#39;,stockKey)) &lt;= 0) then
    -- 不足返回1
    return 1

end
-- 3.2 库存充足,sismember看userId是否存在于orderId
if (redis.call(&#39;sismember&#39;, orderKey, userId) == 1) then
    -- 3.3 如果存在,说明下单了,返回2
    return 2
end
-- 3.4 扣减库存 incrby stockKey -1
redis.call(&#39;incriby&#39;, stockKey, -1)
-- 3.5下单(保存用户)
redis.call(&#39;sadd&#39;, orderKey, userId)
</code></pre>
<ul>
<li>java代码中执行lua脚本，并判断，抢购成功的生成订单并存入阻塞队列<br>首先注入脚本</li>
</ul>
<pre><code class="java">    private IVoucherOrderService proxy;//定义代理对象，提前定义后面会用到
    //注入脚本
    private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;
    static &#123;
        SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;();
        SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;));
        SECKILL_SCRIPT.setResultType(Long.class);
    &#125;
</code></pre>
<p>运行脚本，且判断不满足的请求直接返回提示信息</p>
<pre><code class="java">    @Override
    public Result seckillVoucher(Long voucherId) &#123; //使用lua脚本
        //获取用户
        Long userId = UserHolder.getUser().getId();
        //1.执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(), //这里是key数组，没有key，就传的一个空集合
                voucherId.toString(), userId.toString()
        );
        //2.判断结果是0
        int r = result.intValue();//Long型转为int型，便于下面比较
        if (r != 0)&#123;
            //2.1 不为0，代表没有购买资格
            return  Result.fail(r == 1?&quot;优惠券已售罄&quot;:&quot;不能重复购买&quot;);

        &#125;
</code></pre>
<p>最后是将满足条件的给存放进阻塞队列中<br>创建一个BlockingQueue阻塞队列</p>
<blockquote>
<p><strong>BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素</strong></p>
</blockquote>
<pre><code class="java">//创建阻塞队列  这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒获取
    private BlockingQueue&lt;VoucherOrder&gt; orderTasks = new ArrayBlockingQueue&lt;&gt;(1024 * 1024);//初始化阻塞队列的大小
</code></pre>
<p>接下来就是将满足条件的请求，给生成订单，并把订单对象add到阻塞队列中，接上面的代码，完成整个第三步</p>
<pre><code class="java">        //2.2 为0，有购买资格，把下单信息保存到阻塞队列中
        //7.创建订单   向订单表新增一条数据，除默认字段，其他字段的值需要set
        VoucherOrder voucherOrder = new VoucherOrder();
        //7.1订单id
        long orderId = redisIdWorker.nextId(&quot;order&quot;);
        voucherOrder.setId(orderId);
        //7.2用户id
        voucherOrder.setUserId(userId);
        //7.3代金券id
        voucherOrder.setVoucherId(voucherId);
        //放入阻塞对列中
        orderTasks.add(voucherOrder);
        //获取代理对象
        proxy = (IVoucherOrderService) AopContext.currentProxy();
        //3.返回订单id
        return Result.ok(orderId);
    &#125;
</code></pre>
<p>4.开启线程任务，实现异步下单功能<br>首先创建一个线程池<br>再定义一个线程任务，但是注意，线程任务需要在用户秒杀订单之前开始，用户一但开始秒杀，队列就会有新的订单，线程任务就应该立即取出订单信息，<strong>这里利用spring提供的注解，在类初始化完毕后立即执行线程任务。</strong></p>
<pre><code class="java">    //创建线程池
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();
    //利用spring提供的注解，在类初始化完毕后立即执行线程任务
    @PostConstruct
    private void init()&#123;
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    &#125;
</code></pre>
<p>线程任务代码如下</p>
<pre><code class="java">    //创建线程任务，内部类方式
    private class VoucherOrderHandler implements Runnable&#123;

        @Override
        public void run() &#123;
            //1.获取队列中的订单信息
            try &#123;
                VoucherOrder voucherOrder = orderTasks.take();
                //2.创建订单，这是调之前那个创建订单的方法，需要稍作改动
                handleVoucherOrder(voucherOrder);
            &#125; catch (Exception e) &#123;
                log.info(&quot;异常信息:&quot;,e);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>创建调用的handleVoucherOrder方法，这里的获取锁操作只是做最后的兜底，以防万一，因为前面lua脚本都已经判断过了</p>
<pre><code class="java">    private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;
        Long userId = voucherOrder.getUserId();
        //创建锁对象
        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);
        //获取锁
        boolean isLock = lock.tryLock(1200);
        //判断是否获取锁成功
        if (!isLock)&#123;
            log.error(&quot;您已购买过该商品，不能重复购买&quot;);
        &#125;
        try &#123;
            proxy.createVoucherOrder(voucherOrder);//使用代理对象，最后用于提交事务
        &#125; catch (IllegalStateException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            lock.unlock();//释放锁
        &#125;
    &#125;
</code></pre>
<p>createVoucherOrder创建订单方法，这里一人一单的其实也不必判读了，lua脚本都写好了，这里只是兜底</p>
<pre><code class="java"> @Transactional
    public void createVoucherOrder(VoucherOrder voucherOrder)&#123;
        Long voucherId = voucherOrder.getVoucherId();
        //5.一人一单
        Long userId = voucherOrder.getId();
        //5.1查询订单
        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();
        //5.2判断是否存在
        if (count &gt; 0)&#123;
            log.error(&quot;您已经购买过了&quot;);
        &#125;
        //6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql(&quot;stock = stock - 1&quot;)//set stock = stock -1
                .eq(&quot;voucher_id&quot;,voucherId).gt(&quot;stock&quot;,0) //where id = ? and stock &gt; 0
                .update();
        if (!success)&#123;
            log.error(&quot;库存不足！&quot;);
        &#125;
        this.save(voucherOrder);

    &#125;
</code></pre>
<p>最后来分析以下整个优化思路</p>
<p>①编写lua脚本，对于超卖问题和一人一单进行解决处理，超卖用CAS方法判断库存是否大于0，一人一单用redis的set集合的sismenber判读该优惠券（key）下的用户id（value）是否唯一<br>②Java代码中注入脚本，并执行脚本判断脚本返回结果，若不为脚本结果0，直接返回错误提示<br>③若脚本结果为0，代表有购买优惠券资格，将new VoucherOrder创建订单对象，并set orderId，userId，voucherId。再把订单对象放入阻塞队列中，返回订单id给用户<br>④创建线程池，并定义线程任务，但注意，线程任务必须在方法执行前执行，使用到spring提供的注解在类初始化完成后执行线程任务<br>⑤线程任务中获取阻塞队列的订单对象，然后调用handleVoucherOrder方法传入voucherOrder<br>⑥handleVoucherOrder方法其实是再次获取锁，这个就是个纯兜底，作用不大。并在获取锁成功后调用createVoucherOrder方法扣减库存创建订单，由于都是对数据库的操作，因此要提交事务</p>
<h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192287868-9a1187af-243a-48bc-aa09-c915e6be9d49.png#averageHue=%232d2c2b&clientId=uf4fd22ef-b30f-4&from=paste&height=467&id=uf2e5d9c1&originHeight=584&originWidth=1635&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71962&status=done&style=none&taskId=ud5a1a946-f9b8-4357-b93a-c60d894d2ca&title=&width=1308" alt="image.png"><br>   <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192303259-735adad5-6b92-424d-bad0-ad0848be8aaf.png#averageHue=%23fbf9f8&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=ua57afb52&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55014&status=done&style=none&taskId=u5a954408-ad69-4f84-b89b-0f3dca79db5&title=&width=363.2" alt="fd58151acf51b465fc8430594373e22.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192308132-1578fabd-b085-4d49-bc95-4ddf6dbff04e.png#averageHue=%23e2d3cb&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=u121eda6c&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241575&status=done&style=none&taskId=ufda28241-dcd6-4295-a2a3-daae5345516&title=&width=363.2" alt="4542b554a076d20a0a6da9b3a770e93.png"></p>
<h2 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h2><pre><code class="java"> @GetMapping(&quot;/&#123;id&#125;&quot;)
    public Result queryBlogById(@PathVariable(&quot;id&quot;) Long id)&#123;
        return blogService.queryBlogById(id);
    &#125;
</code></pre>
<pre><code class="java">  @Resource
    UserServiceImpl userService;
    @Override
    public Result queryBlogById(Long id) &#123;
        // 查询blog
        Blog blog = getById(id);
        if (blog == null)Result.fail(&quot;笔记不存在&quot;);
        //查询跟笔记有关的用户
        Long userId = blog.getUserId();
        User user = userService.getById(userId);
        blog.setName(user.getNickName());
        blog.setIcon(user.getIcon());
        return Result.ok(blog);
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700193985582-21a43285-d97d-41fb-bb96-008d81a39809.png#averageHue=%23dfd9d4&clientId=u7b8926cd-a983-4&from=paste&height=649&id=ua3a177b0&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223031&status=done&style=none&taskId=ucea36795-d007-4ff6-9d5f-ff0ca06b5a7&title=&width=363.2" alt="image.png"></p>
<h2 id="完善点赞功能"><a href="#完善点赞功能" class="headerlink" title="完善点赞功能"></a>完善点赞功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700194315711-c845fe89-d025-42f0-a3fe-8d28061c0ded.png#averageHue=%23f5f5f5&clientId=u7b8926cd-a983-4&from=paste&height=761&id=ue7aaec9e&originHeight=951&originWidth=1802&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=443516&status=done&style=none&taskId=u76cbef0d-d4c1-44e3-8596-7e873bba294&title=&width=1441.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700198316712-283624f0-1627-4410-a753-5bf72beb9611.png#averageHue=%23f6f5f5&clientId=u7b8926cd-a983-4&from=paste&height=691&id=ufe8821b3&originHeight=864&originWidth=2126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=469370&status=done&style=none&taskId=u01a71424-ac53-4a05-9b87-257031d9649&title=&width=1700.8" alt="image.png"><br>为什么采用set集合：<br>因为我们的数据是不能重复的.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700222974076-5d45ce71-9321-483f-a627-6dd08c6181cd.png#averageHue=%232b2b2b&clientId=u7b8926cd-a983-4&from=paste&height=516&id=u3e6ea984&originHeight=516&originWidth=1552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37622&status=done&style=none&taskId=u9c1bc59f-ab5a-4eaa-87d4-e42e289448a&title=&width=1552" alt="image.png"><br>不是数据库字段,使我们自己加的.</p>
<h2 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232547308-8fe2e403-8645-44db-94e9-45b0899fe658.png#averageHue=%23e9e0e0&clientId=u7b8926cd-a983-4&from=paste&height=1022&id=u357df1e0&originHeight=1022&originWidth=1860&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=321342&status=done&style=none&taskId=uff5dce92-5d94-43c9-ad68-921e086026a&title=&width=1860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232637405-256dc518-8c4b-4e8c-b74b-6e6cea1bb3fe.png#averageHue=%23072136&clientId=u7b8926cd-a983-4&from=paste&height=631&id=u4fd4e0b9&originHeight=631&originWidth=1910&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=447275&status=done&style=none&taskId=u64a8ae48-4c76-452d-8bd0-12d7bf2e608&title=&width=1910" alt="image.png"><br>修改代码<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700234060791-0ebd8375-a41f-4e12-bd90-fc92631d084a.png#averageHue=%232c2c2b&clientId=u7b8926cd-a983-4&from=paste&height=1281&id=u4782a1b4&originHeight=1281&originWidth=1511&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=213137&status=done&style=none&taskId=uddafbb8c-4fa0-4209-9c32-52b206e5e6f&title=&width=1511" alt="image.png"></p>
<pre><code class="java"> private void isBlogLike(Blog blog) &#123;
        // 1.获取登录用户
        Long userId = UserHolder.getUser().getId();
        // 2.判断当前登录用户是否已经点赞
        String key = RedisConstants.BLOG_LIKED_KEY + blog.getId();
        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());
        blog.setIsLike(BooleanUtil.isTrue(score!=null));
    &#125;

    @Override
    public Result likeBlog(Long id) &#123;
        // 1.获取登录用户
        Long userId = UserHolder.getUser().getId();
        // 2.判断当前登录用户是否已经点赞
        String key = RedisConstants.BLOG_LIKED_KEY + id;
        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());
        if ( score == null) &#123;
            //3.如果未点赞，可以点赞
            //3.1 数据库点赞数+1
            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();
            //3.2 保存用户到Redis的set集合
            if (isSuccess) &#123;
                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());
            &#125;
        &#125; else &#123;
            //4.如果已点赞，取消点赞
            //4.1 数据库点赞数-1
            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();
            //4.2 把用户从Redis的set集合移除
            if (isSuccess) &#123;
                stringRedisTemplate.opsForZSet().remove(key, userId.toString());
            &#125;
        &#125;
        return Result.ok();
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236822763-c63a3595-c66d-4c79-8e45-9cc24c3c9a3b.png#averageHue=%23fafafa&clientId=u7b8926cd-a983-4&from=paste&height=619&id=u7e9d0869&originHeight=619&originWidth=1329&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187179&status=done&style=none&taskId=u2994ebf1-e3c6-4b24-a443-7171bad45eb&title=&width=1329" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236872571-05c9d8c0-3b3c-45b7-ad7a-b8de86d81275.png#averageHue=%23f9f9f9&clientId=u7b8926cd-a983-4&from=paste&height=663&id=u15fb46a1&originHeight=663&originWidth=1475&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=191782&status=done&style=none&taskId=u5769bd53-1963-4081-b4ce-f7373863462&title=&width=1475" alt="image.png"></p>
<h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="实现关注和取关功能"><a href="#实现关注和取关功能" class="headerlink" title="实现关注和取关功能"></a>实现关注和取关功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278801806-7cd17c25-2eeb-48d5-bc32-e9c9d92e8740.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=694&id=ub93a3038&originHeight=694&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=364764&status=done&style=none&taskId=u03326a0e-5c7c-4ada-baa1-62aa4cf9bb4&title=&width=1438" alt="image.png"></p>
<pre><code class="java">  @Override
    public Result follow(Long followUserId, Boolean isFollow) &#123;
        // 1.获取登录用户
        Long userId = UserHolder.getUser().getId();
        String key = &quot;follows:&quot; + userId;
        // 1.判断到底是关注还是取关
        if (isFollow) &#123;
            // 2.关注，新增数据
            Follow follow = new Follow();
            follow.setUserId(userId);
            follow.setFollowUserId(followUserId);
            boolean isSuccess = save(follow);
            if (isSuccess) &#123;
                // 把关注用户的id，放入redis的set集合 sadd userId followerUserId
                stringRedisTemplate.opsForSet().add(key, followUserId.toString());
            &#125;
        &#125; else &#123;
            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?
            boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()
                    .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));
            if (isSuccess) &#123;
                // 把关注用户的id从Redis集合中移除
                stringRedisTemplate.opsForSet().remove(key, followUserId.toString());
            &#125;
        &#125;
        return Result.ok();
    &#125;

    @Override
    public Result isFollow(Long followUserId) &#123;
        // 1.获取登录用户
        Long userId = UserHolder.getUser().getId();
        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?
        Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count();
        // 3.判断
        return Result.ok(count &gt; 0);
    &#125;

    @Override
    public Result followCommons(Long id) &#123;
        // 1.获取当前用户
        Long userId = UserHolder.getUser().getId();
        String key = &quot;follows:&quot; + userId;
        // 2.求交集
        String key2 = &quot;follows:&quot; + id;
        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);
        if (intersect == null || intersect.isEmpty()) &#123;
            // 无交集
            return Result.ok(Collections.emptyList());
        &#125;
        // 3.解析id集合
        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());
        // 4.查询用户
        List&lt;UserDTO&gt; users = userService.listByIds(ids)
                .stream()
                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))
                .collect(Collectors.toList());
        return Result.ok(users);
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278760191-0a31a5e5-4de5-4df2-b30b-d31be97f6836.png#averageHue=%23776141&clientId=u239d3de8-271e-4&from=paste&height=667&id=ub85ab2ae&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=381847&status=done&style=none&taskId=ub8184d02-201d-4d21-94c8-32944030eec&title=&width=375" alt="image.png"></p>
<h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280435793-fb72ba40-d4e0-487c-b6dd-0e1da5cf9353.png#averageHue=%23e7e3df&clientId=u239d3de8-271e-4&from=paste&height=814&id=u4629bab6&originHeight=814&originWidth=1639&originalType=binary&ratio=1&rotation=0&showTitle=false&size=689686&status=done&style=none&taskId=ub478a468-8946-482c-980f-60b696f1351&title=&width=1639" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280752986-320ed5f4-5fcd-4d5f-90b4-edae3dd270a3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=602&id=u625ec156&originHeight=602&originWidth=1312&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173418&status=done&style=none&taskId=ud6ac5584-1554-4d53-9570-60c92c538cc&title=&width=1312" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281004775-9773e98c-2e37-47a5-8ee2-60226f75274e.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=257&id=u584f6121&originHeight=257&originWidth=1316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115430&status=done&style=none&taskId=u03405a14-a5d9-4f52-8b77-c63fc0c227f&title=&width=1316" alt="image.png"><br>应该改造以前的关注接口,每次关注一个人, 就存到set集合中, 从而来找共同好友.</p>
<pre><code class="java">    @Override
    public Result followCommons(Long id) &#123;
        // 1.获取当前用户
        Long userId = UserHolder.getUser().getId();
        String key = &quot;follows:&quot; + userId;
        // 2.求交集
        String key2 = &quot;follows:&quot; + id;
        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);
        if (intersect == null || intersect.isEmpty()) &#123;
            // 无交集
            return Result.ok(Collections.emptyList());
        &#125;
        // 3.解析id集合
        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());
        // 4.查询用户
        List&lt;UserDTO&gt; users = userService.listByIds(ids)
                .stream()
                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))
                .collect(Collectors.toList());
        return Result.ok(users);
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281686178-2beec8e2-4921-4e60-9d1b-3dbead131073.png#averageHue=%23fdfaf9&clientId=u239d3de8-271e-4&from=paste&height=811&id=ufccf59b2&originHeight=811&originWidth=454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47333&status=done&style=none&taskId=u71095f78-67ca-40cd-b547-2198ac7725c&title=&width=454" alt="image.png"></p>
<h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284790050-a87ac7ad-37c8-45a6-a97a-217c7ff84a55.png#averageHue=%23ece1e1&clientId=u239d3de8-271e-4&from=paste&height=747&id=ua6122419&originHeight=747&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204743&status=done&style=none&taskId=u931ebda5-1422-465c-8776-dbe2a8d7d36&title=&width=1562" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284912975-b1b44dcf-fa79-4486-880d-c7e728ec945c.png#averageHue=%23e9e5e3&clientId=u239d3de8-271e-4&from=paste&height=783&id=u630c0be9&originHeight=783&originWidth=1689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=659610&status=done&style=none&taskId=u59cff10f-6c53-4e1f-b2d3-de7c8248ea1&title=&width=1689" alt="image.png"><br>我们的业务<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284953779-20675930-1bba-4136-9abf-0e9e6f7813f7.png#averageHue=%23f6f5f5&clientId=u239d3de8-271e-4&from=paste&height=790&id=u615ca396&originHeight=790&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320765&status=done&style=none&taskId=u17e3405f-ece1-4575-a7af-1d81065951a&title=&width=1496" alt="image.png"><br><strong>拉模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285079923-6e24b596-9068-4f4d-b758-bb4fdc8a9ac3.png#averageHue=%23fcfcfb&clientId=u239d3de8-271e-4&from=paste&height=774&id=u0e7376e8&originHeight=774&originWidth=1607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=255182&status=done&style=none&taskId=u58815847-18cf-4897-9ae6-49320c7314b&title=&width=1607" alt="image.png"><br><strong>推模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285123680-ec4a5326-8214-4684-9f7f-d07dfd246f9c.png#averageHue=%23fcfcfc&clientId=u239d3de8-271e-4&from=paste&height=767&id=u79b63f5c&originHeight=767&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210966&status=done&style=none&taskId=u4eb2e920-1149-474e-b179-d9e325fd0dc&title=&width=1409" alt="image.png"><br>缺点是发给每一个粉丝, 内存占用很高.<br><strong>推拉结合</strong><br>粉丝少-&gt; 推模式<br>粉丝多-&gt;拉模式<br>  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285260959-e254c589-1fe5-400f-afd6-32a228e3e27a.png#averageHue=%23fbfafa&clientId=u239d3de8-271e-4&from=paste&height=782&id=u451f38b3&originHeight=782&originWidth=1589&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281607&status=done&style=none&taskId=ud1193503-c2e3-4550-810d-c43aadf42f6&title=&width=1589" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285315021-96ff8b73-54e3-42f3-9887-0d61244668aa.png#averageHue=%23e7dad9&clientId=u239d3de8-271e-4&from=paste&height=730&id=u73c06178&originHeight=730&originWidth=1660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157594&status=done&style=none&taskId=u07bfb312-1ad0-45a1-b5e4-412fb7ed5c0&title=&width=1660" alt="image.png"></p>
<h2 id="基于推模式实现关注推送功能"><a href="#基于推模式实现关注推送功能" class="headerlink" title="基于推模式实现关注推送功能."></a>基于推模式实现关注推送功能.</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289493961-b55cfb33-3b8a-405d-be38-74923204e2d3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=1090&id=ud8164f58&originHeight=1090&originWidth=2163&originalType=binary&ratio=1&rotation=0&showTitle=false&size=333264&status=done&style=none&taskId=u2a2398b4-0278-4287-a678-2513b79acc7&title=&width=2163" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289532336-17506c65-7a74-48cb-b271-08c0739c424d.png#averageHue=%23f9f8f7&clientId=u239d3de8-271e-4&from=paste&height=1087&id=u4a4bd886&originHeight=1087&originWidth=2072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327415&status=done&style=none&taskId=ude5e1872-71c9-4418-b3c4-d5c8cfd29c6&title=&width=2072" alt="image.png">不依赖角标<br>使用sorted来实现<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292674877-9e3a48dc-dc13-4505-97cb-8cfcf6751a35.png#averageHue=%23092437&clientId=u239d3de8-271e-4&from=paste&height=320&id=u451267d9&originHeight=320&originWidth=1975&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291864&status=done&style=none&taskId=u1c4f9e33-201b-4bd7-867f-da34c378449&title=&width=1975" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292757855-54286e90-8db5-41f3-89c9-15c76cd933dd.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=737&id=q78vy&originHeight=737&originWidth=1517&originalType=binary&ratio=1&rotation=0&showTitle=false&size=294942&status=done&style=none&taskId=u5e677409-2aa1-450e-9671-40371b52f00&title=&width=1517" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293092245-43e5c4b8-a8fe-46d7-afaf-0b17404bbf6c.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=922&id=u174d75a2&originHeight=922&originWidth=1894&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557957&status=done&style=none&taskId=uddb0a0f8-3bb2-438f-9848-7d551401ab4&title=&width=1894" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293221589-5eb005f4-0ebf-4ec2-b7c8-2a1d3360f855.png#averageHue=%23072236&clientId=u239d3de8-271e-4&from=paste&height=782&id=u52f79ff7&originHeight=782&originWidth=1791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=371832&status=done&style=none&taskId=u6e5fdb5a-2bd8-48b4-ab10-5f202986a7c&title=&width=1791" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293348844-fb32c3bb-2876-4750-9c42-707dc06e54ba.png#averageHue=%23052035&clientId=u239d3de8-271e-4&from=paste&height=1040&id=u12dd3b88&originHeight=1040&originWidth=2053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=490628&status=done&style=none&taskId=ubea8abf6-2439-449d-a4d0-b0f686b3281&title=&width=2053" alt="image.png"><br><strong>总结:</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293443441-20ddb32f-62d1-491d-bd6c-99d851ca0791.png#averageHue=%23deddd4&clientId=u239d3de8-271e-4&from=paste&height=647&id=uc2ef59e7&originHeight=647&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=355611&status=done&style=none&taskId=u586e5a50-8e82-4add-91b6-5e05d8f2a31&title=&width=1526" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293509310-beb1b064-aa7f-41ba-90cf-ba42c80b120f.png#averageHue=%23e4dddb&clientId=u239d3de8-271e-4&from=paste&height=1041&id=ubbdd503e&originHeight=1041&originWidth=1632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=725755&status=done&style=none&taskId=u3b34c4e8-a8c0-4436-ac54-688f03597d9&title=&width=1632" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700325372958-8f591a79-b9e9-47e8-a2e4-f609a0375182.png#averageHue=%23f1f6f0&clientId=u239d3de8-271e-4&from=paste&height=1165&id=u12e9f56d&originHeight=1165&originWidth=2085&originalType=binary&ratio=1&rotation=0&showTitle=false&size=702953&status=done&style=none&taskId=ue74b11e5-7449-4ddd-99e2-f08a5278a64&title=&width=2085" alt="image.png"></p>
<h1 id="附件商铺"><a href="#附件商铺" class="headerlink" title="附件商铺"></a>附件商铺</h1><h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363000628-b5dedeca-c042-4f08-90ad-60df5f7522fd.png#averageHue=%23f1f0e6&clientId=u239d3de8-271e-4&from=paste&height=866&id=u3dc15f61&originHeight=866&originWidth=2131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=753135&status=done&style=none&taskId=u0c009a19-cd8a-4a61-92a9-3fa7fbaf3eb&title=&width=2131" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363043045-b3ac121e-24a7-4fd9-b399-9e2f6e3d428e.png#averageHue=%230a2339&clientId=u239d3de8-271e-4&from=paste&height=694&id=u23e1efbc&originHeight=694&originWidth=2258&originalType=binary&ratio=1&rotation=0&showTitle=false&size=495603&status=done&style=none&taskId=ufb3cfff0-c609-4166-b553-fb9ddb9ee3c&title=&width=2258" alt="image.png">·<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363175122-099789de-43e6-4ff0-bb47-877588a426fd.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=490&id=ubc3cbe65&originHeight=490&originWidth=1244&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232721&status=done&style=none&taskId=u23c9cfd6-39d7-43aa-a1c2-dc2dfe8ebb5&title=&width=1244" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363356088-ccb6e01e-68f1-47a9-8a49-05123ba218ca.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=431&id=ud8d9a339&originHeight=431&originWidth=1949&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259143&status=done&style=none&taskId=u6b0822bd-889a-4a4d-9985-905390c20d5&title=&width=1949" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363406537-6ed70eb9-89eb-4c9d-ae10-fb97cf024acb.png#averageHue=%230d233b&clientId=u239d3de8-271e-4&from=paste&height=394&id=u54ff8dd6&originHeight=394&originWidth=1333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=283704&status=done&style=none&taskId=ud95865d6-3368-4985-915b-68f16f143d4&title=&width=1333" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364076459-65d2dc7c-c5b4-4111-b461-e328bce52977.png#averageHue=%23b9c3b1&clientId=u239d3de8-271e-4&from=paste&height=1075&id=u8c317c0a&originHeight=1075&originWidth=2192&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1077835&status=done&style=none&taskId=u0bf4ad10-69a6-425d-8d77-0cf322fc1e7&title=&width=2192" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364201359-0875e76e-f0f3-458f-8672-83907bafbb8d.png#averageHue=%23e0e6e7&clientId=u239d3de8-271e-4&from=paste&height=765&id=u3093abbb&originHeight=765&originWidth=1790&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1124022&status=done&style=none&taskId=u0a775965-a9cf-415e-907f-cd528f57d9d&title=&width=1790" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700369316288-66b9818b-eed9-44bc-9335-0b965e51cc11.png#averageHue=%23777777&clientId=u239d3de8-271e-4&from=paste&height=612&id=ud6756531&originHeight=612&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112120&status=done&style=none&taskId=u27a9d1e8-8e9a-4ec4-876a-f129ec4cbfa&title=&width=1613" alt="image.png"></p>
<h2 id="查找附近商铺功能"><a href="#查找附近商铺功能" class="headerlink" title="查找附近商铺功能"></a>查找附近商铺功能</h2><p>实现数据的导入</p>
<pre><code class="java">    @Test
    void loadShopData() &#123;
        // 1.查询店铺信息
        List&lt;Shop&gt; list = shopService.list();
        // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合
        Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));
        // 3.分批完成写入Redis
        for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;
            // 3.1.获取类型id
            Long typeId = entry.getKey();
            String key = SHOP_GEO_KEY + typeId;
            // 3.2.获取同类型的店铺的集合
            List&lt;Shop&gt; value = entry.getValue();
            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());
            // 3.3.写入redis GEOADD key 经度 纬度 member
            for (Shop shop : value) &#123;
                // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());
                locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(
                        shop.getId().toString(),
                        new Point(shop.getX(), shop.getY())
                ));
            &#125;
            stringRedisTemplate.opsForGeo().add(key, locations);
        &#125;
    &#125;
</code></pre>
<p>SpringDataRedis 的 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令<br>因此我们需要提示其版本，修改自己的 pom.xml</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.6.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<h1 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h1><h2 id="bitmap用法"><a href="#bitmap用法" class="headerlink" title="bitmap用法"></a>bitmap用法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700379557735-4efe8b5e-0d59-414a-9423-17d6142b3451.png#averageHue=%23f3f1ea&clientId=ud7e70bf7-514d-4&from=paste&height=556&id=u7e3a41c0&originHeight=1112&originWidth=2472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1044266&status=done&style=none&taskId=u11207de4-f623-425e-bdaa-0c7eda7a48c&title=&width=1236" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380108867-8b8dbe78-bd4c-465f-a3f8-6d9c3af3316e.png#averageHue=%23f8f8f8&clientId=ud7e70bf7-514d-4&from=paste&height=548&id=ude7763cd&originHeight=1096&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=345948&status=done&style=none&taskId=u15b9380d-2591-44d6-ba35-ed98945e2a7&title=&width=1153" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380440914-1de72eab-f672-4c2d-ad95-33b18e248dca.png#averageHue=%23f3f3f3&clientId=ud7e70bf7-514d-4&from=paste&height=462&id=ua8835d34&originHeight=924&originWidth=2134&originalType=binary&ratio=2&rotation=0&showTitle=false&size=567878&status=done&style=none&taskId=u5f675c73-c2aa-4859-98ee-3ed58201b79&title=&width=1067" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380779465-409513e1-6552-4131-8344-55b6b794f10e.png#averageHue=%230a2435&clientId=ud7e70bf7-514d-4&from=paste&height=221&id=ud1a26804&originHeight=442&originWidth=1588&originalType=binary&ratio=2&rotation=0&showTitle=false&size=291832&status=done&style=none&taskId=u69122527-cce5-4409-97ff-314e595fe8d&title=&width=794" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380819411-62c986bb-66ef-4214-8797-eb0e85645e88.png#averageHue=%2310293a&clientId=ud7e70bf7-514d-4&from=paste&height=170&id=u30917650&originHeight=340&originWidth=1920&originalType=binary&ratio=2&rotation=0&showTitle=false&size=238370&status=done&style=none&taskId=u9ab23b8e-4b42-4454-82e6-464bd5d58f6&title=&width=960" alt="image.png"></p>
<h2 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h2><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380949589-c9919d6c-a5f2-41a9-b188-d0302c6694e1.png#averageHue=%23f2f2f2&clientId=ud7e70bf7-514d-4&from=paste&height=578&id=u0bf95cbb&originHeight=1156&originWidth=1908&originalType=binary&ratio=2&rotation=0&showTitle=false&size=447500&status=done&style=none&taskId=u9b5261d8-5e1b-4637-9fb9-71a7af9dfb6&title=&width=954" alt="image.png"></p>
<pre><code class="java"> @Override
    public Result sign() &#123;
        // 1.获取当前登录用户
        Long userId = UserHolder.getUser().getId();
        // 2.获取日期
        LocalDateTime now = LocalDateTime.now();
        // 3.拼接key
        String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));
        String key = USER_SIGN_KEY + userId + keySuffix;
        // 4.获取今天是本月的第几天
        int dayOfMonth = now.getDayOfMonth();
        // 5.写入Redis SETBIT key offset 1
        stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);
        return Result.ok();
    &#125;
</code></pre>
<h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700399217681-4d4061bc-adb9-4708-add8-bd9d29cf86cc.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=295&id=u25f36d64&originHeight=295&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102345&status=done&style=none&taskId=u76fe03cb-82dc-4e64-8fe0-1a1a538f72e&title=&width=967" alt="image.png"></p>
<pre><code class="java">    @Override
    public Result signCount() &#123;
        // 1.获取当前登录用户
        Long userId = UserHolder.getUser().getId();
        // 2.获取日期
        LocalDateTime now = LocalDateTime.now();
        // 3.拼接key
        String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));
        String key = USER_SIGN_KEY + userId + keySuffix;
        // 4.获取今天是本月的第几天
        int dayOfMonth = now.getDayOfMonth();
        // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0
        List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(
                key,
                BitFieldSubCommands.create()
                        .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)
        );
        if (result == null || result.isEmpty()) &#123;
            // 没有任何签到结果
            return Result.ok(0);
        &#125;
        Long num = result.get(0);
        if (num == null || num == 0) &#123;
            return Result.ok(0);
        &#125;
        // 6.循环遍历
        int count = 0;
        while (true) &#123;
            // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0
            if ((num &amp; 1) == 0) &#123;
                // 如果为0，说明未签到，结束
                break;
            &#125;else &#123;
                // 如果不为0，说明已签到，计数器+1
                count++;
            &#125;
            // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位
            num &gt;&gt;&gt;= 1;
        &#125;
        return Result.ok(count);
    &#125;
</code></pre>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400801636-d5f48bdc-ddcb-4bd7-b197-5e9845d50821.png#averageHue=%23f3f3f3&clientId=u239d3de8-271e-4&from=paste&height=447&id=u5833066c&originHeight=447&originWidth=1609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178150&status=done&style=none&taskId=ueef19a98-2e62-4286-a3ac-40a5ba7a3df&title=&width=1609" alt="image.png"><br>举自己的个人博客网站的例子:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400834771-bf1af00f-3d3f-40ec-ba7b-ee82d8446f49.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=82&id=u05146455&originHeight=82&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4969&status=done&style=none&taskId=u84d83b80-b749-4862-b015-344bcfa6604&title=&width=360" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700401716213-68550223-ad11-4850-8639-54483a560d74.png#averageHue=%23a9ac9e&clientId=u239d3de8-271e-4&from=paste&height=743&id=ua6f5d2d9&originHeight=743&originWidth=1651&originalType=binary&ratio=1&rotation=0&showTitle=false&size=517952&status=done&style=none&taskId=ua2ba5f5d-23dc-4194-9a48-ec3fd79b420&title=&width=1651" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402111007-fec55a72-871e-4ccd-90e8-3a29ca73f275.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=514&id=u39fc541a&originHeight=514&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254600&status=done&style=none&taskId=u69394d77-a7d2-4d5e-a8b6-a85c87c5a85&title=&width=1001" alt="image.png"></p>
<h2 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h2><p>每一次充满容量为1000的数组发给redis. 不能一次发送100万条数据呀</p>
<pre><code class="java">    @Test
    void testHyperLogLog() &#123;
        String[] values = new String[1000];
        int j = 0;
        for (int i = 0; i &lt; 1000000; i++) &#123;
            j = i % 1000;
            values[j] = &quot;user_&quot; + i;
            if(j == 999)&#123;
                // 发送到Redis
                stringRedisTemplate.opsForHyperLogLog().add(&quot;hl2&quot;, values);
            &#125;
        &#125;
        // 统计数量
        Long count = stringRedisTemplate.opsForHyperLogLog().size(&quot;hl2&quot;);
        System.out.println(&quot;count = &quot; + count);
    &#125;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402938508-b14c9aa3-ca7e-4601-a734-0e8d9ed51826.png#averageHue=%232c2c2b&clientId=u239d3de8-271e-4&from=paste&height=135&id=ub131f0bb&originHeight=135&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5181&status=done&style=none&taskId=u34cce56e-e5ae-4949-91b7-55d0ed80cf9&title=&width=516" alt="image.png"><br>会有一些误差. 问题不大</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://axdmdyj.github.io">Lorain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://axdmdyj.github.io/posts/6bd5204f.html">https://axdmdyj.github.io/posts/6bd5204f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://axdmdyj.github.io" target="_blank">Lorain's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/">点评项目</a></div><div class="post_share"><div class="social-share" data-image="https://tse1-mm.cn.bing.net/th/id/OIP-C.ggP8vzkJJJUluo3rx6Ul2gHaEo?rs=1&amp;pid=ImgDetMain" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/dashang.jpg" target="_blank"><img class="post-qr-code-img" src="/img/dashang.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zhifubao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/cc7ca809.html" title="动态规划理论"><img class="cover" src="https://pic2.zhimg.com/80/v2-8cb34ba26d2bb76584541136f9b0aad5_720w.webp" onerror="onerror=null;src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态规划理论</div></div></a></div><div class="next-post pull-right"><a href="/posts/e7c3359a.html" title="数据结构常见问题"><img class="cover" src="https://img.51miz.com/Element/00/79/35/64/136a9f18_E793564_3d30f33d.png" onerror="onerror=null;src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构常见问题</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/bj.webp'" alt="avatar"/></div><div class="author-info__name">Lorain</div><div class="author-info__description">总之岁月漫长,然而值得等待</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/axdmdYJ"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的个人博客，在这里你会看到小卡拉米的成长之路，分享个人学习笔记，以及知识点总结...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">发送验证码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C"><span class="toc-number">1.2.</span> <span class="toc-text">短信验证码登录和注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.3.</span> <span class="toc-text">登录校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">集群的session共享问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB%E7%99%BB%E5%BD%95"><span class="toc-number">1.5.</span> <span class="toc-text">基于redis实现session共享登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">1.6.</span> <span class="toc-text">基于redis实现短信登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">拦截器优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">添加用户缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4"><span class="toc-number">2.4.</span> <span class="toc-text">实现商品缓存和数据库一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.5.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">编码解决缓存穿透问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.7.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">利用互斥锁解决缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">利用逻辑过期方式解决缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85"><span class="toc-number">2.11.</span> <span class="toc-text">缓存工具封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93"><span class="toc-number">2.12.</span> <span class="toc-text">缓存总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">3.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">3.1.</span> <span class="toc-text">全局唯一ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-number">3.2.</span> <span class="toc-text">添加优惠券</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E7%9A%84%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.</span> <span class="toc-text">实现优惠券秒杀的下单功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">库存超卖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">3.5.</span> <span class="toc-text">一人一单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.</span> <span class="toc-text">一人一单并发安全问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">4.2.</span> <span class="toc-text">Redis分布式锁实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC"><span class="toc-number">4.3.</span> <span class="toc-text">实现分布式锁初级版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">Redis分布式锁的误删问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%94%81%E7%9A%84%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">4.5.</span> <span class="toc-text">解决锁的误删问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">分布式锁的原子性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">Lua解决多条命令原子性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E6%94%B9%E8%BF%9BRedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.8.</span> <span class="toc-text">再次改进Redis的分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.9.</span> <span class="toc-text">Redisson功能介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">4.10.</span> <span class="toc-text">Redisson可重入锁原理原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.11.</span> <span class="toc-text">基于redis分布式锁优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">秒杀优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">6.</span> <span class="toc-text">达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">6.1.</span> <span class="toc-text">发布探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">6.2.</span> <span class="toc-text">查看探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">完善点赞功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">6.4.</span> <span class="toc-text">点赞排行榜</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">7.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3%E5%8A%9F%E8%83%BD"><span class="toc-number">7.1.</span> <span class="toc-text">实现关注和取关功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">7.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">关注推送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD"><span class="toc-number">7.4.</span> <span class="toc-text">基于推模式实现关注推送功能.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E4%BB%B6%E5%95%86%E9%93%BA"><span class="toc-number">8.</span> <span class="toc-text">附件商铺</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">GEO数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E5%95%86%E9%93%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">8.2.</span> <span class="toc-text">查找附近商铺功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">9.</span> <span class="toc-text">签到功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bitmap%E7%94%A8%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">bitmap用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.</span> <span class="toc-text">实现签到功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">9.3.</span> <span class="toc-text">签到统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">9.4.</span> <span class="toc-text">UV统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">9.5.</span> <span class="toc-text">实现UV统计</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/852cfab6.html" title="进程管理"><img src="https://img.3dmgame.com/uploads/images/news/20191101/1572593491_374100.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="进程管理"/></a><div class="content"><a class="title" href="/posts/852cfab6.html" title="进程管理">进程管理</a><time datetime="2024-04-09T09:53:16.000Z" title="发表于 2024-04-09 17:53:16">2024-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4a58d47c.html" title="手写mini-HashMap"><img src="https://img.3dmgame.com/uploads/images/news/20191101/1572593491_374100.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="手写mini-HashMap"/></a><div class="content"><a class="title" href="/posts/4a58d47c.html" title="手写mini-HashMap">手写mini-HashMap</a><time datetime="2024-03-06T01:49:01.000Z" title="发表于 2024-03-06 09:49:01">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5fdd80a8.html" title="还迷糊事务的并发问题以及隔离级别？"><img src="https://pic.3gbizhi.com/uploadmark/20240205/1e2b570db66f196368226ab7f63e98df.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="还迷糊事务的并发问题以及隔离级别？"/></a><div class="content"><a class="title" href="/posts/5fdd80a8.html" title="还迷糊事务的并发问题以及隔离级别？">还迷糊事务的并发问题以及隔离级别？</a><time datetime="2024-02-20T02:50:20.000Z" title="发表于 2024-02-20 10:50:20">2024-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c31889ef.html" title="JVM常见问题"><img src="https://pica.zhimg.com/v2-077a594b1a64d55e95de392755a8aa76_r.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="JVM常见问题"/></a><div class="content"><a class="title" href="/posts/c31889ef.html" title="JVM常见问题">JVM常见问题</a><time datetime="2024-02-17T08:50:45.000Z" title="发表于 2024-02-17 16:50:45">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20748c35.html" title="泛型在项目中不怎么用？这次结合实战！"><img src="https://i.pinimg.com/736x/b6/29/2b/b6292b62b7758d2b8c41831125af576b.jpg" onerror="this.onerror=null;this.src='https://unpkg.com/plasx@1.0.3/img/404.webp'" alt="泛型在项目中不怎么用？这次结合实战！"/></a><div class="content"><a class="title" href="/posts/20748c35.html" title="泛型在项目中不怎么用？这次结合实战！">泛型在项目中不怎么用？这次结合实战！</a><time datetime="2024-02-14T14:33:44.000Z" title="发表于 2024-02-14 22:33:44">2024-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://tse1-mm.cn.bing.net/th/id/OIP-C.ggP8vzkJJJUluo3rx6Ul2gHaEo?rs=1&amp;pid=ImgDetMain')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lorain</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'aX6NXi9vT0pNPR8RUR37YZmC-gzGzoHsz',
      appKey: '39u7DWzRXJqme25hLiHeHKho',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png"," tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png ","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>