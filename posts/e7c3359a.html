<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="总之岁月漫长,然而值得等待"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>数据结构常见问题 | Lorain's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lorain's Blog" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">Lorain's Blog</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">数据结构常见问题</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/posts/e7c3359a.html">2023-11-11</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/">小知识</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h1 id="day1-链表"><a href="#day1-链表" class="headerlink" title="day1-链表"></a>day1-链表</h1><ul>
<li><strong>描述一下链表的数据结构？</strong></li>
</ul>
<p>链表是由节点类组成 ,其中包括值, 以及其他节点的引用组成, 通过引用指向 , 串成一个链表.</p>
<p>链表包含三种类型:  单向链表(每个节点只有指向下一个节点的引用), 双向链表:(有上一个节点和下一个节点的引用),  循环链表(最后一个节点的next引用指向头结点,形成循环结构)</p>
<ul>
<li><strong>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</strong></li>
</ul>
<p>LinkedList 使用的是双向链表,</p>
<ul>
<li><strong>链表中数据的插入、删除、获取元素，时间复杂度是多少？</strong></li>
</ul>
<p>插入和删除的时间复杂度是O(1) , 获取元素的时间复杂度是O(n)</p>
<ul>
<li><strong>什么场景下使用链表更合适？</strong></li>
</ul>
<p> 在需要频繁的增加或删除节点的场景下使用链表更合适</p>
<p>不需要预先分配内存大小.</p>
<p>不需要快速随机访问</p>
<p>节省内存,   不需要分配连续的内存块.这在内存优先的嵌入式系统或移动设备很有用</p>
<h1 id="day2-数组"><a href="#day2-数组" class="headerlink" title="day2-数组"></a>day2-数组</h1><ol>
<li><strong>数据结构中有哪些是线性表数据结构？</strong></li>
</ol>
<p>数组: 每个元素都有唯一的索引, 在内存中地址连续</p>
<p>链表: 动态数据结构, 由节点构成, 每个节点存储着数据和指向下一个节点的引用</p>
<p>栈: 只有栈顶元素可以被访问, 插入和删除操作都发生在栈顶</p>
<p>队列: 插入在队尾, 删除在队首</p>
<ol>
<li>数<strong>组的元素删除和获取，时间复杂度是多少？</strong></li>
</ol>
<p>获取时间复杂度是O(1) </p>
<p>删除操作时间复杂度也是O(1), 但是删除的元素后面都需要向前移动, 所以平均情况下也是O(n)</p>
<p>删除是O(n), 获取是O(1)</p>
<ol>
<li>A<strong>rrayList 中默认的初始化长度是多少？</strong></li>
</ol>
<p>10</p>
<ol>
<li><strong>ArrayList 中扩容的范围是多大一次？</strong></li>
</ol>
<p><strong>先判断是否需要扩容,</strong> 如果扩容,咋会扩容1.5倍一次</p>
<ol>
<li>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什</li>
</ol>
<p> <code>System.arraycopy</code> 是 Java 标准库提供的数组拷贝方法:</p>
<ul>
<li><code>src</code>：原数组，即要复制的数据源。</li>
<li><code>srcPos</code>：从原数组的哪个位置开始复制。</li>
<li><code>dest</code>：目标数组，即复制到的位置。</li>
<li><code>destPos</code>：从目标数组的哪个位置开始粘贴。</li>
<li><code>length</code>：要复制的元素数量。</li>
</ul>
<p>在 <code>ArrayList</code> 的情境中，<code>src</code> 是原数组，<code>srcPos</code> 是0（从第一个元素开始复制），<code>dest</code> 是新数组，<code>destPos</code> 是0（从第一个位置开始粘贴），<code>length</code> 是原数组中的元素数量。这就完成了原数组元素到新数组的复制操作。</p>
<p>最后，<code>ArrayList</code> 更新内部的引用，将原数组引用指向新数组，使新数组成为 <code>ArrayList</code> 的内部数组缓冲区。原数组将被垃圾回收。 </p>
<h1 id="day3-队列"><a href="#day3-队列" class="headerlink" title="day3-队列"></a>day3-队列</h1><p><strong>单端队列和双端队列，分别对应的实现类是哪个？</strong></p>
<p><strong>单端队列可以有链表(LinkedList)实现或者是</strong><code>**ArrayDeque**</code><strong>类实现, 使用add和remove方法操作</strong></p>
<p><strong>简述延迟队列&#x2F;优先队列的实现方式以及应用场景?</strong></p>
<p><strong>延迟队列:</strong> </p>
<p><strong>实现方式</strong>：延迟队列通常是基于优先队列实现的。在Java中，常用的实现类是<strong>DelayQueue</strong>。它内部使用了一个优先队列（通常是二叉堆）来存储元素，但每个元素都有一个延迟时间，通过延迟时间作为条件排序, 只有当元素的延迟时间到达后，它才能被取出。这是通过元素的<strong>getDelay</strong>方法来实现的。</p>
<p>优先队列: </p>
<p><strong>优先队列（Priority Queue）</strong>：</p>
<ul>
<li><strong>实现方式</strong>：优先队列可以使用多种数据结构来实现，其中最常见的是二叉堆。在Java中，<strong>PriorityQueue</strong>就是一个二叉堆实现的优先队列。它使用小顶堆（最小元素在队头）或大顶堆（最大元素在队头）来维护元素的优先级顺序。元素的优先级通常由它们的自然顺序（实现<strong>Comparable</strong>接口）或自定义比较器（实现<strong>Comparator</strong>接口）来决定。</li>
</ul>
<p><strong>延迟队列和优先队列应用场景?</strong></p>
<p>延迟队列常用于实现定时任务调度，任务的执行时间可以被设置为延迟时间，从而实现任务的延迟执行。</p>
<p>优先队列常用于需要按照优先级顺序处理元素的场景，如任务调度、Dijkstra算法等。在任务调度中，任务的优先级可以表示任务的紧急程度或重要性，高优先级任务会先被执行。</p>
<h1 id="day4-堆栈"><a href="#day4-堆栈" class="headerlink" title="day4-堆栈"></a>day4-堆栈</h1><p><strong>堆栈使用场景?</strong></p>
<p>需要使用先入后出的数据结构和场景, 比如:递归算法(每次递归,调用相关信息压入堆栈), 浏览器历史, 函数调用等</p>
<p><strong>为什么不是用 Stack 类？</strong></p>
<p>Stack十分粗糙并且过时, 效率低下</p>
<p><strong>ArrayDeque是基于什么实现的?</strong></p>
<p>基于数组实现的堆栈数据结构</p>
<p><strong>ArrayDeque 数据结构使用过程叙述。</strong></p>
<p>ArrayDeque是双端队列, 提供两端插入和弹出的方法, 支持在队头和队尾执行各种操作</p>
<p><strong>ArrayDeque为什么要初始化2的n次幂个长度</strong></p>
<p>为了便于无符号取模(2^n - 1) 得到索引, 比一般的取模运算快得多, 减少扩容次数, </p>
<h1 id="day5-哈希表（散列）"><a href="#day5-哈希表（散列）" class="headerlink" title="day5-哈希表（散列）"></a>day5-哈希表（散列）</h1><ul>
<li><strong>介绍一下散列表</strong></li>
</ul>
<p>散列表是一种数据结构, 基于散列函数, 将键映射到存储值数组的特定位置,  以便在常数时间内进行快速查找, 插入, 删除操作. 通常适用于需要快速查找和插入的情况, 特别是当数据集较大且充足时.</p>
<ul>
<li><strong>为什么使用散列表</strong></li>
</ul>
<p>能够快速查找和输入, 提供了平均情况O(1)的时间复杂度</p>
<p>灵活的键-值映射,</p>
<ul>
<li><strong>拉链寻址和开放寻址的区别</strong></li>
</ul>
<p>拉链寻址中, 每个散列槽(或哈希桶)都存储一个链表, 数组或其他数据结构. 消耗内存</p>
<p>开放寻址, 所有元素都存储在散列槽中, 如果发生冲突, 查找下一个可用的槽, 直到找到空槽, 或遍历整个散列表. 可能会导致散列表出现堆积, 使得性能下降</p>
<ul>
<li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li>
</ul>
<p>通过合并散列, 杜鹃散列, 跳房子散列,  罗宾汉哈希算法也是可以解决散列哈希索引冲突</p>
<ul>
<li>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</li>
</ul>
<p>通过拉链法, 在冲突位置(索引位置)上, 有一个链表, 将具有相同索引的元素串起来</p>
<h1 id="day6-堆-Heap"><a href="#day6-堆-Heap" class="headerlink" title="day6-堆 Heap"></a>day6-堆 Heap</h1><ul>
<li><strong>堆的数据结构是什么样？</strong></li>
</ul>
<p>堆是一种特殊的树形结构, 通常是一种完全二叉树. 在堆中, 每个节点都有一个值, 通常从父节点-&gt;子节点 或子节点-&gt;父节点都有一种特定的顺序 </p>
<ul>
<li><strong>堆的数据结构使用场景？</strong></li>
</ul>
<p>可以实现一种高效的排序算法-&gt;堆排序</p>
<p>可以用作优先队列, 允许高优先级的快速出队</p>
<p>可以实现高效的数据结构,比如斐波那契堆</p>
<ul>
<li><strong>堆的数据结构实现方式有哪些？</strong></li>
</ul>
<p>二叉堆(最小堆和最大堆) , 二顶堆, 后面不了解: 斐波那契堆,左偏树.</p>
<ul>
<li><strong>最小堆和最大堆的区别是什么？</strong></li>
</ul>
<p><strong>在最小堆中, 根节点的值最小, 每一个父节点的值小于等于子节点</strong></p>
<p><strong>最大堆则相反</strong></p>
<ul>
<li><strong>有了解斐波那契堆吗？</strong></li>
</ul>
<p>斐波那契堆是一种多叉堆，通常用于一些高级的图算法和优化问题。与二叉堆不同，斐波那契堆允许节点具有任意数量的子节点，使得合并操作更加高效。斐波那契堆的插入和删除操作通常具有分摊常数时间复杂度。这种堆的一个应用是最小生成树算法Prim和Dijkstra的高效实现。它还在某些离线最小生成树算法中得到了广泛应用。</p>
<h1 id="day7-字典树Trie"><a href="#day7-字典树Trie" class="headerlink" title="day7-字典树Trie"></a>day7-字典树Trie</h1><ul>
<li><strong>简述字典树的数据结构</strong></li>
</ul>
<p>字典树是一中树型的数据结构, 每个节点包含一个字符, 从根节点开始的路径代表一个字符串. 树的分支代表字符的不同选择.</p>
<ul>
<li><strong>叙述你怎么来实现一个字典树</strong></li>
</ul>
<p>先创建一个根节点 -&gt; 插入字符串, 从根节点开始, 按照字符串每个字符依次创建节点 . 直到构建整个字符串. 最后的结点标记为字符串的结束</p>
<ul>
<li><strong>字典树的实际业务场景举例</strong></li>
</ul>
<p>排序、全文搜索、网络搜索引擎、生物信息</p>
<ul>
<li><strong>字典树的存入和检索的时间复杂度</strong></li>
</ul>
<p>插入O(L)  检索O(L)  L是字符串的长度, 都需要遍历字符串的每个字符</p>
<ul>
<li>还有哪些字典树的实现方式</li>
</ul>
<p>【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Suffix_tree">后缀树(opens new window)</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_trie">哈希树(opens new window)</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HAT-trie">帽子树(opens new window)</a>】</p>
<h1 id="day8-二叉树"><a href="#day8-二叉树" class="headerlink" title="day8-二叉树"></a>day8-二叉树</h1><ul>
<li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li>
</ul>
<p>二叉搜索树是一种特殊的属性结构, 每个节点都包含一个值, 左子节点的值小于父节点, 右子节点的值大于父节点. 每一个左子树和右子树同样也是一个二叉搜索树</p>
<ul>
<li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li>
</ul>
<p>平均情况下, 均为Log(n) 最坏情况下均为O(n)</p>
<ul>
<li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li>
</ul>
<ol>
<li>找到要删除的节点，通常找其右子树中最小的节点或左子树中最大的节点，也可以选择前驱节点或后继节点。</li>
<li>复制该节点的值到要删除的节点。</li>
<li>删除找到的前驱节点或后继节点，此时它可能只有一个子节点或没有子节点，这是一个递归操作。</li>
</ol>
<ul>
<li><p>二<strong>叉搜索树的节点都包括了哪些信息</strong></p>
<pre><code>节点值, 左子树, 右子树
</code></pre>
</li>
<li><p><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></p>
</li>
</ul>
<p>出于性能和平衡的考虑, 红黑树的时间复杂度能够维持在O(logn)范围内</p>
<p>同时避免了树退化成链表的情况</p>
<h1 id="day9-AVL"><a href="#day9-AVL" class="headerlink" title="day9-AVL"></a>day9-AVL</h1><ul>
<li><strong>AVL 树平衡因子怎么计算？</strong></li>
</ul>
<p>左子树的高度减去右子树；</p>
<ul>
<li><strong>AVL 树左旋操作的目的是什么？</strong></li>
</ul>
<p>将一个节点的右子树变为新的根节点，以保持 AVL 树的平衡性。左旋操作用于解决右子树高度过高的情况</p>
<ul>
<li><strong>AVL 树左旋操作的流程是什么？</strong></li>
</ul>
<ol>
<li>假设要左旋的节点为 N，它的右子节点为 R。</li>
<li>将 R 的左子节点变为 N 的右子节点，同时更新 N 的右子节点为 R 的左子节点。</li>
<li>将 N 的父节点（如果存在）指向 R，以及将 R 的父节点指向 N 的原父节点。</li>
<li>最后，更新 N 和 R 的高度信息。</li>
</ol>
<ul>
<li><strong>AVL 树什么情况下要左旋+右旋？</strong></li>
</ul>
<ol>
<li>当一个节点的平衡因子为 2，且其左子树的平衡因子为 -1（或者是左子树的平衡因子为 0）时，需要先对左子树进行左旋，再对当前节点进行右旋，以达到平衡。</li>
<li>当一个节点的平衡因子为 -2，且其右子树的平衡因子为 1（或者是右子树的平衡因子为 0）时，需要先对右子树进行右旋，再对当前节点进行左旋，以达到平衡。</li>
</ol>
<ul>
<li><strong>AVL 树的插入和读取的时间复杂度？</strong></li>
</ul>
<p>AVL 树的插入和读取的时间复杂度为 O(log n)，其中 n 表示树中节点的数量。这是因为 AVL 树通过旋转操作来保持平衡，使得树的高度保持在 O(log n) 的水平。因此，插入和读取操作的时间复杂度都是 O(log n)。</p>
<h1 id="day10-2-3-树"><a href="#day10-2-3-树" class="headerlink" title="day10-2-3-树"></a>day10-2-3-树</h1><ul>
<li><p><strong>2-3树的数据结构描述</strong></p>
<ul>
<li><p>每个节点可以包含 1 个或 2 个元素。</p>
</li>
<li><p>如果一个节点包含 1 个元素，它有 2 个子节点。</p>
</li>
<li><p>如果一个节点包含 2 个元素，它有 3 个子节点。</p>
</li>
</ul>
</li>
<li><p>2-3树一个节点最多可以存放几个元素</p>
</li>
</ul>
<p>2个</p>
<ul>
<li><strong>2-3树插入节点时间复杂度</strong></li>
</ul>
<p>时间复杂度是 O(log n)，其中 n 表示树中节点的数量。</p>
<ul>
<li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li>
</ul>
<p>当一个节点已经包含 3 个元素时，需要进行分裂操作。分裂操作会将这个节点分为两个节点，每个节点包含 1 个元素。分裂操作的过程不需要旋转，而是将中间元素上移，形成一个新的父节点。</p>
<ul>
<li><strong>2-3树，你能手写一下吗</strong>？</li>
</ul>
<p>以下是一个简单的示例，假设我们要插入元素 7 到一个已经包含元素 4、9 的节点中：</p>
<pre><code class="plain">Before Insertion:
     4 9

After Insertion:
    4 7 9
</code></pre>
<p>在这个示例中，插入元素 7 后，原节点中的元素 4 和 9 会变成两个独立的节点，中间元素 7 上移，成为它们的新父节点。这就是 2-3树的分裂操作。</p>
<h1 id="day11-红黑树"><a href="#day11-红黑树" class="headerlink" title="day11-红黑树"></a>day11-红黑树</h1><ul>
<li><strong>红黑树都有哪些使用场景？</strong></li>
</ul>
<ol>
<li>数据库系统中，用于索引的实现，例如 InnoDB 存储引擎使用 B+树，而 B+树本质上是一种特殊的红黑树。</li>
<li>在编程语言的编译器和解释器中，用于实现符号表（Symbol Table）。</li>
<li>在 Java 的集合框架中，TreeMap 和 TreeSet 使用红黑树来实现有序的数据结构。</li>
</ol>
<ul>
<li><strong>相比于BST树，红黑树有什么用途？</strong></li>
</ul>
<ol>
<li>自平衡性：红黑树能够自动维护平衡，确保树的高度保持在较低的水平，因此查找、插入和删除等操作的时间复杂度是 O(log n)。</li>
<li>有序性：红黑树是有序的数据结构，可以方便地进行范围查询和有序遍历。</li>
<li>稳定性：插入和删除操作不会导致树的大规模重构，保持了数据的稳定性</li>
</ol>
<ul>
<li><strong>B-树是什么意思，都包括哪些？</strong></li>
</ul>
<p>是一种平衡的多路搜索树，通常用于外部存储，例如数据库和文件系统中的索引结构。B-树是一棵多叉树，每个节点可以包含多个子节点。B-树的特点包括：</p>
<ol>
<li>所有叶子节点都在同一层，使得每次查询时磁盘 I&#x2F;O 次数保持较低。</li>
<li>每个节点可以包含多个键值对，不仅仅包含 2 个（如红黑树的节点）。</li>
</ol>
<ul>
<li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li>
</ul>
<ol>
<li>当新插入节点是根节点时，需要将该节点染成黑色，以满足红黑树性质。</li>
<li>当新插入节点的父节点是黑色时，不需要进行任何操作，红黑树性质不受影响。</li>
<li>当新插入节点的父节点是红色时，需要进行染色和旋转操作，以恢复红黑树性质。</li>
</ol>
<p>具体的左旋和左旋+右旋操作会在不满足红黑树性质的情况下进行，以重新平衡树的结构。</p>
<ul>
<li><strong>红黑树的特点是什么？</strong></li>
</ul>
<p>红黑树的特点包括：</p>
<ol>
<li>每个节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL 节点）是黑色。</li>
<li>如果一个节点是红色，那么它的子节点必须是黑色。</li>
<li>从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li>
<li>没有两个相邻的红色节点，即红黑树中不存在连续的红色节点。</li>
</ol>
<h1 id="day12-并查集"><a href="#day12-并查集" class="headerlink" title="day12-并查集"></a>day12-并查集</h1><ul>
<li><strong>并查集叙述？</strong></li>
</ul>
<p>并查集（Disjoint-Set Union，DSU）是一种数据结构，用于管理一系列不相交的集合（或称为集合分区）。它支持两种主要操作：查找（Find）和合并（Union）。并查集的主要目标是确定两个元素是否属于同一个集合，以及将两个集合合并为一个集合。</p>
<ul>
<li><strong>并查集的使用场景？</strong></li>
</ul>
<ol>
<li>连通性问题：并查集常用于解决网络连通性问题，如判断网络中的设备是否互通。</li>
<li>图的连通分量：在图论中，它可用于查找图的连通分量。</li>
<li>集合的合并：在算法和数据结构中，用于合并不相交的集合，例如 Kruskal 算法中用于最小生成树的构建</li>
</ol>
<ul>
<li><strong>并查集怎么合并元素？</strong></li>
</ul>
<p>合并元素： 合并两个元素的集合通常是通过将其中一个元素的根节点连接到另一个元素的根节点来实现。</p>
<ul>
<li>并查集合并元素的优化策略？</li>
</ul>
<ol>
<li>“Union by Rank”（按秩合并）：将较短的树合并到较高的树上。每个树的节点维护一个秩（或者称为深度），合并时将秩较小的树连接到秩较大的树上，以确保树的高度不会过大。</li>
<li>“Path Compression”（路径压缩）：在查找根节点时，将遍历过的节点都直接连接到根节点，以减小后续查找操作的时间复杂度。这是通过递归或循环方式实现的。</li>
</ol>
<ul>
<li><strong>如何压缩路径？</strong></li>
</ul>
<p>路径压缩是指在查找根节点时，将沿途的节点直接连接到根节点，以减小树的高度，从而提高后续操作的效率。路径压缩可以通过递归或迭代方式实现。</p>
<p>在路径压缩中，当查找根节点时，会将当前节点的父节点直接更新为根节点。这样，在后续查找操作中，沿途的节点都会指向根节点，从而加速查找操作。</p>
<h1 id="day13-图"><a href="#day13-图" class="headerlink" title="day13-图"></a>day13-图</h1><ul>
<li><strong>图的使用场景是什么？</strong></li>
</ul>
<ol>
<li>社交网络：图可用于表示社交网络中的用户和他们之间的关系，如朋友关系、关注关系等。</li>
<li>地图和导航系统：地图应用可以使用图来表示道路、城市和导航路径，以帮助用户找到最短路径。</li>
<li>网络拓扑：在计算机网络中，图可用于表示网络拓扑结构，包括路由器、交换机和连接。</li>
<li>任务调度：图可以表示任务和它们之间的依赖关系，用于任务调度和优化。</li>
<li>推荐系统：用于生成用户和项目之间的关系图，以提供个性化推荐。</li>
<li>数据分析：在数据分析中，图可以用于表示数据之间的关系，以进行关联性分析和可视化。</li>
<li>语义网络：图可用于构建语义网络，用于自然语言处理和知识表示。</li>
<li>游戏开发：图可用于表示游戏中的地图、任务和角色之间的关系。</li>
</ol>
<ul>
<li><strong>图有的分类？</strong></li>
</ul>
<ol>
<li>有向图（Directed Graph）：图中的边具有方向，表示从一个顶点到另一个顶点的有向关系。</li>
<li>无向图（Undirected Graph）：图中的边没有方向，表示两个顶点之间的无向关系。</li>
<li>带权图（Weighted Graph）：图中的边带有权重或成本，表示不同路径的成本。</li>
<li>有向无环图（DAG，Directed Acyclic Graph）：有向图中不存在形成环的路径。</li>
<li>连通图（Connected Graph）：无向图中的任意两个顶点之间都存在路径。</li>
<li>无环图（Acyclic Graph）：图中不存在形成环的路径。</li>
</ol>
<ul>
<li><strong>图怎么存放权重值？</strong></li>
</ul>
<p>权重通常存放在图的边上，每条边都可以具有一个权重值，用于表示连接两个顶点之间的成本或距离。在编程中，可以使用邻接矩阵或邻接表等数据结构来存储带权图的权重信息。</p>
<ul>
<li><strong>图的广度遍历</strong></li>
</ul>
<p>图的广度遍历（Breadth-First Search，BFS）： BFS 是一种用于遍历图的算法，它从起始顶点开始，首先访问起始顶点的所有相邻顶点，然后逐层扩展，依次访问更远的顶点。BFS 可用于查找最短路径、连通性检查和拓扑排序等任务。</p>
<ul>
<li><strong>图的深度遍历</strong></li>
</ul>
<p>DFS 是一种递归或栈的方式来遍历图的算法，它从起始顶点开始，首先访问一个相邻顶点，然后递归地访问这个相邻顶点的未访问邻居，直到到达最远的顶点，然后回溯并继续遍历其他分支。DFS 可用于查找路径、拓扑排序和连通性检查等任务。</p>
<h1 id="day14-布隆过滤器"><a href="#day14-布隆过滤器" class="headerlink" title="day14-布隆过滤器"></a>day14-布隆过滤器</h1><ul>
<li><strong>布隆过滤器的使用场景？</strong></li>
</ul>
<ol>
<li>数据缓存：用于快速检查某个数据是否在缓存中，从而避免查询数据库或磁盘操作。</li>
<li>防止缓存穿透：用于检查请求的数据是否有效，避免频繁请求不存在的数据。</li>
<li>网页爬虫去重：用于检查已经爬取的网页 URL，避免重复爬取。</li>
<li>邮件服务器：用于检查电子邮件地址是否有效，防止垃圾邮件地址。</li>
<li>数据库查询优化：用于加速数据库查询操作，判断数据是否存在于数据库表中。</li>
<li>拦截器过滤：用于拦截恶意请求，检查是否在黑名单中。</li>
</ol>
<ul>
<li><strong>布隆过滤器的实现原理和方式？</strong></li>
</ul>
<p>布隆过滤器的基本思想是使用多个哈希函数（通常称为哈希算法），将元素映射到位数组（Bit Array）中的多个位上。当检查某个元素是否存在时，计算它的哈希值，然后查看位数组上对应位置的位是否都为1。如果所有哈希值对应的位都为1，说明元素可能存在；如果有一个或多个位为0，说明元素肯定不存在。</p>
<ul>
<li><strong>如何提高布隆过滤器的准确性</strong>？</li>
</ul>
<p>关于提高布隆过滤器的准确性：</p>
<ul>
<li><p>增加哈希函数的数量：使用更多的哈希函数可以减小碰撞的概率，提高准确性。但需要权衡时间和空间开销。</p>
</li>
<li><p>动态调整布隆过滤器的大小：根据实际使用情况，动态调整布隆过滤器的大小，以降低误判率。</p>
</li>
<li><p><strong>有哪些中哈希计算方式？</strong></p>
</li>
</ul>
<ol>
<li>哈希函数：应用单一哈希函数，计算元素的哈希值。</li>
<li>多哈希函数：应用多个哈希函数，计算多个哈希值。</li>
</ol>
<ul>
<li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li>
</ul>
<ol>
<li>基本布隆过滤器：实现基本的布隆过滤器功能，例如判断元素是否存在。</li>
<li>可动态扩展的布隆过滤器：支持动态添加元素和自动扩展位数组大小，以适应不断变化的数据。</li>
<li>可序列化的布隆过滤器：支持将布隆过滤器序列化到文件或内存，以便后续加载和使用。</li>
<li>支持删除操作的布隆过滤器：支持从布隆过滤器中删除元素，通常需要额外的位数组标记删除。</li>
<li>高级性能布隆过滤器：优化过的布隆过滤器，提供更高的性能和低误判率。</li>
</ol>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Lorain</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/posts/e7c3359a.html">https://axdmdyj.github.io/posts/e7c3359a.html</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://axdmdyj.github.io">Lorain的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#day1-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">day1-链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day2-%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">day2-数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day3-%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">day3-队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day4-%E5%A0%86%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">day4-堆栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day5-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">day5-哈希表（散列）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day6-%E5%A0%86-Heap"><span class="toc-number">6.</span> <span class="toc-text">day6-堆 Heap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day7-%E5%AD%97%E5%85%B8%E6%A0%91Trie"><span class="toc-number">7.</span> <span class="toc-text">day7-字典树Trie</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day8-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">day8-二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day9-AVL"><span class="toc-number">9.</span> <span class="toc-text">day9-AVL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-2-3-%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">day10-2-3-树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">day11-红黑树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day12-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">12.</span> <span class="toc-text">day12-并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day13-%E5%9B%BE"><span class="toc-number">13.</span> <span class="toc-text">day13-图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day14-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">day14-布隆过滤器</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/posts/6bd5204f.html">&lt; 点评项目实战</a><a class="next" href="/posts/43a71ae4.html">索引 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'aX6NXi9vT0pNPR8RUR37YZmC-gzGzoHsz',
  appKey:'39u7DWzRXJqme25hLiHeHKho',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2024 <a href="/." rel="nofollow">Lorain's Blog</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>