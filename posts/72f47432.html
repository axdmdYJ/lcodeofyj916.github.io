<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="总之岁月漫长,然而值得等待"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>垃圾回收 | Lorain's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lorain's Blog" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">Lorain's Blog</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">垃圾回收</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/posts/72f47432.html">2024-07-13</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/JVM/">JVM</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><blockquote>
<p>🌕垃圾回收对于 Java 党来说，是一个绕不开的话题，工作中涉及到的调优工作也经常围绕着垃圾回收器展开。面对不同的业务场景，往往需要不同的垃圾收集器才能保证 GC 性能，因此，对于面大厂或者有远大志向的球友可以卷一下垃圾收集器。</p>
</blockquote>
<h1 id="🌟分代垃圾回收机制"><a href="#🌟分代垃圾回收机制" class="headerlink" title="🌟分代垃圾回收机制"></a>🌟分代垃圾回收机制</h1><h2 id="堆内存大致分为两块："><a href="#堆内存大致分为两块：" class="headerlink" title="堆内存大致分为两块："></a>堆内存大致分为两块：</h2><p>新生代、老年代；新生代又划分为伊甸园、幸存区from、幸存区to。</p>
<p>长时间使用的对象放在老年代中，用完了就丢弃的对象放在新生代中。根据对象生命周期的不同特点，采用不同的垃圾回收算法，老年代发生次数少，新生代比较频繁。不同区域采用不同算法，更有效的对垃圾回收进行管理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881007627-58238735-ea09-46ba-8a18-eb949359a3d5.png" alt="img"></p>
<h2 id="分代垃圾回收怎么工作："><a href="#分代垃圾回收怎么工作：" class="headerlink" title="分代垃圾回收怎么工作："></a>分代垃圾回收怎么工作：</h2><p>java虚拟机本身就是一个小的操作系统吧？</p>
<ul>
<li>新创建的对象首先分配在 伊甸园区；</li>
<li>伊甸园 区空间不足时，触发 minor gc ，使用<strong>可达性分析</strong>算法沿着GC root引用链去找，进行标记的动作；</li>
<li>采用复制算法将 伊甸园 区 和幸存区from 区存活的对象复制到幸存区to 中，存活的对象年龄加一，然后交换 from to（这里很细节，实际变的不是两块物理地址，而是指针引用）；</li>
<li>minor gc 会引发 stop the world，因为垃圾回收的时候对象地址发生改变，如果其他线程也在运行，会造成混乱。暂停其他线程，等垃圾回收结束后，恢复用户线程运行；</li>
<li>新生代触发的STW的时间较短  </li>
<li>每次minorGC后，eden和from对象都清除干净了</li>
<li>每次都把不需要回收和幸存区from留下的移到To中，然后交换From和To的位置</li>
<li>当幸存区to对象的寿命超过阈值时，会晋升到老年代，最大寿命是15（4bit）</li>
<li>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li>
<li>如果老年代空间不足时，会先尝试触发 minor gc，如果空间仍然不足，那么就触发 full fc ，STW停止的时间更长！</li>
<li>from和to每次都要留一个空的，空间不足就触发gc，还不足就会触发提前晋升老年代，老年代如果放不下先触发full gc 然后再尝试提前晋升，还不行就Java heap space outofmemoryerror异常</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881771672-021f9d70-7ed1-45bb-a8b4-669bee5ffa8f.png" alt="img"></p>
<h3 id="1）相关-JVM-参数"><a href="#1）相关-JVM-参数" class="headerlink" title="1）相关 JVM 参数"></a>1）相关 JVM 参数</h3><p><strong>含义</strong>	                                       <strong>参数</strong></p>
<p>堆初始大小	                      -Xms</p>
<p>堆最大大小	                      -Xmx 或 -XX:MaxHeapSize&#x3D;size</p>
<p>新生代大小	                      -Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</p>
<p>幸存区比例（动态）	       -XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</p>
<p>幸存区比例	                      -XX:SurvivorRatio&#x3D;ratio</p>
<p>晋升阈值	                              -XX:MaxTenuringThreshold&#x3D;threshold</p>
<p>晋升详情	                              -XX:+PrintTenuringDistribution</p>
<p>GC详情	                             -XX:+PrintGCDetails -verbose:gc</p>
<p>FullGC 前 MinorGC	              -XX:+ScavengeBeforeFullGC</p>
<h3 id="2）GC-分析"><a href="#2）GC-分析" class="headerlink" title="2）GC 分析"></a>2）GC 分析</h3><h4 id="程序刚加载时的堆内存情况："><a href="#程序刚加载时的堆内存情况：" class="headerlink" title="程序刚加载时的堆内存情况："></a>程序刚加载时的堆内存情况：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648887378100-37e3a00f-3c41-43d5-8c39-92f11622161a.png" alt="img"></p>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><p>通过如下代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，什么时候 幸存区放不下，直接晋升老年代，使用前需要设置 jvm 参数。</p>
<pre><code class="java">public class Code_10_GCTest &#123;

    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
    public static void main(String[] args) &#123;
        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new byte[_6MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_6MB]);
        list.add(new byte[_512KB]);
        list.add(new byte[_6MB]);
    &#125;
&#125;
</code></pre>
<h4 id="大对象处理策略："><a href="#大对象处理策略：" class="headerlink" title="大对象处理策略："></a>大对象处理策略：</h4><p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代</p>
<h4 id="线程内存溢出："><a href="#线程内存溢出：" class="headerlink" title="线程内存溢出："></a>线程内存溢出：</h4><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。</p>
<h1 id="🌟垃圾回收器"><a href="#🌟垃圾回收器" class="headerlink" title="🌟垃圾回收器"></a>🌟垃圾回收器</h1><h2 id="三类垃圾回收器特点："><a href="#三类垃圾回收器特点：" class="headerlink" title="三类垃圾回收器特点："></a>三类垃圾回收器特点：</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648891339209-becdf46b-9a69-400d-a57d-54bb03b4ccec.png" alt="img"></p>
<h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p> 在谈论垃圾收集器的上下文语境中， 它们可以理解为：</p>
<h3 id="并行（Parallel）-："><a href="#并行（Parallel）-：" class="headerlink" title="并行（Parallel） ："></a>并行（Parallel） ：</h3><p>并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。</p>
<h3 id="并发（Concurrent）-："><a href="#并发（Concurrent）-：" class="headerlink" title="并发（Concurrent） ："></a>并发（Concurrent） ：</h3><p> 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行（不一定是并行的可能会交替执行）。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。 </p>
<h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><p>即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p>
<h2 id="1）串行"><a href="#1）串行" class="headerlink" title="1）串行"></a>1）串行</h2><p>单线程</p>
<p>适用于堆内存较小，如个人电脑（CPU核数较少也可以，因为单线程）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648902517820-ef16f7d9-6770-4e5a-a046-a0e24fb4d5c5.png" alt="img"></p>
<pre><code class="java">-XX:+UseSerialGC=serial + serialOld
</code></pre>
<h3 id="安全点："><a href="#安全点：" class="headerlink" title="安全点："></a>安全点：</h3><p>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p>
<h3 id="Serial-收集器："><a href="#Serial-收集器：" class="headerlink" title="Serial 收集器："></a>Serial 收集器：</h3><p>Serial 收集器是最基本的、发展历史最悠久的收集器</p>
<p>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p>
<h3 id="ParNew-收集器："><a href="#ParNew-收集器：" class="headerlink" title="ParNew 收集器："></a>ParNew 收集器：</h3><ul>
<li>ParNew 收集器其实就是 Serial 收集器的多线程版本</li>
<li>除了Serial收集器外， 目前只有它能与CMS收集器配合工作。 </li>
<li>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</li>
</ul>
<h3 id="Serial-Old-收集器："><a href="#Serial-Old-收集器：" class="headerlink" title="Serial Old 收集器："></a>Serial Old 收集器：</h3><p>Serial Old 是 Serial 收集器的老年代版本</p>
<p>特点：同样是单线程收集器，采用标记-整理算法</p>
<p>在服务端模式下，它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用 </p>
<h2 id="2）吞吐量优先"><a href="#2）吞吐量优先" class="headerlink" title="2）吞吐量优先"></a>2）吞吐量优先</h2><p><strong>parallel：并行的   Pause：停顿</strong></p>
<ul>
<li>多线程</li>
<li>适合堆内存较大，需要多核 cpu支持</li>
<li>让单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li>JDK1.8默认使用的垃圾回收器</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648905756956-5700f0dd-4a7a-4a73-b0b2-844407cd7d14.png" alt="img"></p>
<pre><code class="java">//第一个是新生代的垃圾回收器,复制算法；第二个是老年代的垃圾回收器，标记整理算法
//都是多线程的，只要开启一个，另外一个就会开启
//工作开启的回收线程数目，与cpu核数有关。回收时，cpu占有率100%
-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC  
-XX:+UseAdaptiveSizePolicy   //GC自适应调节策略
-XX:GCTimeRatio=ratio  //  1/(1+radio)
-XX:MaxGCPauseMillis=ms  //  200ms
-XX:ParallelGCThreads=n   //回收线程数 控制
</code></pre>
<h3 id="Parallel-Scavenge-收集器："><a href="#Parallel-Scavenge-收集器：" class="headerlink" title="Parallel Scavenge 收集器："></a>Parallel Scavenge 收集器：</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值 。</p>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p>特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）</p>
<h3 id="GC自适应调节策略："><a href="#GC自适应调节策略：" class="headerlink" title="GC自适应调节策略："></a>GC自适应调节策略：</h3><p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。</p>
<p>当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、</p>
<p>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p>
<h3 id="Parallel-Scavenge-收集器使用两个参数控制吞吐量："><a href="#Parallel-Scavenge-收集器使用两个参数控制吞吐量：" class="headerlink" title="Parallel Scavenge 收集器使用两个参数控制吞吐量："></a>Parallel Scavenge 收集器使用两个参数控制吞吐量：</h3><p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）：</p>
<p><strong>回收器一般会让堆变小，减少每次停顿的时间</strong></p>
<p>XX:GCTimeRatio&#x3D;radio 垃圾收集时间占总时间的比率，相当于吞吐量的倒数</p>
<p><strong>回收器一般会让堆变大，去减少垃圾回收次数，从而减少时间</strong></p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本</p>
<p>特点：多线程，采用标记-整理算法</p>
<h2 id="3）响应时间优先"><a href="#3）响应时间优先" class="headerlink" title="3）响应时间优先"></a>3）响应时间优先</h2><p>-<br>  CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 </p>
<ul>
<li>CMS作为老年代的收集器，新生代只能选择ParNew或者Serial收集器中的一个来配合工作。</li>
<li>多线程</li>
<li>适合堆内存较大，需要多核 cpu支持</li>
<li>面向并发设计的程序都对处理器资源比较敏感。 在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648890886592-6db2f622-b3fb-443a-b8fd-7e7f4a023df6.png" alt="img"></p>
<h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><pre><code class="java">//第一个CMS是并发标记清除算法，用户线程与垃圾回收线程并发进行，老年代浮动垃圾过多，退化为 SerialOld
//第二个是parnew新生代多线程回收器
-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld

//第一个是并行的垃圾回收线程数，一般跟cpu核数一样；第二个是并发的垃圾回收线程数,一般设置为并行线程数的四分之一
//比如：核数为4，那就占用一个cpu核进行垃圾回收。其他用于用户线程
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads

//同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。
//设置得太高将会很容易导致大量的并发失败产生，性能反而降低;
//设置太低将导致内存回收频率增加，性能降低
-XX:CMSInitiatingOccupancyFraction=percent

//重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力
-XX:+CMSScavengeBeforeRemark
</code></pre>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p>
<p>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p>
<p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p>
<h3 id="CMS-收集器的运行过程分为下列4步："><a href="#CMS-收集器的运行过程分为下列4步：" class="headerlink" title="CMS 收集器的运行过程分为下列4步："></a>CMS 收集器的运行过程分为下列4步：</h3><h4 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h4><p>标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</p>
<h4 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h4><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p>
<h4 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h4><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题，这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短。</p>
<h4 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h4><p>并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的 </p>
<h3 id="浮动垃圾："><a href="#浮动垃圾：" class="headerlink" title="浮动垃圾："></a>浮动垃圾：</h3><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。 </p>
<h3 id="并发失败："><a href="#并发失败：" class="headerlink" title="并发失败："></a>并发失败：</h3><h4 id="浮动垃圾过多："><a href="#浮动垃圾过多：" class="headerlink" title="浮动垃圾过多："></a>浮动垃圾过多：</h4><p>如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p>
<h4 id="内存碎片过多："><a href="#内存碎片过多：" class="headerlink" title="内存碎片过多："></a>内存碎片过多：</h4><p>CMS是一款基于“标记-清除”算法实现的收集器， 这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。 退化为SerialOld，进行标记整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。  </p>
<h2 id="4）G1-收集器"><a href="#4）G1-收集器" class="headerlink" title="4）G1 收集器"></a>4）G1 收集器</h2><h3 id="重要定义："><a href="#重要定义：" class="headerlink" title="重要定义："></a>重要定义：</h3><ul>
<li>Garbage First ，并发的垃圾回收器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。 </li>
<li>首先要有一个思想上的改变， 在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代（Minor GC） ， 要么就是整个老年代（Major GC） ， 再要么就是整个Java堆（Full GC） 。 而G1跳出了这个樊笼， 它可以面向堆内存任何部分来组成回收集（Collection Set， 一般简称CSet） 进行回收， 衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多， 回收收益最大， 这就是G1收集器的Mixed GC模式。  </li>
<li>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。 </li>
<li>收集器能够对扮演不同角色的Region采用不同的策略去处理 </li>
<li>Region中还有一类特殊的Humongous区域， 专门用来存储大对象。 G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中， G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li>
<li>G1仍然保留新生代和老年代的概念， 但新生代和老年代不再是固定的了， 它们都是一系列区域（不需要连续） 的动态集合。 G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作为单次回收的最小单元， 即每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。 </li>
<li>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。这种使用Region划分内存空间， 以及具有优先级的区域回收方式， 保证了G1收集器在有限的时间内获取尽可能高的收集效率。</li>
</ul>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ul>
<li>同时注重吞吐量和低延迟（响应时间），默认暂停目标是200ms</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的 区域（1，2，4，8兆；每个区域都可以独立的作为伊甸园、幸存区、老年代）</li>
<li>仍然有新生代老年代的概念但是他们不再固定了,他们变成一系列Reion的动态集合</li>
<li>整体上是标记-整理算法，两个区域之间是复制算法</li>
</ul>
<h4 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h4><p>JDK9默认的垃圾回收器，并且在9 废弃了CMS垃圾回收器。   JDK8 并不是默认开启的，所需要参数开启</p>
<pre><code class="java">-XX:+UseG1GC  //开关，JDK9默认开启
-XX:G1HeapRegionSize=size  //设置region大小 1 ， 2， 4， 8
-XX:MaxGCPauseMillis=time //默认暂停目标是200ms
</code></pre>
<h3 id="G1-垃圾回收阶段"><a href="#G1-垃圾回收阶段" class="headerlink" title="G1 垃圾回收阶段"></a>G1 垃圾回收阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948611265-89c91622-a8ec-4d35-a1d1-ac36d12133b0.png" alt="img"></p>
<p><strong>Young Collection：</strong>对新生代垃圾收集</p>
<p><strong>Young Collection + Concurrent Mark：</strong>如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</p>
<p><strong>Mixed Collection：</strong>会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h4 id="运行示意图："><a href="#运行示意图：" class="headerlink" title="运行示意图："></a>运行示意图：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648951849268-be1b104e-578b-40d6-b014-2e8033d95798.png" alt="img"></p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><ul>
<li>新生代进行GC存在 STW，但时间较短</li>
<li>会将存活的对象通过复制算法，复制到幸存区</li>
<li>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每个区域都可以独立的作为伊甸园、幸存区、老年代，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！</li>
</ul>
<p><strong>E：eden，S：幸存区，O：老年代</strong></p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948818440-2ea40959-173c-46c1-917e-7a6298282423.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948833159-c3a47bc4-00a8-43da-9615-1161cf4a6df1.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948852640-a71c1413-0cd4-4c9e-b00b-085899d60672.png" alt="img"></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><p>在 Young GC 时，即STW时，会进行 GC Root 的直接对象的初始化标记</p>
<p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定 </p>
<p>-XX:InitiatingHeapOccupancyPercent&#x3D;percent （默认45%）<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949003589-721183f6-bf2a-453a-86e1-a9d977d69b13.png" alt="img"></p>
<h4 id="Mixed-Collection："><a href="#Mixed-Collection：" class="headerlink" title="Mixed Collection："></a>Mixed Collection：</h4><ul>
<li><p>会对 E S O 进行全面的回收</p>
</li>
<li><p><strong>最终标记会(remark) STW    (错标、漏标)</strong></p>
</li>
<li><p><strong>拷贝存活会(evacuation) STW</strong></p>
</li>
<li><p>-XX:MaxGCPauseMills&#x3D;xxms 用于指定最长的停顿时间，分区的意义体现出来了！</p>
</li>
<li><p><strong>问：为什么有的老年代被拷贝了，有的没拷贝？</strong></p>
</li>
<li><p><strong>筛选回收</strong> 	</p>
</li>
<li><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949035948-f831e683-2ee0-445d-8ad5-fd44e4a95547.png" alt="img"></p>
<h3 id="Full-GC辨析："><a href="#Full-GC辨析：" class="headerlink" title="Full GC辨析："></a>Full GC辨析：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648952691083-9cca4e4a-cc30-4ee9-aab3-72a2068dc239.png" alt="img"></p>
<p>CMS和G1的fullGC发送情况类似：</p>
<ul>
<li>G1 在老年代内存不足时（老年代所占内存超过阈值），触发并发标记，重新标记，筛选回收</li>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理，虽然重新标记，筛选回收有STW，但比fullGC耗时少</li>
<li>如果垃圾产生速度快于垃圾回收速度，并发收集失败，然后退化成 serial Old 收集器串行的收集，触发 Full GC，就会导致停顿STW的时间长。</li>
</ul>
<h3 id="记忆表-Remembered-Set-："><a href="#记忆表-Remembered-Set-：" class="headerlink" title="记忆表(Remembered Set)："></a>记忆表(Remembered Set)：</h3><ul>
<li>进行minor GC 时不应为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干内存块， 标识出老年代的哪一块内存会存在跨代引用。</li>
<li>此后当发生Minor GC时， 只有包含了跨代引用的内存块里的对象才会被加入到GCRoots进行扫描。 虽然这种方法需要在对象改变引用关系（ 如将自己或者某个属性赋值） 时维护记录数据的正确性， 会增加一些运行时的开销， 但比起收集时扫描整个老年代来说仍然是划算的。</li>
</ul>
<h3 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h3><ul>
<li>“卡精度”所指的是用一种称为“卡表”（Card Table） 的方式去实现记忆集。前面定义中提到记忆集其实是一种“抽象”的数据结构， 抽象的意思是只定义了记忆集的行为意图， 并没有定义其行为的具体实现。 卡表就是记忆集的一种具体实现， 它定义了记忆集的记录精度、 与堆内存的映射关系等 。</li>
<li>卡表最简单的形式可以只是一个字节数组，数组中每一个元素都对应着其标识的内存区域中一块特定大小的内存块， 这个内存块被称作“卡页”（Card Page） 。 一般来说， 卡页大小都是以2的N次幂的字节数， 通过上面代码可以看出HotSpot中使用的卡页是2的9次幂， 即512字节 。</li>
<li>一个卡页的内存中通常包含不止一个对象， 只要卡页内有一个（或更多） 对象的字段存在着跨代指针， 那就将对应卡表的数组元素的值标识为1， 称为这个元素变脏（Dirty） ， 没有则标识为0。 在垃圾收集发生时， 只要筛选出卡表中变脏的元素， 就能轻易得出哪些卡页内存块中包含跨代指针， 把它们加入GC Roots中一并扫描。</li>
</ul>
<h3 id="写屏障（Write-Barrier）"><a href="#写屏障（Write-Barrier）" class="headerlink" title="写屏障（Write Barrier）"></a>写屏障（Write Barrier）</h3><p>写屏障（Write Barrier）技术维护卡表状态。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面， 在引用对象赋值时会产生一个环形（Around） 通知， 供程序执行额外的动作， 也就是说赋值的<br>前后都在写屏障的覆盖范畴内。 </p>
<h3 id="Young-Collection垃圾回收的跨代引用问题："><a href="#Young-Collection垃圾回收的跨代引用问题：" class="headerlink" title="Young Collection垃圾回收的跨代引用问题："></a>Young Collection垃圾回收的跨代引用问题：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949069957-d64d4a0e-81c8-42d1-b29c-0a1615dc60fe.png" alt="img"></p>
<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡</li>
<li>脏卡：O 被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
<li>将来不用找整个老年代根对象，只需要关注脏卡区域，提高效率</li>
<li>在引用对象赋值时通过写屏障更新卡表  post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949095307-3aef0ce2-f43f-4205-872f-a30b0a67b1af.png" alt="img"></p>
<h3 id="Remark重新标记阶段-详解："><a href="#Remark重新标记阶段-详解：" class="headerlink" title="Remark重新标记阶段 详解："></a>Remark重新标记阶段 详解：</h3><p>在垃圾回收并发标记阶段，收集器处理对象的过程中 ，对象的状态：</p>
<ul>
<li>黑色：已被处理，需要保留的</li>
<li>灰色：正在处理中的</li>
<li>白色：还未处理的<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949120624-b90b62c7-57fa-44b0-926f-15b198e358b9.png" alt="img"></li>
<li>但是在并发标记过程中，有可能 A 被处理了以后未引用 C ，但该处理过程还未结束；</li>
<li>在处理过程结束之前用户线程使 A 引用了 C ，即对象的引用发送改变时，这时就会用到 remark</li>
</ul>
<h4 id="过程如下："><a href="#过程如下：" class="headerlink" title="过程如下："></a>过程如下：</h4><ul>
<li>之前 C 未被引用，这时 A 引用了 C ，就会给 C 加一个写屏障，写屏障的指令会被执行，将 C 放入一个队列当中，并将 C 变为 处理中 状态</li>
<li>在并发标记阶段结束以后，重新标记 阶段会 STW ，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它，由灰色变成黑色。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949161437-46c610b5-08af-4d28-896d-48e43f003dfd.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949181853-a6339cd4-1a3d-4b8e-b097-d47dfad37daf.png" alt="img"></p>
<h2 id="G1垃圾回收器优化："><a href="#G1垃圾回收器优化：" class="headerlink" title="G1垃圾回收器优化："></a>G1垃圾回收器优化：</h2><p>程序进行中的优化 ，只介绍JDK8-JDK9</p>
<h3 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h3><p>String对象不是一样，返回false。因为他们是两个字符串对象，只是他们的底层value属性指向的char[]都引用到同一个char[]了 ，去看一下String源码会明白点。</p>
<ul>
<li>将所有新分配的字符串（底层是 char[] ）放入一个队列</li>
<li>当新生代回收时，G1 并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们引用同一个字符串对象</li>
</ul>
<h4 id="其与-String-intern-的区别"><a href="#其与-String-intern-的区别" class="headerlink" title="其与 String.intern() 的区别"></a>其与 String.intern() 的区别</h4><ul>
<li>String.intern() 关注的是字符串对象</li>
<li>字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串标</li>
</ul>
<h4 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h4><ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用 CPU</li>
</ul>
<pre><code class="java">-XX:+UseStringDeduplication  //字符串去重，默认开启
</code></pre>
<h3 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>对于自定义类加载器，如果这个加载器下面的所有类以及它们的实例不被使用，那么这个类加载器下面的所有类就会被卸载。</p>
<h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ul>
<li>所有对象都经过并发标记阶段以后，就能知道哪些类不再被使用，这时尝试执行类卸载的操作。</li>
<li>卸载条件：首先这个类的实例都被回收掉了，这个类所在的 类加载器的 所有类都不在使用，则卸载它所加载的所有类。虽然条件比较苛刻，但是对于一些框架程序，很多都是使用自定义的类加载器，当没用的时候，就可以卸载此类加载器下的所有类。</li>
</ul>
<h3 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h3><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝，因为大，耗时间</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648972282994-e7dfbb09-b52e-466a-8b80-a7c92c6f5623.png" alt="img"></p>
<h3 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h3><ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FulGC</li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li>
<li>JDK 9 之后可以动态调整</li>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li>
<li>之后会进行数据采样并动态调整，总会添加一个安全的空挡空间来容纳并发过程中用户线程产生的垃圾</li>
</ul>
<h1 id="🌟垃圾回收调优"><a href="#🌟垃圾回收调优" class="headerlink" title="🌟垃圾回收调优"></a>🌟垃圾回收调优</h1><h2 id="查看虚拟机参数命令"><a href="#查看虚拟机参数命令" class="headerlink" title="查看虚拟机参数命令"></a>查看虚拟机参数命令</h2><pre><code class="java">//查看虚拟机运行参数
D:\Java\jdk1.8  -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;
</code></pre>
<p>可以根据参数去查询具体的信息，有助于调优</p>
<h2 id="1）调优领域"><a href="#1）调优领域" class="headerlink" title="1）调优领域"></a>1）调优领域</h2><ul>
<li>内存</li>
<li>线程锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
<li>GC</li>
</ul>
<h2 id="2）确定目标"><a href="#2）确定目标" class="headerlink" title="2）确定目标"></a>2）确定目标</h2><p><strong>低延迟 &#x2F; 高吞吐量？</strong> 选择合适的GC回收器</p>
<ul>
<li>hotspot虚拟机中的垃圾回收器：CMS G1 ZGC      <strong>低延迟</strong></li>
<li>hotspot虚拟机中的垃圾回收器：ParallelGC          <strong>高吞吐量</strong></li>
<li>其他虚拟机：Zing                                                  <strong>低延迟</strong></li>
</ul>
<h2 id="3）最快的-GC"><a href="#3）最快的-GC" class="headerlink" title="3）最快的 GC"></a>3）最快的 GC</h2><h3 id="排除因为自身编写的代码"><a href="#排除因为自身编写的代码" class="headerlink" title="排除因为自身编写的代码"></a>排除因为自身编写的代码</h3><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<p>查看 Full GC 前后的内存占用，考虑以下几个问题：</p>
<h3 id="数据是不是太多？"><a href="#数据是不是太多？" class="headerlink" title="数据是不是太多？"></a>数据是不是太多？</h3><p>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</p>
<h3 id="数据表示是否太臃肿"><a href="#数据表示是否太臃肿" class="headerlink" title="数据表示是否太臃肿"></a>数据表示是否太臃肿</h3><ul>
<li>对象图   是不是查询不必要的字段了</li>
<li>对象大小   一个object最少占16字节； Integer大约占24字节，int占4字节。减小数据本身的占用量</li>
</ul>
<h3 id="是否存在内存泄漏"><a href="#是否存在内存泄漏" class="headerlink" title="是否存在内存泄漏"></a>是否存在内存泄漏</h3><ul>
<li>长时间引用的对象，频繁往里面放东西，如：static Map map &#x3D;   一直不移出</li>
<li>长时间存活的对象，建议使用软弱引用：</li>
</ul>
<p>软</p>
<p>弱</p>
<ul>
<li>第三方缓存实现：redis</li>
</ul>
<h2 id="4）从新生代调优开始"><a href="#4）从新生代调优开始" class="headerlink" title="4）从新生代调优开始"></a>4）从新生代调优开始</h2><h3 id="新生代的特点："><a href="#新生代的特点：" class="headerlink" title="新生代的特点："></a>新生代的特点：</h3><h4 id="所有的-new-操作分配内存都是非常快、廉价的"><a href="#所有的-new-操作分配内存都是非常快、廉价的" class="headerlink" title="所有的 new 操作分配内存都是非常快、廉价的"></a>所有的 new 操作分配内存都是非常快、廉价的</h4><ul>
<li>每个线程都会在伊甸园中分配一块私有的内存空间TLAB，new一个对象首先会检查该线程TLAB缓冲区有没有更多内存，有就在这块区域进行对象分配。因为对象分配也有线程安全问题，线程的内存不能冲突</li>
<li>TLAB thread-lcoal allocation buffer</li>
</ul>
<h4 id="死亡对象回收零代价"><a href="#死亡对象回收零代价" class="headerlink" title="死亡对象回收零代价"></a>死亡对象回收零代价</h4><ul>
<li>因为新生代垃圾回收是复制算法，把存活的对象复制到幸存区to，然后伊甸园区、from区的内存就释放掉了</li>
</ul>
<h4 id="大部分对象用过即死（朝生夕死）"><a href="#大部分对象用过即死（朝生夕死）" class="headerlink" title="大部分对象用过即死（朝生夕死）"></a>大部分对象用过即死（朝生夕死）</h4><h4 id="Minor-GC-所用时间远小于-Full-GC"><a href="#Minor-GC-所用时间远小于-Full-GC" class="headerlink" title="Minor GC 所用时间远小于 Full GC"></a>Minor GC 所用时间远小于 Full GC</h4><ul>
<li>存活对象少，并且采用复制算法，使用minorGC耗时很少</li>
</ul>
<h3 id="新生代内存越大越好么？"><a href="#新生代内存越大越好么？" class="headerlink" title="新生代内存越大越好么？"></a>新生代内存越大越好么？</h3><ul>
<li>不是</li>
<li>新生代内存太小：频繁触发 Minor GC ，会 STW ，使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC,，耗时更长。而且当触发 Minor GC 时，清理新生代所花费的时间会更长，因为新生代内存大。</li>
<li>总的原则，还是将新生代区域调的尽可能大，耗费时间多的是在复制算法中的复制过程，而不是标记过程，因为复制需要将对象内存移动，更新引用对象地址。大部分对象都是朝生夕死，所以复制时间也是占用很少</li>
</ul>
<h4 id="新生代内存设置"><a href="#新生代内存设置" class="headerlink" title="新生代内存设置"></a>新生代内存设置</h4><p>新生代所能容纳  <strong>[并发量*(请求-响应)]</strong>  的数据为宜</p>
<h4 id="幸存区内存设置"><a href="#幸存区内存设置" class="headerlink" title="幸存区内存设置"></a>幸存区内存设置</h4><p>幸存区需要能够保存 <strong>当前活跃对象+需要晋升的对象</strong></p>
<p>如果幸存区内存太小，当内存不足时，晋升阈值变小，会导致什么后果呢？</p>
<ul>
<li>会导致一些存活时间短的对象，晋升到老年代，只有等到老年代内存不足时，才会触发Full GC被回收。</li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升到老年代，不要占用幸存区的内存</li>
</ul>
<h4 id="晋升阈值参数"><a href="#晋升阈值参数" class="headerlink" title="晋升阈值参数"></a>晋升阈值参数</h4><pre><code class="java">-XX:MaxTenuringThreshold=threshold
-XX:+PrintTenuringDistrubution
</code></pre>
<h2 id="5）老年代调优"><a href="#5）老年代调优" class="headerlink" title="5）老年代调优"></a>5）老年代调优</h2><h3 id="以-CMS-为例："><a href="#以-CMS-为例：" class="headerlink" title="以 CMS 为例："></a>以 CMS 为例：</h3><ul>
<li>CMS 的老年代内存越大越好，低响应、并发的垃圾回收线程，用户线程也在运行，会产生浮动垃圾，导致内存不足，就会并发失败，退化为serial old ，STW变长</li>
<li>先尝试不做老年代调优，如果没有 Full GC 那么已经OK；即使发生Full GC，也先尝试调优新生代。</li>
<li>如果新生代调优后，还是经常Full GC，观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li>
</ul>
<h4 id="老年代占用多少进行垃圾回收"><a href="#老年代占用多少进行垃圾回收" class="headerlink" title="老年代占用多少进行垃圾回收"></a>老年代占用多少进行垃圾回收</h4><pre><code class="java">//75% ~ 80%
-XX:CMSInitiatingOccupancyFraction=percent
</code></pre>
<h2 id="6）内存调优案例"><a href="#6）内存调优案例" class="headerlink" title="6）内存调优案例"></a>6）内存调优案例</h2><h3 id="案例1：Full-GC-和-Minor-GC都频繁"><a href="#案例1：Full-GC-和-Minor-GC都频繁" class="headerlink" title="案例1：Full GC 和 Minor GC都频繁"></a>案例1：Full GC 和 Minor GC都频繁</h3><p>增大新生代的内存导致minor gc更少触发，并且survivor区增大，就不会让本不是生命周期那么长的对象进入老年区，从而给老年区节省空间，进一步就减少了老年区触发full GC</p>
<h3 id="案例2：请求高峰期发生-Full-GC，单次暂停时间特别长（CMS）"><a href="#案例2：请求高峰期发生-Full-GC，单次暂停时间特别长（CMS）" class="headerlink" title="案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）"></a>案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</h3><ul>
<li>重新标记耗时多，因为重新标记需要扫描整个堆内存，如果业务高峰，新生代个数多，那么扫描需要花费的时间也多。</li>
<li>重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力</li>
<li>-XX:+CMSScavengeBeforeRemark</li>
</ul>
<h3 id="案例3：老年代充裕情况下，发生-Full-GC（jdk1-7）"><a href="#案例3：老年代充裕情况下，发生-Full-GC（jdk1-7）" class="headerlink" title="案例3：老年代充裕情况下，发生 Full GC（jdk1.7）"></a>案例3：老年代充裕情况下，发生 Full GC（jdk1.7）</h3><ul>
<li>空间充裕，说明不是并发失败：如内存碎片过多、浮动垃圾过多</li>
<li>此处应该是JDK1.7版本，由于永久代的空间不足导致full gc；JDK1.8之后JVM实现为元空间，用的是操作系统内存，内存大很多，并且有相应的内存垃圾回收管理，所以在JDK1.8此类情况少见</li>
</ul>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Lorain</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/posts/72f47432.html">https://blog.lorainjay.icu/posts/72f47432.html</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://blog.lorainjay.icu">Lorain的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/JVM/">JVM</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%9F%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">🌟分代垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E8%87%B4%E5%88%86%E4%B8%BA%E4%B8%A4%E5%9D%97%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">堆内存大致分为两块：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">分代垃圾回收怎么工作：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%9B%B8%E5%85%B3-JVM-%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）相关 JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89GC-%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）GC 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%9A%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">程序刚加载时的堆内存情况：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">代码分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">大对象处理策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9A"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">线程内存溢出：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">🌟垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">三类垃圾回收器特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">相关概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89-%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">并行（Parallel） ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89-%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">并发（Concurrent） ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">吞吐量：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E4%B8%B2%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">1）串行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">安全点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">Serial 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">ParNew 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.3.4.</span> <span class="toc-text">Serial Old 收集器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">2.4.</span> <span class="toc-text">2）吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">Parallel Scavenge 收集器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E8%8A%82%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">2.4.2.</span> <span class="toc-text">GC自适应调节策略：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%8E%A7%E5%88%B6%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9A"><span class="toc-number">2.4.3.</span> <span class="toc-text">Parallel Scavenge 收集器使用两个参数控制吞吐量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">Parallel Old 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">2.5.</span> <span class="toc-text">3）响应时间优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">2.5.1.</span> <span class="toc-text">参数设置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E4%B8%BA%E4%B8%8B%E5%88%974%E6%AD%A5%EF%BC%9A"><span class="toc-number">2.5.3.</span> <span class="toc-text">CMS 收集器的运行过程分为下列4步：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">初始标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">并发标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%9A"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">重新标记：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4%EF%BC%9A"><span class="toc-number">2.5.3.4.</span> <span class="toc-text">并发清除：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%EF%BC%9A"><span class="toc-number">2.5.4.</span> <span class="toc-text">浮动垃圾：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%B1%E8%B4%A5%EF%BC%9A"><span class="toc-number">2.5.5.</span> <span class="toc-text">并发失败：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%E8%BF%87%E5%A4%9A%EF%BC%9A"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">浮动垃圾过多：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E8%BF%87%E5%A4%9A%EF%BC%9A"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">内存碎片过多：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">4）G1 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.6.1.</span> <span class="toc-text">重要定义：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">适用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">相关参数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">2.6.2.</span> <span class="toc-text">G1 垃圾回收阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%9A"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">运行示意图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.6.2.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">2.6.2.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-number">2.6.2.5.</span> <span class="toc-text">Young Collection + CM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection%EF%BC%9A"><span class="toc-number">2.6.2.6.</span> <span class="toc-text">Mixed Collection：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC%E8%BE%A8%E6%9E%90%EF%BC%9A"><span class="toc-number">2.6.3.</span> <span class="toc-text">Full GC辨析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E8%A1%A8-Remembered-Set-%EF%BC%9A"><span class="toc-number">2.6.4.</span> <span class="toc-text">记忆表(Remembered Set)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8%EF%BC%88Card-Table%EF%BC%89"><span class="toc-number">2.6.5.</span> <span class="toc-text">卡表（Card Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C%EF%BC%88Write-Barrier%EF%BC%89"><span class="toc-number">2.6.6.</span> <span class="toc-text">写屏障（Write Barrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Young-Collection%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.6.7.</span> <span class="toc-text">Young Collection垃圾回收的跨代引用问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remark%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5-%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.6.8.</span> <span class="toc-text">Remark重新标记阶段 详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">过程如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">2.7.</span> <span class="toc-text">G1垃圾回收器优化：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8u20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">JDK 8u20 字符串去重</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%B8%8E-String-intern-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">其与 String.intern() 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">优点与缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8u40-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.7.2.</span> <span class="toc-text">JDK 8u40 并发标记类卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">流程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8u60-%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">JDK 8u60 回收巨型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-9-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">2.7.4.</span> <span class="toc-text">JDK 9 并发标记起始时间的调整</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">3.</span> <span class="toc-text">🌟垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">查看虚拟机参数命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E8%B0%83%E4%BC%98%E9%A2%86%E5%9F%9F"><span class="toc-number">3.2.</span> <span class="toc-text">1）调优领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">3.3.</span> <span class="toc-text">2）确定目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E6%9C%80%E5%BF%AB%E7%9A%84-GC"><span class="toc-number">3.4.</span> <span class="toc-text">3）最快的 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E5%9B%A0%E4%B8%BA%E8%87%AA%E8%BA%AB%E7%BC%96%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">排除因为自身编写的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E5%A4%9A%EF%BC%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">数据是不是太多？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E5%A4%AA%E8%87%83%E8%82%BF"><span class="toc-number">3.4.3.</span> <span class="toc-text">数据表示是否太臃肿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.4.4.</span> <span class="toc-text">是否存在内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89%E4%BB%8E%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98%E5%BC%80%E5%A7%8B"><span class="toc-number">3.5.</span> <span class="toc-text">4）从新生代调优开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.5.1.</span> <span class="toc-text">新生代的特点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%9A%84-new-%E6%93%8D%E4%BD%9C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%83%BD%E6%98%AF%E9%9D%9E%E5%B8%B8%E5%BF%AB%E3%80%81%E5%BB%89%E4%BB%B7%E7%9A%84"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">所有的 new 操作分配内存都是非常快、廉价的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E9%9B%B6%E4%BB%A3%E4%BB%B7"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">死亡对象回收零代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E7%94%A8%E8%BF%87%E5%8D%B3%E6%AD%BB%EF%BC%88%E6%9C%9D%E7%94%9F%E5%A4%95%E6%AD%BB%EF%BC%89"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">大部分对象用过即死（朝生夕死）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Minor-GC-%E6%89%80%E7%94%A8%E6%97%B6%E9%97%B4%E8%BF%9C%E5%B0%8F%E4%BA%8E-Full-GC"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">Minor GC 所用时间远小于 Full GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.2.</span> <span class="toc-text">新生代内存越大越好么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">新生代内存设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B8%E5%AD%98%E5%8C%BA%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">幸存区内存设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%8B%E5%8D%87%E9%98%88%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">晋升阈值参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.6.</span> <span class="toc-text">5）老年代调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5-CMS-%E4%B8%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.6.1.</span> <span class="toc-text">以 CMS 为例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">老年代占用多少进行垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B"><span class="toc-number">3.7.</span> <span class="toc-text">6）内存调优案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9AFull-GC-%E5%92%8C-Minor-GC%E9%83%BD%E9%A2%91%E7%B9%81"><span class="toc-number">3.7.1.</span> <span class="toc-text">案例1：Full GC 和 Minor GC都频繁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E8%AF%B7%E6%B1%82%E9%AB%98%E5%B3%B0%E6%9C%9F%E5%8F%91%E7%94%9F-Full-GC%EF%BC%8C%E5%8D%95%E6%AC%A1%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%E7%89%B9%E5%88%AB%E9%95%BF%EF%BC%88CMS%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3%EF%BC%9A%E8%80%81%E5%B9%B4%E4%BB%A3%E5%85%85%E8%A3%95%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%8F%91%E7%94%9F-Full-GC%EF%BC%88jdk1-7%EF%BC%89"><span class="toc-number">3.7.3.</span> <span class="toc-text">案例3：老年代充裕情况下，发生 Full GC（jdk1.7）</span></a></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/posts/852cfab6.html">进程管理 &gt;</a></div></section><footer><p>Copyright © 2016 - 2024 <a href="/." rel="nofollow">Lorain's Blog</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>