<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>垃圾回收</title>
      <link href="/posts/72f47432.html"/>
      <url>/posts/72f47432.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>🌕垃圾回收对于 Java 党来说，是一个绕不开的话题，工作中涉及到的调优工作也经常围绕着垃圾回收器展开。面对不同的业务场景，往往需要不同的垃圾收集器才能保证 GC 性能，因此，对于面大厂或者有远大志向的球友可以卷一下垃圾收集器。</p></blockquote><h1 id="🌟分代垃圾回收机制"><a href="#🌟分代垃圾回收机制" class="headerlink" title="🌟分代垃圾回收机制"></a>🌟分代垃圾回收机制</h1><h2 id="堆内存大致分为两块："><a href="#堆内存大致分为两块：" class="headerlink" title="堆内存大致分为两块："></a>堆内存大致分为两块：</h2><p>新生代、老年代；新生代又划分为伊甸园、幸存区from、幸存区to。</p><p>长时间使用的对象放在老年代中，用完了就丢弃的对象放在新生代中。根据对象生命周期的不同特点，采用不同的垃圾回收算法，老年代发生次数少，新生代比较频繁。不同区域采用不同算法，更有效的对垃圾回收进行管理</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881007627-58238735-ea09-46ba-8a18-eb949359a3d5.png" alt="img"></p><h2 id="分代垃圾回收怎么工作："><a href="#分代垃圾回收怎么工作：" class="headerlink" title="分代垃圾回收怎么工作："></a>分代垃圾回收怎么工作：</h2><p>java虚拟机本身就是一个小的操作系统吧？</p><ul><li>新创建的对象首先分配在 伊甸园区；</li><li>伊甸园 区空间不足时，触发 minor gc ，使用<strong>可达性分析</strong>算法沿着GC root引用链去找，进行标记的动作；</li><li>采用复制算法将 伊甸园 区 和幸存区from 区存活的对象复制到幸存区to 中，存活的对象年龄加一，然后交换 from to（这里很细节，实际变的不是两块物理地址，而是指针引用）；</li><li>minor gc 会引发 stop the world，因为垃圾回收的时候对象地址发生改变，如果其他线程也在运行，会造成混乱。暂停其他线程，等垃圾回收结束后，恢复用户线程运行；</li><li>新生代触发的STW的时间较短  </li><li>每次minorGC后，eden和from对象都清除干净了</li><li>每次都把不需要回收和幸存区from留下的移到To中，然后交换From和To的位置</li><li>当幸存区to对象的寿命超过阈值时，会晋升到老年代，最大寿命是15（4bit）</li><li>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li><li>如果老年代空间不足时，会先尝试触发 minor gc，如果空间仍然不足，那么就触发 full fc ，STW停止的时间更长！</li><li>from和to每次都要留一个空的，空间不足就触发gc，还不足就会触发提前晋升老年代，老年代如果放不下先触发full gc 然后再尝试提前晋升，还不行就Java heap space outofmemoryerror异常</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881771672-021f9d70-7ed1-45bb-a8b4-669bee5ffa8f.png" alt="img"></p><h3 id="1）相关-JVM-参数"><a href="#1）相关-JVM-参数" class="headerlink" title="1）相关 JVM 参数"></a>1）相关 JVM 参数</h3><p><strong>含义</strong>                                       <strong>参数</strong></p><p>堆初始大小                      -Xms</p><p>堆最大大小                      -Xmx 或 -XX:MaxHeapSize&#x3D;size</p><p>新生代大小                      -Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</p><p>幸存区比例（动态）       -XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</p><p>幸存区比例                      -XX:SurvivorRatio&#x3D;ratio</p><p>晋升阈值                              -XX:MaxTenuringThreshold&#x3D;threshold</p><p>晋升详情                              -XX:+PrintTenuringDistribution</p><p>GC详情                             -XX:+PrintGCDetails -verbose:gc</p><p>FullGC 前 MinorGC              -XX:+ScavengeBeforeFullGC</p><h3 id="2）GC-分析"><a href="#2）GC-分析" class="headerlink" title="2）GC 分析"></a>2）GC 分析</h3><h4 id="程序刚加载时的堆内存情况："><a href="#程序刚加载时的堆内存情况：" class="headerlink" title="程序刚加载时的堆内存情况："></a>程序刚加载时的堆内存情况：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648887378100-37e3a00f-3c41-43d5-8c39-92f11622161a.png" alt="img"></p><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><p>通过如下代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，什么时候 幸存区放不下，直接晋升老年代，使用前需要设置 jvm 参数。</p><pre><code class="java">public class Code_10_GCTest &#123;    private static final int _512KB = 512 * 1024;    private static final int _1MB = 1024 * 1024;    private static final int _6MB = 6 * 1024 * 1024;    private static final int _7MB = 7 * 1024 * 1024;    private static final int _8MB = 8 * 1024 * 1024;    // -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc    public static void main(String[] args) &#123;        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();        list.add(new byte[_6MB]);        list.add(new byte[_512KB]);        list.add(new byte[_6MB]);        list.add(new byte[_512KB]);        list.add(new byte[_6MB]);    &#125;&#125;</code></pre><h4 id="大对象处理策略："><a href="#大对象处理策略：" class="headerlink" title="大对象处理策略："></a>大对象处理策略：</h4><p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代</p><h4 id="线程内存溢出："><a href="#线程内存溢出：" class="headerlink" title="线程内存溢出："></a>线程内存溢出：</h4><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。</p><h1 id="🌟垃圾回收器"><a href="#🌟垃圾回收器" class="headerlink" title="🌟垃圾回收器"></a>🌟垃圾回收器</h1><h2 id="三类垃圾回收器特点："><a href="#三类垃圾回收器特点：" class="headerlink" title="三类垃圾回收器特点："></a>三类垃圾回收器特点：</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648891339209-becdf46b-9a69-400d-a57d-54bb03b4ccec.png" alt="img"></p><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p> 在谈论垃圾收集器的上下文语境中， 它们可以理解为：</p><h3 id="并行（Parallel）-："><a href="#并行（Parallel）-：" class="headerlink" title="并行（Parallel） ："></a>并行（Parallel） ：</h3><p>并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。</p><h3 id="并发（Concurrent）-："><a href="#并发（Concurrent）-：" class="headerlink" title="并发（Concurrent） ："></a>并发（Concurrent） ：</h3><p> 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行（不一定是并行的可能会交替执行）。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。 </p><h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><p>即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p><h2 id="1）串行"><a href="#1）串行" class="headerlink" title="1）串行"></a>1）串行</h2><p>单线程</p><p>适用于堆内存较小，如个人电脑（CPU核数较少也可以，因为单线程）</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648902517820-ef16f7d9-6770-4e5a-a046-a0e24fb4d5c5.png" alt="img"></p><pre><code class="java">-XX:+UseSerialGC=serial + serialOld</code></pre><h3 id="安全点："><a href="#安全点：" class="headerlink" title="安全点："></a>安全点：</h3><p>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p><h3 id="Serial-收集器："><a href="#Serial-收集器：" class="headerlink" title="Serial 收集器："></a>Serial 收集器：</h3><p>Serial 收集器是最基本的、发展历史最悠久的收集器</p><p>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p><h3 id="ParNew-收集器："><a href="#ParNew-收集器：" class="headerlink" title="ParNew 收集器："></a>ParNew 收集器：</h3><ul><li>ParNew 收集器其实就是 Serial 收集器的多线程版本</li><li>除了Serial收集器外， 目前只有它能与CMS收集器配合工作。 </li><li>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</li></ul><h3 id="Serial-Old-收集器："><a href="#Serial-Old-收集器：" class="headerlink" title="Serial Old 收集器："></a>Serial Old 收集器：</h3><p>Serial Old 是 Serial 收集器的老年代版本</p><p>特点：同样是单线程收集器，采用标记-整理算法</p><p>在服务端模式下，它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用 </p><h2 id="2）吞吐量优先"><a href="#2）吞吐量优先" class="headerlink" title="2）吞吐量优先"></a>2）吞吐量优先</h2><p><strong>parallel：并行的   Pause：停顿</strong></p><ul><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>让单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li>JDK1.8默认使用的垃圾回收器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648905756956-5700f0dd-4a7a-4a73-b0b2-844407cd7d14.png" alt="img"></p><pre><code class="java">//第一个是新生代的垃圾回收器,复制算法；第二个是老年代的垃圾回收器，标记整理算法//都是多线程的，只要开启一个，另外一个就会开启//工作开启的回收线程数目，与cpu核数有关。回收时，cpu占有率100%-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC  -XX:+UseAdaptiveSizePolicy   //GC自适应调节策略-XX:GCTimeRatio=ratio  //  1/(1+radio)-XX:MaxGCPauseMillis=ms  //  200ms-XX:ParallelGCThreads=n   //回收线程数 控制</code></pre><h3 id="Parallel-Scavenge-收集器："><a href="#Parallel-Scavenge-收集器：" class="headerlink" title="Parallel Scavenge 收集器："></a>Parallel Scavenge 收集器：</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值 。</p><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p>特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）</p><h3 id="GC自适应调节策略："><a href="#GC自适应调节策略：" class="headerlink" title="GC自适应调节策略："></a>GC自适应调节策略：</h3><p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。</p><p>当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、</p><p>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p><h3 id="Parallel-Scavenge-收集器使用两个参数控制吞吐量："><a href="#Parallel-Scavenge-收集器使用两个参数控制吞吐量：" class="headerlink" title="Parallel Scavenge 收集器使用两个参数控制吞吐量："></a>Parallel Scavenge 收集器使用两个参数控制吞吐量：</h3><p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）：</p><p><strong>回收器一般会让堆变小，减少每次停顿的时间</strong></p><p>XX:GCTimeRatio&#x3D;radio 垃圾收集时间占总时间的比率，相当于吞吐量的倒数</p><p><strong>回收器一般会让堆变大，去减少垃圾回收次数，从而减少时间</strong></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本</p><p>特点：多线程，采用标记-整理算法</p><h2 id="3）响应时间优先"><a href="#3）响应时间优先" class="headerlink" title="3）响应时间优先"></a>3）响应时间优先</h2><p>-<br>  CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 </p><ul><li>CMS作为老年代的收集器，新生代只能选择ParNew或者Serial收集器中的一个来配合工作。</li><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>面向并发设计的程序都对处理器资源比较敏感。 在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648890886592-6db2f622-b3fb-443a-b8fd-7e7f4a023df6.png" alt="img"></p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><pre><code class="java">//第一个CMS是并发标记清除算法，用户线程与垃圾回收线程并发进行，老年代浮动垃圾过多，退化为 SerialOld//第二个是parnew新生代多线程回收器-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld//第一个是并行的垃圾回收线程数，一般跟cpu核数一样；第二个是并发的垃圾回收线程数,一般设置为并行线程数的四分之一//比如：核数为4，那就占用一个cpu核进行垃圾回收。其他用于用户线程-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads//同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。//设置得太高将会很容易导致大量的并发失败产生，性能反而降低;//设置太低将导致内存回收频率增加，性能降低-XX:CMSInitiatingOccupancyFraction=percent//重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力-XX:+CMSScavengeBeforeRemark</code></pre><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p><p>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p><p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p><h3 id="CMS-收集器的运行过程分为下列4步："><a href="#CMS-收集器的运行过程分为下列4步：" class="headerlink" title="CMS 收集器的运行过程分为下列4步："></a>CMS 收集器的运行过程分为下列4步：</h3><h4 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h4><p>标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</p><h4 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h4><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p><h4 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h4><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题，这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短。</p><h4 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h4><p>并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的 </p><h3 id="浮动垃圾："><a href="#浮动垃圾：" class="headerlink" title="浮动垃圾："></a>浮动垃圾：</h3><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。 </p><h3 id="并发失败："><a href="#并发失败：" class="headerlink" title="并发失败："></a>并发失败：</h3><h4 id="浮动垃圾过多："><a href="#浮动垃圾过多：" class="headerlink" title="浮动垃圾过多："></a>浮动垃圾过多：</h4><p>如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><h4 id="内存碎片过多："><a href="#内存碎片过多：" class="headerlink" title="内存碎片过多："></a>内存碎片过多：</h4><p>CMS是一款基于“标记-清除”算法实现的收集器， 这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。 退化为SerialOld，进行标记整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。  </p><h2 id="4）G1-收集器"><a href="#4）G1-收集器" class="headerlink" title="4）G1 收集器"></a>4）G1 收集器</h2><h3 id="重要定义："><a href="#重要定义：" class="headerlink" title="重要定义："></a>重要定义：</h3><ul><li>Garbage First ，并发的垃圾回收器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。 </li><li>首先要有一个思想上的改变， 在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代（Minor GC） ， 要么就是整个老年代（Major GC） ， 再要么就是整个Java堆（Full GC） 。 而G1跳出了这个樊笼， 它可以面向堆内存任何部分来组成回收集（Collection Set， 一般简称CSet） 进行回收， 衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多， 回收收益最大， 这就是G1收集器的Mixed GC模式。  </li><li>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。 </li><li>收集器能够对扮演不同角色的Region采用不同的策略去处理 </li><li>Region中还有一类特殊的Humongous区域， 专门用来存储大对象。 G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中， G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li><li>G1仍然保留新生代和老年代的概念， 但新生代和老年代不再是固定的了， 它们都是一系列区域（不需要连续） 的动态集合。 G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作为单次回收的最小单元， 即每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。 </li><li>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。这种使用Region划分内存空间， 以及具有优先级的区域回收方式， 保证了G1收集器在有限的时间内获取尽可能高的收集效率。</li></ul><h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ul><li>同时注重吞吐量和低延迟（响应时间），默认暂停目标是200ms</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的 区域（1，2，4，8兆；每个区域都可以独立的作为伊甸园、幸存区、老年代）</li><li>仍然有新生代老年代的概念但是他们不再固定了,他们变成一系列Reion的动态集合</li><li>整体上是标记-整理算法，两个区域之间是复制算法</li></ul><h4 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h4><p>JDK9默认的垃圾回收器，并且在9 废弃了CMS垃圾回收器。   JDK8 并不是默认开启的，所需要参数开启</p><pre><code class="java">-XX:+UseG1GC  //开关，JDK9默认开启-XX:G1HeapRegionSize=size  //设置region大小 1 ， 2， 4， 8-XX:MaxGCPauseMillis=time //默认暂停目标是200ms</code></pre><h3 id="G1-垃圾回收阶段"><a href="#G1-垃圾回收阶段" class="headerlink" title="G1 垃圾回收阶段"></a>G1 垃圾回收阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948611265-89c91622-a8ec-4d35-a1d1-ac36d12133b0.png" alt="img"></p><p><strong>Young Collection：</strong>对新生代垃圾收集</p><p><strong>Young Collection + Concurrent Mark：</strong>如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</p><p><strong>Mixed Collection：</strong>会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h4 id="运行示意图："><a href="#运行示意图：" class="headerlink" title="运行示意图："></a>运行示意图：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648951849268-be1b104e-578b-40d6-b014-2e8033d95798.png" alt="img"></p><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><ul><li>新生代进行GC存在 STW，但时间较短</li><li>会将存活的对象通过复制算法，复制到幸存区</li><li>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每个区域都可以独立的作为伊甸园、幸存区、老年代，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！</li></ul><p><strong>E：eden，S：幸存区，O：老年代</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948818440-2ea40959-173c-46c1-917e-7a6298282423.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948833159-c3a47bc4-00a8-43da-9615-1161cf4a6df1.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648948852640-a71c1413-0cd4-4c9e-b00b-085899d60672.png" alt="img"></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><p>在 Young GC 时，即STW时，会进行 GC Root 的直接对象的初始化标记</p><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定 </p><p>-XX:InitiatingHeapOccupancyPercent&#x3D;percent （默认45%）<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949003589-721183f6-bf2a-453a-86e1-a9d977d69b13.png" alt="img"></p><h4 id="Mixed-Collection："><a href="#Mixed-Collection：" class="headerlink" title="Mixed Collection："></a>Mixed Collection：</h4><ul><li><p>会对 E S O 进行全面的回收</p></li><li><p><strong>最终标记会(remark) STW    (错标、漏标)</strong></p></li><li><p><strong>拷贝存活会(evacuation) STW</strong></p></li><li><p>-XX:MaxGCPauseMills&#x3D;xxms 用于指定最长的停顿时间，分区的意义体现出来了！</p></li><li><p><strong>问：为什么有的老年代被拷贝了，有的没拷贝？</strong></p></li><li><p><strong>筛选回收</strong> </p></li><li><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949035948-f831e683-2ee0-445d-8ad5-fd44e4a95547.png" alt="img"></p><h3 id="Full-GC辨析："><a href="#Full-GC辨析：" class="headerlink" title="Full GC辨析："></a>Full GC辨析：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648952691083-9cca4e4a-cc30-4ee9-aab3-72a2068dc239.png" alt="img"></p><p>CMS和G1的fullGC发送情况类似：</p><ul><li>G1 在老年代内存不足时（老年代所占内存超过阈值），触发并发标记，重新标记，筛选回收</li><li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理，虽然重新标记，筛选回收有STW，但比fullGC耗时少</li><li>如果垃圾产生速度快于垃圾回收速度，并发收集失败，然后退化成 serial Old 收集器串行的收集，触发 Full GC，就会导致停顿STW的时间长。</li></ul><h3 id="记忆表-Remembered-Set-："><a href="#记忆表-Remembered-Set-：" class="headerlink" title="记忆表(Remembered Set)："></a>记忆表(Remembered Set)：</h3><ul><li>进行minor GC 时不应为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干内存块， 标识出老年代的哪一块内存会存在跨代引用。</li><li>此后当发生Minor GC时， 只有包含了跨代引用的内存块里的对象才会被加入到GCRoots进行扫描。 虽然这种方法需要在对象改变引用关系（ 如将自己或者某个属性赋值） 时维护记录数据的正确性， 会增加一些运行时的开销， 但比起收集时扫描整个老年代来说仍然是划算的。</li></ul><h3 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h3><ul><li>“卡精度”所指的是用一种称为“卡表”（Card Table） 的方式去实现记忆集。前面定义中提到记忆集其实是一种“抽象”的数据结构， 抽象的意思是只定义了记忆集的行为意图， 并没有定义其行为的具体实现。 卡表就是记忆集的一种具体实现， 它定义了记忆集的记录精度、 与堆内存的映射关系等 。</li><li>卡表最简单的形式可以只是一个字节数组，数组中每一个元素都对应着其标识的内存区域中一块特定大小的内存块， 这个内存块被称作“卡页”（Card Page） 。 一般来说， 卡页大小都是以2的N次幂的字节数， 通过上面代码可以看出HotSpot中使用的卡页是2的9次幂， 即512字节 。</li><li>一个卡页的内存中通常包含不止一个对象， 只要卡页内有一个（或更多） 对象的字段存在着跨代指针， 那就将对应卡表的数组元素的值标识为1， 称为这个元素变脏（Dirty） ， 没有则标识为0。 在垃圾收集发生时， 只要筛选出卡表中变脏的元素， 就能轻易得出哪些卡页内存块中包含跨代指针， 把它们加入GC Roots中一并扫描。</li></ul><h3 id="写屏障（Write-Barrier）"><a href="#写屏障（Write-Barrier）" class="headerlink" title="写屏障（Write Barrier）"></a>写屏障（Write Barrier）</h3><p>写屏障（Write Barrier）技术维护卡表状态。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面， 在引用对象赋值时会产生一个环形（Around） 通知， 供程序执行额外的动作， 也就是说赋值的<br>前后都在写屏障的覆盖范畴内。 </p><h3 id="Young-Collection垃圾回收的跨代引用问题："><a href="#Young-Collection垃圾回收的跨代引用问题：" class="headerlink" title="Young Collection垃圾回收的跨代引用问题："></a>Young Collection垃圾回收的跨代引用问题：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949069957-d64d4a0e-81c8-42d1-b29c-0a1615dc60fe.png" alt="img"></p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡</li><li>脏卡：O 被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li><li>将来不用找整个老年代根对象，只需要关注脏卡区域，提高效率</li><li>在引用对象赋值时通过写屏障更新卡表  post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949095307-3aef0ce2-f43f-4205-872f-a30b0a67b1af.png" alt="img"></p><h3 id="Remark重新标记阶段-详解："><a href="#Remark重新标记阶段-详解：" class="headerlink" title="Remark重新标记阶段 详解："></a>Remark重新标记阶段 详解：</h3><p>在垃圾回收并发标记阶段，收集器处理对象的过程中 ，对象的状态：</p><ul><li>黑色：已被处理，需要保留的</li><li>灰色：正在处理中的</li><li>白色：还未处理的<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949120624-b90b62c7-57fa-44b0-926f-15b198e358b9.png" alt="img"></li><li>但是在并发标记过程中，有可能 A 被处理了以后未引用 C ，但该处理过程还未结束；</li><li>在处理过程结束之前用户线程使 A 引用了 C ，即对象的引用发送改变时，这时就会用到 remark</li></ul><h4 id="过程如下："><a href="#过程如下：" class="headerlink" title="过程如下："></a>过程如下：</h4><ul><li>之前 C 未被引用，这时 A 引用了 C ，就会给 C 加一个写屏障，写屏障的指令会被执行，将 C 放入一个队列当中，并将 C 变为 处理中 状态</li><li>在并发标记阶段结束以后，重新标记 阶段会 STW ，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它，由灰色变成黑色。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949161437-46c610b5-08af-4d28-896d-48e43f003dfd.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648949181853-a6339cd4-1a3d-4b8e-b097-d47dfad37daf.png" alt="img"></p><h2 id="G1垃圾回收器优化："><a href="#G1垃圾回收器优化：" class="headerlink" title="G1垃圾回收器优化："></a>G1垃圾回收器优化：</h2><p>程序进行中的优化 ，只介绍JDK8-JDK9</p><h3 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h3><p>String对象不是一样，返回false。因为他们是两个字符串对象，只是他们的底层value属性指向的char[]都引用到同一个char[]了 ，去看一下String源码会明白点。</p><ul><li>将所有新分配的字符串（底层是 char[] ）放入一个队列</li><li>当新生代回收时，G1 并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们引用同一个字符串对象</li></ul><h4 id="其与-String-intern-的区别"><a href="#其与-String-intern-的区别" class="headerlink" title="其与 String.intern() 的区别"></a>其与 String.intern() 的区别</h4><ul><li>String.intern() 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串标</li></ul><h4 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h4><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用 CPU</li></ul><pre><code class="java">-XX:+UseStringDeduplication  //字符串去重，默认开启</code></pre><h3 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>对于自定义类加载器，如果这个加载器下面的所有类以及它们的实例不被使用，那么这个类加载器下面的所有类就会被卸载。</p><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ul><li>所有对象都经过并发标记阶段以后，就能知道哪些类不再被使用，这时尝试执行类卸载的操作。</li><li>卸载条件：首先这个类的实例都被回收掉了，这个类所在的 类加载器的 所有类都不在使用，则卸载它所加载的所有类。虽然条件比较苛刻，但是对于一些框架程序，很多都是使用自定义的类加载器，当没用的时候，就可以卸载此类加载器下的所有类。</li></ul><h3 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h3><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝，因为大，耗时间</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648972282994-e7dfbb09-b52e-466a-8b80-a7c92c6f5623.png" alt="img"></p><h3 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h3><ul><li>并发标记必须在堆空间占满前完成，否则退化为 FulGC</li><li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK 9 之后可以动态调整</li><li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li><li>之后会进行数据采样并动态调整，总会添加一个安全的空挡空间来容纳并发过程中用户线程产生的垃圾</li></ul><h1 id="🌟垃圾回收调优"><a href="#🌟垃圾回收调优" class="headerlink" title="🌟垃圾回收调优"></a>🌟垃圾回收调优</h1><h2 id="查看虚拟机参数命令"><a href="#查看虚拟机参数命令" class="headerlink" title="查看虚拟机参数命令"></a>查看虚拟机参数命令</h2><pre><code class="java">//查看虚拟机运行参数D:\Java\jdk1.8  -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</code></pre><p>可以根据参数去查询具体的信息，有助于调优</p><h2 id="1）调优领域"><a href="#1）调优领域" class="headerlink" title="1）调优领域"></a>1）调优领域</h2><ul><li>内存</li><li>线程锁竞争</li><li>cpu 占用</li><li>io</li><li>GC</li></ul><h2 id="2）确定目标"><a href="#2）确定目标" class="headerlink" title="2）确定目标"></a>2）确定目标</h2><p><strong>低延迟 &#x2F; 高吞吐量？</strong> 选择合适的GC回收器</p><ul><li>hotspot虚拟机中的垃圾回收器：CMS G1 ZGC      <strong>低延迟</strong></li><li>hotspot虚拟机中的垃圾回收器：ParallelGC          <strong>高吞吐量</strong></li><li>其他虚拟机：Zing                                                  <strong>低延迟</strong></li></ul><h2 id="3）最快的-GC"><a href="#3）最快的-GC" class="headerlink" title="3）最快的 GC"></a>3）最快的 GC</h2><h3 id="排除因为自身编写的代码"><a href="#排除因为自身编写的代码" class="headerlink" title="排除因为自身编写的代码"></a>排除因为自身编写的代码</h3><p>首先排除减少因为自身编写的代码而引发的内存问题</p><p>查看 Full GC 前后的内存占用，考虑以下几个问题：</p><h3 id="数据是不是太多？"><a href="#数据是不是太多？" class="headerlink" title="数据是不是太多？"></a>数据是不是太多？</h3><p>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</p><h3 id="数据表示是否太臃肿"><a href="#数据表示是否太臃肿" class="headerlink" title="数据表示是否太臃肿"></a>数据表示是否太臃肿</h3><ul><li>对象图   是不是查询不必要的字段了</li><li>对象大小   一个object最少占16字节； Integer大约占24字节，int占4字节。减小数据本身的占用量</li></ul><h3 id="是否存在内存泄漏"><a href="#是否存在内存泄漏" class="headerlink" title="是否存在内存泄漏"></a>是否存在内存泄漏</h3><ul><li>长时间引用的对象，频繁往里面放东西，如：static Map map &#x3D;   一直不移出</li><li>长时间存活的对象，建议使用软弱引用：</li></ul><p>软</p><p>弱</p><ul><li>第三方缓存实现：redis</li></ul><h2 id="4）从新生代调优开始"><a href="#4）从新生代调优开始" class="headerlink" title="4）从新生代调优开始"></a>4）从新生代调优开始</h2><h3 id="新生代的特点："><a href="#新生代的特点：" class="headerlink" title="新生代的特点："></a>新生代的特点：</h3><h4 id="所有的-new-操作分配内存都是非常快、廉价的"><a href="#所有的-new-操作分配内存都是非常快、廉价的" class="headerlink" title="所有的 new 操作分配内存都是非常快、廉价的"></a>所有的 new 操作分配内存都是非常快、廉价的</h4><ul><li>每个线程都会在伊甸园中分配一块私有的内存空间TLAB，new一个对象首先会检查该线程TLAB缓冲区有没有更多内存，有就在这块区域进行对象分配。因为对象分配也有线程安全问题，线程的内存不能冲突</li><li>TLAB thread-lcoal allocation buffer</li></ul><h4 id="死亡对象回收零代价"><a href="#死亡对象回收零代价" class="headerlink" title="死亡对象回收零代价"></a>死亡对象回收零代价</h4><ul><li>因为新生代垃圾回收是复制算法，把存活的对象复制到幸存区to，然后伊甸园区、from区的内存就释放掉了</li></ul><h4 id="大部分对象用过即死（朝生夕死）"><a href="#大部分对象用过即死（朝生夕死）" class="headerlink" title="大部分对象用过即死（朝生夕死）"></a>大部分对象用过即死（朝生夕死）</h4><h4 id="Minor-GC-所用时间远小于-Full-GC"><a href="#Minor-GC-所用时间远小于-Full-GC" class="headerlink" title="Minor GC 所用时间远小于 Full GC"></a>Minor GC 所用时间远小于 Full GC</h4><ul><li>存活对象少，并且采用复制算法，使用minorGC耗时很少</li></ul><h3 id="新生代内存越大越好么？"><a href="#新生代内存越大越好么？" class="headerlink" title="新生代内存越大越好么？"></a>新生代内存越大越好么？</h3><ul><li>不是</li><li>新生代内存太小：频繁触发 Minor GC ，会 STW ，使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC,，耗时更长。而且当触发 Minor GC 时，清理新生代所花费的时间会更长，因为新生代内存大。</li><li>总的原则，还是将新生代区域调的尽可能大，耗费时间多的是在复制算法中的复制过程，而不是标记过程，因为复制需要将对象内存移动，更新引用对象地址。大部分对象都是朝生夕死，所以复制时间也是占用很少</li></ul><h4 id="新生代内存设置"><a href="#新生代内存设置" class="headerlink" title="新生代内存设置"></a>新生代内存设置</h4><p>新生代所能容纳  <strong>[并发量*(请求-响应)]</strong>  的数据为宜</p><h4 id="幸存区内存设置"><a href="#幸存区内存设置" class="headerlink" title="幸存区内存设置"></a>幸存区内存设置</h4><p>幸存区需要能够保存 <strong>当前活跃对象+需要晋升的对象</strong></p><p>如果幸存区内存太小，当内存不足时，晋升阈值变小，会导致什么后果呢？</p><ul><li>会导致一些存活时间短的对象，晋升到老年代，只有等到老年代内存不足时，才会触发Full GC被回收。</li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升到老年代，不要占用幸存区的内存</li></ul><h4 id="晋升阈值参数"><a href="#晋升阈值参数" class="headerlink" title="晋升阈值参数"></a>晋升阈值参数</h4><pre><code class="java">-XX:MaxTenuringThreshold=threshold-XX:+PrintTenuringDistrubution</code></pre><h2 id="5）老年代调优"><a href="#5）老年代调优" class="headerlink" title="5）老年代调优"></a>5）老年代调优</h2><h3 id="以-CMS-为例："><a href="#以-CMS-为例：" class="headerlink" title="以 CMS 为例："></a>以 CMS 为例：</h3><ul><li>CMS 的老年代内存越大越好，低响应、并发的垃圾回收线程，用户线程也在运行，会产生浮动垃圾，导致内存不足，就会并发失败，退化为serial old ，STW变长</li><li>先尝试不做老年代调优，如果没有 Full GC 那么已经OK；即使发生Full GC，也先尝试调优新生代。</li><li>如果新生代调优后，还是经常Full GC，观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li></ul><h4 id="老年代占用多少进行垃圾回收"><a href="#老年代占用多少进行垃圾回收" class="headerlink" title="老年代占用多少进行垃圾回收"></a>老年代占用多少进行垃圾回收</h4><pre><code class="java">//75% ~ 80%-XX:CMSInitiatingOccupancyFraction=percent</code></pre><h2 id="6）内存调优案例"><a href="#6）内存调优案例" class="headerlink" title="6）内存调优案例"></a>6）内存调优案例</h2><h3 id="案例1：Full-GC-和-Minor-GC都频繁"><a href="#案例1：Full-GC-和-Minor-GC都频繁" class="headerlink" title="案例1：Full GC 和 Minor GC都频繁"></a>案例1：Full GC 和 Minor GC都频繁</h3><p>增大新生代的内存导致minor gc更少触发，并且survivor区增大，就不会让本不是生命周期那么长的对象进入老年区，从而给老年区节省空间，进一步就减少了老年区触发full GC</p><h3 id="案例2：请求高峰期发生-Full-GC，单次暂停时间特别长（CMS）"><a href="#案例2：请求高峰期发生-Full-GC，单次暂停时间特别长（CMS）" class="headerlink" title="案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）"></a>案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</h3><ul><li>重新标记耗时多，因为重新标记需要扫描整个堆内存，如果业务高峰，新生代个数多，那么扫描需要花费的时间也多。</li><li>重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力</li><li>-XX:+CMSScavengeBeforeRemark</li></ul><h3 id="案例3：老年代充裕情况下，发生-Full-GC（jdk1-7）"><a href="#案例3：老年代充裕情况下，发生-Full-GC（jdk1-7）" class="headerlink" title="案例3：老年代充裕情况下，发生 Full GC（jdk1.7）"></a>案例3：老年代充裕情况下，发生 Full GC（jdk1.7）</h3><ul><li>空间充裕，说明不是并发失败：如内存碎片过多、浮动垃圾过多</li><li>此处应该是JDK1.7版本，由于永久代的空间不足导致full gc；JDK1.8之后JVM实现为元空间，用的是操作系统内存，内存大很多，并且有相应的内存垃圾回收管理，所以在JDK1.8此类情况少见</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/posts/852cfab6.html"/>
      <url>/posts/852cfab6.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="进程的概念，组成特征"><a href="#进程的概念，组成特征" class="headerlink" title="进程的概念，组成特征"></a>进程的概念，组成特征</h2><h3 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702606926-185560f5-3727-4a74-a795-702724ad4995.png#averageHue=%23d4d0cb&clientId=ucbe49618-2be1-4&from=paste&id=u272d463f&originHeight=414&originWidth=1753&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud6ece8e7-5d4c-416d-9ed5-14535cb8fa2&title="></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>程<strong>序段、数据段、PCB三部分组成了进程实体（进程映像</strong>）。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702670456-458c1b77-1257-4b96-8d14-5b3717110a63.png#averageHue=%23d2cbc9&clientId=ucbe49618-2be1-4&from=paste&height=550&id=u0ce6225c&originHeight=825&originWidth=1624&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=824981&status=done&style=none&taskId=u248e4d06-883e-4d6c-8207-2d04dab227b&title=&width=1082.6666666666667" alt="image.png"><br>我们一般把进程实体简称为进程。<br><strong>PCB是进程存在的唯一标志</strong><br>如：创建进程，是创建进程实体中的PCB；撤销实体是撤销PCB。<br>从不同的角度，进程可以有不同的定义：<br>1.进程是程序的一次执行过程<br>2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>3.进程是具有独立功能的程序在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020">数据集</a>合上运行的过程（强调“动态性”它是系统进行资源分配和调度的一个独立单位。<br>引入进程实体的概念后，可把进程定义为：<br>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。<br>注：严格来说，进程实体和进程不同。进程实体是静态的，进程是动态的。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>进程由程序段、数据段、PCB组成。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702606760-15a3933a-4f0c-482b-bcf4-df479b9cdc1b.png#averageHue=%239aa35f&clientId=ucbe49618-2be1-4&from=paste&id=udbf1ad6b&originHeight=668&originWidth=915&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7a582afb-9bad-4b69-aacb-a55e6f3a199&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702801739-d3e5e359-4c4a-4959-82e4-dc0c82c9d230.png#averageHue=%23d0a07f&clientId=ucbe49618-2be1-4&from=paste&height=786&id=ue616bc25&originHeight=865&originWidth=1637&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=567803&status=done&style=none&taskId=ud6050aa5-a5ca-4817-991b-540490f1538&title=&width=1488.1817859263467" alt="image.png"><br>组成：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702607130-9464480b-beb2-432f-b453-edac5eb3d55b.png#averageHue=%2391b471&clientId=ucbe49618-2be1-4&from=paste&id=u7557eca9&originHeight=822&originWidth=1670&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u39dbc3ae-dbca-4921-9e62-1f746934f18&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702990634-c520c32a-50a0-431d-81e8-8da24de9bad0.png#averageHue=%23dfdddc&clientId=ucbe49618-2be1-4&from=paste&height=832&id=uf9adc9a5&originHeight=915&originWidth=1696&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=814466&status=done&style=none&taskId=ucb0ad733-3083-4c37-87f8-5bcee263cb8&title=&width=1541.8181484001734" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702606732-f680ba7f-fc3a-4d65-be5e-5a6323c1e59f.png#averageHue=%2395b377&clientId=ucbe49618-2be1-4&from=paste&id=u6871591d&originHeight=795&originWidth=1457&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5294c4cc-5232-4720-ae67-5925ed6628b&title="></p><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711932805358-43b5844c-127b-44ad-86db-832e68bb4469.png#averageHue=%23d6d8d2&clientId=ubea11f0f-9fad-4&from=paste&height=822&id=u46b89bf2&originHeight=1480&originWidth=2764&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=1731620&status=done&style=none&taskId=ub13d07b7-e3c0-4968-8253-c5100fbfa19&title=&width=1535.555596233887" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702606975-e240e51b-410c-468a-99c7-ddf267a3f688.png#averageHue=%23f6f6f6&clientId=ucbe49618-2be1-4&from=paste&id=u2a365a7d&originHeight=629&originWidth=1660&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua3fdcf2e-e83f-4715-a483-3077df57120&title="></p><p>链接方式：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702607926-11e2cd34-9447-4f58-99e4-ae497e44aa26.png#averageHue=%2389b266&clientId=ucbe49618-2be1-4&from=paste&id=ud6eb3277&originHeight=854&originWidth=1570&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0bda5818-ca95-42ab-95f8-cda1195c1bc&title=">索引方式：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702607736-b0635c3a-fec3-4cb1-b75a-b2c7336c1186.png#averageHue=%23fdfefc&clientId=ucbe49618-2be1-4&from=paste&id=uec4bd078&originHeight=804&originWidth=1283&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud1746f74-2488-495b-9cf4-69a306a264b&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711932744464-76aad909-c08b-4872-a866-116fc55e32ee.png#averageHue=%23dddad9&clientId=ubea11f0f-9fad-4&from=paste&height=774&id=u0f5b013f&originHeight=1394&originWidth=2750&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=1654590&status=done&style=none&taskId=u97644707-b519-4ea7-bea7-957a4a85207&title=&width=1527.7778182500685" alt="image.png"></p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702607720-fbbb1069-9f3e-4a93-98f5-940b3396814f.png#averageHue=%23a0bb86&clientId=ucbe49618-2be1-4&from=paste&id=uab76709d&originHeight=886&originWidth=1818&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u47c128a7-5816-40f4-8e6b-0ea56599566&title="></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711702608172-3d470317-b230-46ce-b50a-1829792f3c1d.png#averageHue=%239fbc83&clientId=ucbe49618-2be1-4&from=paste&id=u232a8457&originHeight=942&originWidth=1537&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u70878fc0-dfb7-47a8-99f5-6a4dbe0838e&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711932920592-b960646f-6ebc-4891-8a36-d41ce7373003.png#averageHue=%23e2e4d9&clientId=ubea11f0f-9fad-4&from=paste&height=783&id=uf206525d&originHeight=1410&originWidth=2516&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=1416410&status=done&style=none&taskId=u6de73de1-8712-4bbf-869e-1558a766146&title=&width=1397.7778148062446" alt="image.png"></p><h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><h3 id="知识总览-1"><a href="#知识总览-1" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933178424-3672b686-1f1c-4d97-b747-738e8efcd432.png#averageHue=%23fbfbfb&clientId=ubea11f0f-9fad-4&from=paste&id=u8dd78a57&originHeight=647&originWidth=1406&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=uddfde8f3-937d-436d-803a-1ad295688b3&title="></p><h3 id="什么是进程控制"><a href="#什么是进程控制" class="headerlink" title="什么是进程控制"></a>什么是进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81&spm=1001.2101.3001.7020">进程状态</a>转换等功能。<br>简化理解：进程控制是要实现进程状态转换。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933178358-249b229a-18fe-492a-96d7-e403bf698382.png#averageHue=%23fcf8f6&clientId=ubea11f0f-9fad-4&from=paste&id=u76cb7147&originHeight=466&originWidth=1722&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u1778ae2a-b43f-4458-aa00-3038fa5921a&title="></p><h3 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933178870-1143fe56-3cb0-43d4-9188-37e32018a4a3.png#averageHue=%23a4c089&clientId=ubea11f0f-9fad-4&from=paste&id=u8a1221d2&originHeight=1058&originWidth=1859&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u83aa61f7-1dc1-482a-848d-24924cb26dc&title="><strong>原语</strong><br>用原语实现进程控制。<br><strong>原语的特点是：执行期间不允许中断，只能一气呵成。</strong><br>原语采用“关中断指令”和“开中断指令”实现。<br>原语运行在核心态。<br>开&#x2F;关 中断指令权限很大，是只能在核心态下执行的特权指令。<br>程序开头-&gt;程序结尾开关中短指令</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933178323-424da464-a775-4758-aa28-d848181d8156.png#averageHue=%23e1e7d7&clientId=ubea11f0f-9fad-4&from=paste&id=uaebe98e6&originHeight=590&originWidth=1556&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u63958486-c6e0-4ef3-ae07-3e1d5431859&title="></p><h3 id="控制相关的原语"><a href="#控制相关的原语" class="headerlink" title="控制相关的原语"></a>控制相关的原语</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933178319-d710cb04-06b5-46bc-9107-c760453e5ae4.png#averageHue=%23ebebeb&clientId=ubea11f0f-9fad-4&from=paste&id=ubd213cf8&originHeight=331&originWidth=1487&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u7da03079-d2ca-4fef-be57-7fad7274bfe&title=">进程创建原语：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933179126-f8e5ee8b-ce1c-43b7-8bd4-ed7a81213934.png#averageHue=%23cddac0&clientId=ubea11f0f-9fad-4&from=paste&id=u85c5d6fe&originHeight=543&originWidth=1805&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=uf4c5a819-f3b4-444c-b1aa-9e2cd8e1269&title=">进程终止原语：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933179161-a1f7cded-b01f-40bb-a60c-2674730efcb9.png#averageHue=%23b3c69f&clientId=ubea11f0f-9fad-4&from=paste&id=u6d9803be&originHeight=591&originWidth=1531&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u5b5ce753-6653-404e-a910-87fc604917f&title=">进程阻塞和唤醒原语：<strong>成对使用</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933179177-964867f6-7ac7-4a08-9ff6-4deeb7bef30b.png#averageHue=%23b0c998&clientId=ubea11f0f-9fad-4&from=paste&id=u7091c52a&originHeight=682&originWidth=1853&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u15d9fabb-9dfe-4a4b-9ab6-a50d47427f2&title=">切换原语：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933179464-d650c445-e11f-44d2-b7dc-4126b77b03a5.png#averageHue=%23a4c289&clientId=ubea11f0f-9fad-4&from=paste&id=ubd794149&originHeight=645&originWidth=1337&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=ucdd3e213-a91a-4ec0-b4dd-68df9f74d0a&title="><br>结合程序是如何运行的来理解：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712146526958-83029fd0-0735-493c-b0db-e1fd2ffefc84.png#averageHue=%23a99d6d&clientId=u69e60934-0f15-4&from=paste&height=1178&id=u4aa97809&originHeight=1178&originWidth=2435&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1291993&status=done&style=none&taskId=u56eb8570-f7e0-4daf-8236-2ede27eacb3&title=&width=2435" alt="image.png"><br>通过PCB 保存信息， 来达到防止切换进程，导致PSW， PC， IR内容被覆盖，<br>（这里的PCB有点像程序计数器的意思？）</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1711933180159-d0ad9da9-35f2-4563-b631-f07b705ff133.png#averageHue=%23f8f9f6&clientId=ubea11f0f-9fad-4&from=paste&id=u2eda4cc6&originHeight=764&originWidth=1608&originalType=url&ratio=1.7999999523162842&rotation=0&showTitle=false&status=done&style=none&taskId=u3a8d6663-b59c-43b5-ab8d-3b5dab4fa0a&title="><br>无论哪个进程控制原语，要做的无非三类事情：</p><ol><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信（Inter-ProcessCommunication,IPC）是指两个进程之间产生数据交互。</p><h3 id="为什么需要操作系统支持"><a href="#为什么需要操作系统支持" class="headerlink" title="为什么需要操作系统支持"></a>为什么需要操作系统支持</h3><p>一个进程不能访问其他进程的空间，比如垃圾软件访问你微信，不久g了。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712147039378-0e4dbde4-1a3b-4585-81de-552916962d09.png#averageHue=%23cfcfcf&clientId=u69e60934-0f15-4&from=paste&height=396&id=u595ca00c&originHeight=396&originWidth=710&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95321&status=done&style=none&taskId=u1b3f1f57-0a99-4c96-be92-d9651ca2f4a&title=&width=710" alt="image.png"></p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>通过一个共享存储区来实现共享存储<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712147448041-5dd8c9ca-04dd-47d6-8d48-31fea840ed4c.png#averageHue=%23e7e4e1&clientId=u69e60934-0f15-4&from=paste&height=1146&id=u6cfa4d0c&originHeight=1146&originWidth=2150&originalType=binary&ratio=1&rotation=0&showTitle=false&size=814534&status=done&style=none&taskId=u404e6cd3-bf65-4178-b4ab-c8850d5253e&title=&width=2150" alt="image.png">基干存储区的共享：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信：<br>基于数据结构的天享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712147620119-c1b2b486-63c8-4c04-9601-1c2f3264f1eb.png#averageHue=%23e8e4e1&clientId=u69e60934-0f15-4&from=paste&height=1000&id=uc820ddee&originHeight=1000&originWidth=2047&originalType=binary&ratio=1&rotation=0&showTitle=false&size=804158&status=done&style=none&taskId=u5ac516c5-b21d-4d8c-a57b-f9903554884&title=&width=2047" alt="image.png"></p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul><li>直接通信方式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712148010144-382c4fb5-1db7-400b-a789-7e151e66d171.png#averageHue=%23eadfda&clientId=u69e60934-0f15-4&from=paste&height=1030&id=u463c6e72&originHeight=1030&originWidth=2074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=670767&status=done&style=none&taskId=ubf310d62-2882-4008-9f10-b5fd4a787f8&title=&width=2074" alt="image.png"><br>进程P发消息到操作系统的内核中， Q在其中找P的消息，找到之后放到进程Q的地址空间中。</p><ul><li>间接通信方式</li></ul><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712148394959-268b5290-56b5-46c9-a4c9-043e8fac8bd7.png#averageHue=%23e7e5e4&clientId=u69e60934-0f15-4&from=paste&height=1130&id=uc398350f&originHeight=1130&originWidth=1723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=714517&status=done&style=none&taskId=u12baf0bf-d366-4ec7-928f-be4dfb6b4f9&title=&width=1723" alt="image.png"><br>进程P将信息发送到信箱A中， 进程Q从信箱取出来。<br>相比直接通信方式，间接通信方式可以在一个信箱recive来自多个进程的消息，而直接通信是点名到姓的方式来进行。</p><ul><li>管道通信方式</li></ul><p>FIFO，类似于队列。本质就是在内存中开辟一个大小固定的缓冲区。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712148713397-e373766e-ab72-4563-ab32-214a0bad6cc3.png#averageHue=%23efeeee&clientId=u69e60934-0f15-4&from=paste&height=1135&id=uf0a68024&originHeight=1135&originWidth=1998&originalType=binary&ratio=1&rotation=0&showTitle=false&size=739208&status=done&style=none&taskId=u16826606-d9f2-4ce7-b587-3e26af76c9e&title=&width=1998" alt="image.png"><br>这里的管道缓冲区可以理解为一个循环队列。</p><blockquote><p>和共享内存有什么区别呢?</p></blockquote><p>管道通信是先进先出。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712149058551-00f7622c-43aa-4a7a-81df-e56f83dcc236.png#averageHue=%23dfdad7&clientId=u69e60934-0f15-4&from=paste&height=634&id=u5680989a&originHeight=634&originWidth=1879&originalType=binary&ratio=1&rotation=0&showTitle=false&size=444023&status=done&style=none&taskId=u33867ca1-74f6-4230-a721-e10dbeb0840&title=&width=1879" alt="image.png"></p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道（由操作系统实现）</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①一个管道允许多个写进程，（1个读进程2014年408真题高教社官方答案）；②允许有多个写进程，多个读进程，但系统会让各个个读进程轮流从管道中读数据（Linux 的方案）。</li></ol><h3 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a>知识点梳理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712149257101-fd8a1d6b-e4b6-4789-bb93-daf051ee8ec9.png#averageHue=%23e6e6e6&clientId=u69e60934-0f15-4&from=paste&height=1076&id=u21793875&originHeight=1076&originWidth=1957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=569538&status=done&style=none&taskId=u3addef58-afe5-4b1c-bbb7-dbaddbef6ff&title=&width=1957" alt="image.png"><br>内存缓冲区<br>半双工通信<br>互斥访问管道</p><p>写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据<br>读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据</p><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><h3 id="为什么引入线程"><a href="#为什么引入线程" class="headerlink" title="为什么引入线程"></a>为什么引入线程</h3><p>传统的进程，只能串行的去处理程序，程序执行流的最小单位是进程。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712159723928-235ad70a-7e2d-4621-9654-98b7f2cbd2c9.png#averageHue=%23fefefc&clientId=ucd5fe55e-4a30-4&from=paste&height=478&id=ua0e1014d&originHeight=956&originWidth=648&originalType=binary&ratio=2&rotation=0&showTitle=false&size=206800&status=done&style=none&taskId=u1ab47386-5e5f-452f-9919-a41e8350115&title=&width=324" alt="image.png"><br>引入线程后，线程成为执行流的最小单位，增加了并发度。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712159771783-c7d1f58b-61d5-49fb-8873-18f41447c378.png#averageHue=%23b3c39f&clientId=ucd5fe55e-4a30-4&from=paste&height=555&id=u420d20b1&originHeight=1110&originWidth=1574&originalType=binary&ratio=2&rotation=0&showTitle=false&size=706778&status=done&style=none&taskId=ue5b1fa80-4ee1-4611-bbad-a0d65a1c8d2&title=&width=787" alt="image.png"><br>可以把线程理解“轻量级进程”。 线程是一个基本的CPU执行单元，也是程序执行流的最小单位。 引入线程之后，不仅是进程之间 可以并发，进程内的各线程之间 也可以并发，从而进一步提升了 系统的并发度，使得一个进程内 也可以并发处理各种任务（如QQ视频、文字聊天、传文件） 引入线程后，进程只作为除CPU之 外的系统资源的分配单元（如打 印机、内存地址空间等都是分配给进程的）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712159897468-99c0dda4-c09f-45b2-8ece-7465b6b6beeb.png#averageHue=%23cbd1c2&clientId=ucd5fe55e-4a30-4&from=paste&height=665&id=u31a41bca&originHeight=1330&originWidth=1684&originalType=binary&ratio=2&rotation=0&showTitle=false&size=751044&status=done&style=none&taskId=u5d13be7e-d69c-4957-9c6d-4889a4afdbd&title=&width=842" alt="image.png"></p><h3 id="引入线程机制后有什么变化"><a href="#引入线程机制后有什么变化" class="headerlink" title="引入线程机制后有什么变化"></a>引入线程机制后有什么变化</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712159987826-bac03288-5e48-480d-9068-50cd216c6599.png#averageHue=%23dfb4ae&clientId=ucd5fe55e-4a30-4&from=paste&height=653&id=u9980197f&originHeight=1306&originWidth=2750&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1434652&status=done&style=none&taskId=u7495bab8-e929-4e31-834a-fb3fe768cd1&title=&width=1375" alt="image.png"></p><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712160077081-b69aac13-df0a-4833-8074-2d554a5873c7.png#averageHue=%23e0e0e0&clientId=ucd5fe55e-4a30-4&from=paste&height=712&id=u71b9d6e5&originHeight=1424&originWidth=2190&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1098146&status=done&style=none&taskId=u713d9556-ce9f-4c31-b1de-bf48f863705&title=&width=1095" alt="image.png"></p><h2 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712160674319-af921095-723f-49fe-ab44-1a4b95a216b1.png#averageHue=%23d5d5d5&clientId=u4e4148cf-5ca9-4&from=paste&height=447&id=ufaf0d73e&originHeight=894&originWidth=1858&originalType=binary&ratio=2&rotation=0&showTitle=false&size=320556&status=done&style=none&taskId=u3439f818-9f0b-4bf0-8168-bcab3ea8550&title=&width=929" alt="image.png"></p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><h4 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712241447827-333fbc2c-174f-4ac7-8401-73a333174c5a.png#averageHue=%23acabaa&clientId=ud9dcd271-f44b-4&from=paste&height=610&id=u11ae1a87&originHeight=1220&originWidth=1378&originalType=binary&ratio=2&rotation=0&showTitle=false&size=466279&status=done&style=none&taskId=uc2c8fb16-c494-487c-a288-28339e9bb35&title=&width=689" alt="image.png"><br>早期没有_线程，通过线程库来实现“逻辑”的的线程。比如:_<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712241337177-5e5d8ccd-c28c-4f24-868c-3e02b364c4ae.png#averageHue=%23c7c7c7&clientId=ud9dcd271-f44b-4&from=paste&height=347&id=ue5fc7c94&originHeight=694&originWidth=1176&originalType=binary&ratio=2&rotation=0&showTitle=false&size=256151&status=done&style=none&taskId=u032b504f-d9f3-4826-8ed0-433d5c02b1e&title=&width=588" alt="image.png"><br>用户级线程管理操作不是由操作系统完成的，而是通过程序来完成的。</p><hr><ol><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程” 就是“从用户视角看能看到的线程”</li><li>优缺点</li></ol><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞， 并发度不高。多个线程不可在多核处理机上并行运行。</p><h4 id="现代"><a href="#现代" class="headerlink" title="现代"></a>现代</h4><ul><li>一对一</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712242404183-0a210f1f-37a5-428e-8783-32ca2d9726a7.png#averageHue=%23c7c4c3&clientId=ud9dcd271-f44b-4&from=paste&height=682&id=u4189e306&originHeight=1364&originWidth=2798&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1501569&status=done&style=none&taskId=u840359e2-e122-430c-bf9d-51f3fbd4890&title=&width=1399" alt="image.png"></p><ul><li>多对一</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712242641315-d4e40df0-9fda-4418-9794-4c1fd94c1fa7.png#averageHue=%23c6c4c3&clientId=ud9dcd271-f44b-4&from=paste&height=564&id=u5b30b1b9&originHeight=1128&originWidth=2792&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1011640&status=done&style=none&taskId=u97ab9de3-2511-4a8d-9fa4-bf4e7b4c577&title=&width=1396" alt="image.png"></p><ul><li>多对多</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712242828321-c05e4db0-db01-4e9c-ac56-5ebda12a53b6.png#averageHue=%23c4bdbb&clientId=ud9dcd271-f44b-4&from=paste&height=721&id=u016eb3f6&originHeight=1442&originWidth=2770&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2133027&status=done&style=none&taskId=ub5fff3e8-8c74-4335-a20a-911f3e48cb0&title=&width=1385" alt="image.png"></p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712242860495-fb13ac64-43e9-453f-beb0-7927e5c3219e.png#averageHue=%23d9d9d9&clientId=ud9dcd271-f44b-4&from=paste&height=675&id=udb4b5809&originHeight=1350&originWidth=2458&originalType=binary&ratio=2&rotation=0&showTitle=false&size=842112&status=done&style=none&taskId=u9b625a76-b274-400e-8f1a-7566af77a10&title=&width=1229" alt="image.png"></p><h2 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h2><h3 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712242972041-110b43c1-b505-4192-a4a2-fa3862fac20a.png#averageHue=%23dbdbdb&clientId=ud9dcd271-f44b-4&from=paste&height=497&id=aMA6b&originHeight=994&originWidth=1814&originalType=binary&ratio=2&rotation=0&showTitle=false&size=300618&status=done&style=none&taskId=ua14b509b-9b67-442a-b0f3-3350323334e&title=&width=907" alt="image.png"></p><h3 id="组织与控制"><a href="#组织与控制" class="headerlink" title="组织与控制"></a>组织与控制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712243169505-2e03a4d0-e798-4075-abe0-c78e544b8acf.png#averageHue=%23e1e0df&clientId=ud9dcd271-f44b-4&from=paste&height=599&id=u84d6ab3f&originHeight=1198&originWidth=2662&originalType=binary&ratio=2&rotation=0&showTitle=false&size=607747&status=done&style=none&taskId=u559dd93e-7819-471a-81ee-d844bcc5448&title=&width=1331" alt="image.png"><br>主要根进程的PCB类似。<br>堆栈指针 主要记录，比如a调用b， 值赋给c这些，<br>堆栈指针，指的是内存中的堆栈。</p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712243340304-afcc6284-6483-41ec-81cc-63fce46fc885.png#averageHue=%23dedede&clientId=ud9dcd271-f44b-4&from=paste&height=618&id=u648c57a2&originHeight=1236&originWidth=2382&originalType=binary&ratio=2&rotation=0&showTitle=false&size=834149&status=done&style=none&taskId=u9b8d4d24-95cf-4e35-88c5-9452edfe837&title=&width=1191" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285179779-61b6356e-bbb9-4089-8089-48b9d015b214.png#averageHue=%23bcbcbc&clientId=ud9dcd271-f44b-4&from=paste&height=406&id=u66ebfbd8&originHeight=812&originWidth=2624&originalType=binary&ratio=2&rotation=0&showTitle=false&size=758797&status=done&style=none&taskId=uf428f732-7a1e-4ddb-9e69-d5e0aa94f10&title=&width=1312" alt="image.png"><br>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理<br>这些任务的顺序，这就是“调度”研究的问题。</p><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285323177-3a3df526-fdf4-44a0-ae6b-07cac7273e14.png#averageHue=%23e0dedd&clientId=ud9dcd271-f44b-4&from=paste&height=666&id=u8a9767f6&originHeight=1332&originWidth=2748&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1387285&status=done&style=none&taskId=u77213a42-11e2-4dc8-85c7-f88adb0ab98&title=&width=1374" alt="image.png"></p><h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285382113-60494624-dfda-4fa9-87a2-353c5dc05ec5.png#averageHue=%23c0c0c0&clientId=ud9dcd271-f44b-4&from=paste&height=312&id=u83076c09&originHeight=624&originWidth=1720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=423311&status=done&style=none&taskId=u63afc76a-3bbc-4036-96d9-97bbc06f9d9&title=&width=860" alt="image.png">低级调度（进程调度&#x2F;处理机调度）一—按照某种策略从就绪队列中选取一个进程，将处理机分配<br>给它。<br>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。<br>进程调度的频率很高，一般几十毫秒一次。</p><p>轮流的去cpu执行，用户感觉不到</p><h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285597146-5be30ebd-212a-4697-94ec-f0a80b4998d8.png#averageHue=%23efe0d6&clientId=ud9dcd271-f44b-4&from=paste&height=299&id=uaad64513&originHeight=598&originWidth=2224&originalType=binary&ratio=2&rotation=0&showTitle=false&size=579126&status=done&style=none&taskId=u8c00a1ad-c2b1-41e4-80b3-b7bdd030b19&title=&width=1112" alt="image.png"><br>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列<br><strong>中级调度（内存调度</strong>）一一按照某种策略诀定将哪个处上的进程重新调入内存。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285818671-233b307b-0380-4953-aa95-04f071902786.png#averageHue=%23cbcfc8&clientId=ud9dcd271-f44b-4&from=paste&height=584&id=ua615ed4c&originHeight=1168&originWidth=2624&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1486269&status=done&style=none&taskId=u6c6abce9-f904-4906-bb7f-ae3f94ac23b&title=&width=1312" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712285870751-baae90f8-a0d5-471a-8ada-048790de4854.png#averageHue=%23e2e1e1&clientId=ud9dcd271-f44b-4&from=paste&height=659&id=u7d3a9959&originHeight=1318&originWidth=2864&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1328567&status=done&style=none&taskId=u76cf1130-ac2d-40ec-8a5a-1209fe4a65c&title=&width=1432" alt="image.png"></p><h2 id="进程调度的时机切换与过程调度方式"><a href="#进程调度的时机切换与过程调度方式" class="headerlink" title="进程调度的时机切换与过程调度方式"></a>进程调度的时机切换与过程调度方式</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712300247045-8e1f06aa-03fc-44b6-8c89-257f7358f865.png#averageHue=%23dddddc&clientId=uabdbe3df-f9e2-4&from=paste&height=572&id=u722e48a8&originHeight=1144&originWidth=2106&originalType=binary&ratio=2&rotation=0&showTitle=false&size=791631&status=done&style=none&taskId=uc933ba32-8fa0-4f20-beaa-9efbb250833&title=&width=1053" alt="image.png"></p><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><p>进程调度就是按照某种算法从就绪队列选择一个进程为其分配处理机。<br>注意什么时候需要进程调度，（主动放弃？&#x2F;被动放弃？）<br>什么时候不能进行进程调度？<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712300468726-2263c2e1-f8e3-4ca2-a7c2-d003917e4ac6.png#averageHue=%23dcdbd9&clientId=uabdbe3df-f9e2-4&from=paste&height=640&id=u28f319fd&originHeight=1280&originWidth=2554&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1400139&status=done&style=none&taskId=u4c45376d-374c-47d6-b66c-da92fd65e6a&title=&width=1277" alt="image.png"></p><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712300811241-d6dfdc2b-d8c6-4568-9cfd-6922a9f12de4.png#averageHue=%23dcdbdb&clientId=uabdbe3df-f9e2-4&from=paste&height=645&id=u314dcf92&originHeight=1290&originWidth=2760&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1699474&status=done&style=none&taskId=u4a608542-b070-415a-927c-7816f67de01&title=&width=1380" alt="image.png"><br>在内核临界区，访问资源会进行加锁，期间不能进行调度和切换。<br>在普通临界区，比如打印机，可以进行调度与切换。<br>所以真题说临界区不能进行处理机调度是错的，以偏概全。</p><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301057968-0afa65ef-9c93-4d09-8b5a-22e921277c80.png#averageHue=%23dddddd&clientId=uabdbe3df-f9e2-4&from=paste&height=630&id=uc1feab2c&originHeight=1260&originWidth=2682&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1294521&status=done&style=none&taskId=uc00d92f9-f5bf-4a53-a29b-b158fbb98e9&title=&width=1341" alt="image.png"></p><h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301252243-597d3fa8-2f6f-4483-8503-fe782eca520a.png#averageHue=%23dadada&clientId=uabdbe3df-f9e2-4&from=paste&height=554&id=uabe02604&originHeight=1108&originWidth=2700&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1234600&status=done&style=none&taskId=u9767b69b-6c18-46a4-a426-d49e03745b7&title=&width=1350" alt="image.png"></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301299088-aaf70dbe-ed70-4e92-9e7a-d389d638905f.png#averageHue=%23d7d4cf&clientId=uabdbe3df-f9e2-4&from=paste&height=767&id=uac4fcd64&originHeight=1534&originWidth=2486&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1478238&status=done&style=none&taskId=uc9bc5037-fa8e-4e02-a0a2-ef112b2f7da&title=&width=1243" alt="image.png"><br>进程的切换是有代价的，还有就是注意临界区的理解</p><h2 id="调度器，闲逛进程"><a href="#调度器，闲逛进程" class="headerlink" title="调度器，闲逛进程"></a>调度器，闲逛进程</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301382758-98c0d170-3efb-462f-8e52-ae44791dc861.png#averageHue=%23d4d4d4&clientId=uabdbe3df-f9e2-4&from=paste&height=390&id=ua0bc5c29&originHeight=780&originWidth=1340&originalType=binary&ratio=2&rotation=0&showTitle=false&size=178807&status=done&style=none&taskId=ubb4fa1bb-3cf0-46bd-be8e-b89aff44f4f&title=&width=670" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301522735-132606e1-f688-4262-958e-c6ce6d30a27c.png#averageHue=%23d9d7d7&clientId=uabdbe3df-f9e2-4&from=paste&height=628&id=u85b65b0f&originHeight=1256&originWidth=1370&originalType=binary&ratio=2&rotation=0&showTitle=false&size=593586&status=done&style=none&taskId=ub8cf9ed2-5e50-40a2-94c8-9bcdb421c21&title=&width=685" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301586914-7ee2c868-d79f-40d3-8e3a-276f5f2a06da.png#averageHue=%23d4d4d4&clientId=uabdbe3df-f9e2-4&from=paste&height=334&id=u0eb847f2&originHeight=668&originWidth=2746&originalType=binary&ratio=2&rotation=0&showTitle=false&size=293555&status=done&style=none&taskId=u21fd9c3f-cbc4-4748-8633-9af58eb880e&title=&width=1373" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301663786-e289b6e1-d166-4f4b-8c53-cef9dfef7316.png#averageHue=%23d6d6a7&clientId=uabdbe3df-f9e2-4&from=paste&height=676&id=u6b05b1f6&originHeight=1352&originWidth=1954&originalType=binary&ratio=2&rotation=0&showTitle=false&size=589755&status=done&style=none&taskId=u5cd8af9d-8e35-4aae-8785-e629a372587&title=&width=977" alt="image.png"></p><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712301698593-7662ae87-d406-48af-9dd2-201cbca0c1c8.png#averageHue=%23dbdbdb&clientId=uabdbe3df-f9e2-4&from=paste&height=441&id=u6f7c089f&originHeight=882&originWidth=2384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=497067&status=done&style=none&taskId=u8f780eae-8dc1-4d9d-a432-bb44e14a915&title=&width=1192" alt="image.png"></p><ul><li>CPU利用率</li></ul><p>忙碌时间（CPU运行时间） &#x2F; 总时间。</p><ul><li>系统吞吐量</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712452106566-4c4c3398-f82e-4c17-8248-8a42daa60773.png#averageHue=%23d9d9d9&clientId=u29d4ccfe-e999-4&from=paste&height=433&id=u1c84bab2&originHeight=866&originWidth=1824&originalType=binary&ratio=2&rotation=0&showTitle=false&size=288024&status=done&style=none&taskId=u30564a2d-a36a-4596-9cf2-e610ee47c95&title=&width=912" alt="image.png"></p><ul><li>周转时间</li></ul><p>作业完成时间 - 作业提交时间<br>越短越好</p><ul><li>等待时间</li></ul><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;0完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><ul><li>响应时间</li></ul><p>提交请求到首次产生响应<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712452510875-1fc1cfad-9a18-4fa6-b361-2ef1b12567d0.png#averageHue=%23dfdede&clientId=u29d4ccfe-e999-4&from=paste&height=678&id=u2216b92c&originHeight=1356&originWidth=2172&originalType=binary&ratio=2&rotation=0&showTitle=false&size=919273&status=done&style=none&taskId=ude7b8ad3-b2a0-49a4-bbdd-02ca96f2a8d&title=&width=1086" alt="image.png"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul><li>运行态→等待态：等待使用资源；</li><li>如等待外设传输；等待人工干预。</li><li>等待态→就绪态：资源得到满足；</li><li>如外设传输结束；人工干预完成。</li><li>运行态→就绪态：运行时间片到；</li></ul><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>公平，先来的先服务，不会导致后来的还跟先来的去一样的抢锁。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712454871723-a9f19aab-c6ef-4d7c-b1ad-203f2f3e6203.png#averageHue=%23d3d1cf&clientId=u29d4ccfe-e999-4&from=paste&height=695&id=ufe34f697&originHeight=1390&originWidth=2660&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1684258&status=done&style=none&taskId=ud70136b1-4220-41e0-8c8e-3b0015882f4&title=&width=1330" alt="image.png"></p><h2 id="进程同步、互斥"><a href="#进程同步、互斥" class="headerlink" title="进程同步、互斥"></a>进程同步、互斥</h2><h3 id="进程同步、异步、临界区"><a href="#进程同步、异步、临界区" class="headerlink" title="进程同步、异步、临界区"></a>进程同步、异步、临界区</h3><p>进程同步就是为了解决异步读写操作带来的问题。</p><p>两种资源共享方式：</p><ul><li>互斥共享（一段时间只允许一个进程）</li><li>同时共享（宏观上同时）</li></ul><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。<br>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712503463203-c14fb5be-c147-4eb5-809b-f51cbdd1f307.png#averageHue=%23cfd0cd&clientId=uccc0ee54-63cc-4&from=paste&height=395&id=ub8e3ebab&originHeight=790&originWidth=2326&originalType=binary&ratio=2&rotation=0&showTitle=false&size=847890&status=done&style=none&taskId=u28351dee-bbd1-4b01-ad09-107f4952352&title=&width=1163" alt="image.png"></p><p>注意：临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。</p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="知识回顾-1"><a href="#知识回顾-1" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712503647242-e833ad5c-73f8-45b8-b986-1709f792c1d0.png#averageHue=%23d3d0cb&clientId=uccc0ee54-63cc-4&from=paste&height=647&id=u56abb8a4&originHeight=1294&originWidth=2834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1378239&status=done&style=none&taskId=u575cb4f6-553d-47ad-886f-19f3f449df4&title=&width=1417" alt="image.png"></p><h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712503729667-f2971097-8380-4b62-af2a-94d1f8a8a176.png#averageHue=%23c8c6c2&clientId=uccc0ee54-63cc-4&from=paste&height=361&id=ued8d07a4&originHeight=722&originWidth=1494&originalType=binary&ratio=2&rotation=0&showTitle=false&size=384623&status=done&style=none&taskId=u35c457cb-ddc1-431a-9963-2eb5a9b9aab&title=&width=747" alt="image.png"></p><h3 id="如果没有进程互斥"><a href="#如果没有进程互斥" class="headerlink" title="如果没有进程互斥"></a>如果没有进程互斥</h3><p>如果两个进程同时操作一个资源，那么两个进程就混在一起了！<br>那么如何通过软件来避免进程互斥？</p><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712503994059-507dd5a5-95c9-47b9-bb4a-e48a9ecd70d7.png#averageHue=%23dcdada&clientId=uccc0ee54-63cc-4&from=paste&height=684&id=ucc1779c4&originHeight=1368&originWidth=2668&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1660430&status=done&style=none&taskId=ufc21d0be-2469-4a96-ad4d-77072d0b64b&title=&width=1334" alt="image.png"><br>但是这样会有一个问题。<br>如果P0进程执行完成，turn变为1<br>那么当临界区再次空闲， P0却出不去， 违反了空闲让进的原则</p><h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712504482256-1679cb69-ef98-4379-9442-7327c452f1cc.png#averageHue=%23d5d4d4&clientId=uccc0ee54-63cc-4&from=paste&height=613&id=u97c50dce&originHeight=1226&originWidth=2662&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1662431&status=done&style=none&taskId=u0f7d36e8-04a1-4954-b06c-83f4d882611&title=&width=1331" alt="image.png"><br>因为1，2 。 5，6 。 两步不是原子性，可能导致两个进程同时进入临界区</p><p>可以用硬件的方式保证这两步一气呵成！</p><h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712504632061-4c0f07b8-2c7c-44ca-b9f7-95005575ff6a.png#averageHue=%23d8d7d7&clientId=uccc0ee54-63cc-4&from=paste&height=635&id=u72e8f944&originHeight=1270&originWidth=2716&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1651957&status=done&style=none&taskId=u43d80745-8ba3-4b77-9592-6ea90c1f378&title=&width=1358" alt="image.png"><br>可能P0,P1都无法进入临界区</p><h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712504962342-52ab2763-217b-473b-bd9b-f3fc83cbc1de.png#averageHue=%23dad9d9&clientId=uccc0ee54-63cc-4&from=paste&height=695&id=u48d962d5&originHeight=1390&originWidth=2798&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1746538&status=done&style=none&taskId=ub2fef45f-0b30-40ab-a49b-f4cd6e16f40&title=&width=1399" alt="image.png"></p><p>如果p0执行到3进不了临界区就应该立马放弃CPU资源， 但是这里会一直占用CPU资源，违反了让权等待的原则；</p><h3 id="知识回顾-2"><a href="#知识回顾-2" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712505192467-8a77e698-aff0-498a-bf6a-c8bfa069927a.png#averageHue=%23cac9c6&clientId=uccc0ee54-63cc-4&from=paste&height=606&id=lZ9tZ&originHeight=1212&originWidth=2612&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1188009&status=done&style=none&taskId=u63ed327f-d5a0-4577-a2fa-6446935215f&title=&width=1306" alt="image.png"></p><h2 id="进程互斥方法"><a href="#进程互斥方法" class="headerlink" title="进程互斥方法"></a>进程互斥方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712535949920-be85f886-ffd2-4114-bae3-c6533922bcd7.png#averageHue=%23dddddd&clientId=uccc0ee54-63cc-4&from=paste&height=591&id=u828c1378&originHeight=1182&originWidth=2654&originalType=binary&ratio=2&rotation=0&showTitle=false&size=942495&status=done&style=none&taskId=u70361b3e-f8b2-4458-aa22-b6b38f1987f&title=&width=1327" alt="image.png"><br>缺点是需要在同一个处理机上。</p><h3 id="testAndSet"><a href="#testAndSet" class="headerlink" title="testAndSet"></a>testAndSet</h3><p>有点类似于CAS<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712536261400-7ff69717-7226-47a0-aa5c-607b4a1abbdf.png#averageHue=%23d5d5d5&clientId=uccc0ee54-63cc-4&from=paste&height=416&id=uc58eb104&originHeight=832&originWidth=2710&originalType=binary&ratio=2&rotation=0&showTitle=false&size=906935&status=done&style=none&taskId=u5295e917-164b-40e9-86a1-2a67af6fd34&title=&width=1355" alt="image.png"><br>若刚开始lock 是false，则TSL返回的old 值次false，while 循环条件不满足，直接跳过循环，述入临界区。若刚开始lock 是true，则执行TLS后old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。<br>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作(while(TSL))。<br>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712536488108-c9d8ff29-2c51-41b7-941b-b38f16c89bba.png#averageHue=%23dbdbdb&clientId=uccc0ee54-63cc-4&from=paste&height=660&id=uf87de660&originHeight=1320&originWidth=2640&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1334091&status=done&style=none&taskId=u8444d8ed-6c79-4118-bb60-840ad9f4cf1&title=&width=1320" alt="image.png"><br>跟TSL基本一样</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712536651208-b3014174-855b-47e5-87c3-c69d0b789536.png#averageHue=%23ded9d9&clientId=uccc0ee54-63cc-4&from=paste&height=637&id=u16d280f6&originHeight=1274&originWidth=2500&originalType=binary&ratio=2&rotation=0&showTitle=false&size=884207&status=done&style=none&taskId=u47ff847e-a48a-479b-a963-6b9daded81d&title=&width=1250" alt="image.png"></p><h3 id="知识回顾-3"><a href="#知识回顾-3" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712536512662-070459dc-e260-42fd-a722-41872d82ad80.png#averageHue=%23dedfdd&clientId=uccc0ee54-63cc-4&from=paste&height=625&id=u4b61efe6&originHeight=1250&originWidth=2736&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1140830&status=done&style=none&taskId=u9ab91707-d696-46f8-b518-411c3e17af5&title=&width=1368" alt="image.png"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="总揽"><a href="#总揽" class="headerlink" title="总揽"></a>总揽</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712538907670-a7e2809c-3eed-41aa-96de-b5ecc32fad77.png#averageHue=%23dedede&clientId=uccc0ee54-63cc-4&from=paste&height=679&id=uf00a92ea&originHeight=1358&originWidth=2376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=893858&status=done&style=none&taskId=u706386fc-a1ee-4939-80f6-18b4d263a8f&title=&width=1188" alt="image.png"><br>很好的解决进程互斥&#x2F;同步问题</p><h3 id="信号量机制-1"><a href="#信号量机制-1" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。<br>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。<br>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。<br>一对原语：wait（S） 原语和 signal（S）原语，可以把原语理解为我们自己写的函数，函数名分别为wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。<br>wait、signal 原语常简称为P、V操作（来自荷兰语 proberen 和verhogen）。因此，做题的时候常把wait（S）、Signal（S） 两个操作分别写为P（S）、V（S）</p><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712539565048-7479925e-865a-46c6-9914-cf01d12f7a1e.png#averageHue=%23e3e2e2&clientId=uccc0ee54-63cc-4&from=paste&height=775&id=u419df677&originHeight=1550&originWidth=2834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1949430&status=done&style=none&taskId=u0a775336-4b88-459f-b6fb-a43e25f8377&title=&width=1417" alt="image.png"><br>有点类似于双标志先检查法，但是这里的while 和 s &#x3D; s-1 是原语实现的，原语是通过开关中断指令实现的，所以这里就完美解决了双标志先检查法带来的判断和执行不能一气呵成的问题</p><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712540111325-92c13ac2-c157-486b-ab42-519fdd4a300e.png#averageHue=%23e2e2e2&clientId=uccc0ee54-63cc-4&from=paste&height=669&id=u309a1001&originHeight=1338&originWidth=2586&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1196031&status=done&style=none&taskId=ud831d6e3-97f0-409f-8485-a2c9e309f22&title=&width=1293" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712540216556-83f4fbb1-4840-42f9-b94f-35d2da50048c.png#averageHue=%23d8d6d6&clientId=uccc0ee54-63cc-4&from=paste&height=666&id=u6ea5f0ed&originHeight=1332&originWidth=2610&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2196652&status=done&style=none&taskId=u8dd65fe8-2b33-48a9-8118-d67edfb9a80&title=&width=1305" alt="image.png"><br>多了一个阻塞队列，资源足够，就从阻塞队列获取一个。<br>解决了让权等待的问题。</p><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712540282210-b7cff2e3-9eb9-4590-a37e-62b27a2d2136.png#averageHue=%23e9e8e6&clientId=uccc0ee54-63cc-4&from=paste&height=612&id=ufd7a6ac2&originHeight=1224&originWidth=2840&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1394742&status=done&style=none&taskId=u49de418d-5c6e-464b-a807-469200ec356&title=&width=1420" alt="image.png"></p><h2 id="用信号量实现同步，互斥，前驱关系"><a href="#用信号量实现同步，互斥，前驱关系" class="headerlink" title="用信号量实现同步，互斥，前驱关系"></a>用信号量实现同步，互斥，前驱关系</h2><h3 id="总揽-1"><a href="#总揽-1" class="headerlink" title="总揽"></a>总揽</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712559421050-7c8aa4ff-7cba-4393-867f-bf93587a4d9c.png#averageHue=%23dddddc&clientId=u94321b27-e9fa-4&from=paste&height=633&id=ueeb16db5&originHeight=1266&originWidth=2462&originalType=binary&ratio=2&rotation=0&showTitle=false&size=815774&status=done&style=none&taskId=ucaaa1070-2bd8-493d-8b93-01b252e004e&title=&width=1231" alt="image.png"></p><h3 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712559647201-78e01ab2-1f90-46d7-917e-e026e915467f.png#averageHue=%23d9d6d4&clientId=u94321b27-e9fa-4&from=paste&height=810&id=u902768ee&originHeight=1620&originWidth=2734&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2265737&status=done&style=none&taskId=u6b103ffb-5a0e-4f7d-99bb-26f8d7065c6&title=&width=1367" alt="image.png"></p><h3 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h3><p>让各个并发进程顺序的进行<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712559945960-6cbca89c-cda6-4d6c-bde4-b990643be05c.png#averageHue=%23dddcdc&clientId=u94321b27-e9fa-4&from=paste&height=793&id=u23764ec2&originHeight=1586&originWidth=2766&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1865386&status=done&style=none&taskId=ue5735b47-92c9-4661-bbf4-6f6959f4797&title=&width=1383" alt="image.png"><br>前V 后 P</p><h3 id="实现前驱关系"><a href="#实现前驱关系" class="headerlink" title="实现前驱关系"></a>实现前驱关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712560063796-15e0ddbc-1b87-4e13-891e-886ff62ab64b.png#averageHue=%23e0dfdf&clientId=u94321b27-e9fa-4&from=paste&height=677&id=u38c6c0b8&originHeight=1354&originWidth=2684&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1271701&status=done&style=none&taskId=ud1ae3a0d-974c-4076-87f2-8d75a0de1f6&title=&width=1342" alt="image.png"><br>应该是在实现同步关系之后的改进版</p><h3 id="知识回顾-4"><a href="#知识回顾-4" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712560325917-b86f5be5-fbc2-4348-910c-51ea993e63f6.png#averageHue=%23e4e3e3&clientId=u94321b27-e9fa-4&from=paste&height=835&id=u3a4b4e7f&originHeight=1670&originWidth=2820&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1779804&status=done&style=none&taskId=u5cd1a26a-43ac-428e-b569-fac50eb13ad&title=&width=1410" alt="image.png"></p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712572748544-b8ceae5b-5269-457f-8936-8a0ce35fa4f6.png#averageHue=%23e5e1e1&clientId=u81d8c38b-8668-4&from=paste&height=1182&id=u859b79fe&originHeight=1182&originWidth=2285&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1018064&status=done&style=none&taskId=u27fbafe3-900c-45aa-9dd2-5ae8456becc&title=&width=2285" alt="image.png"><br>主要是以缓冲区为媒介来实现生产消费的。<br>但是如果两个生产者进程同时放入缓冲区，可能就会导致覆盖。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712572946843-989ab63a-c068-4bcf-899c-af49773c0e4d.png#averageHue=%23b3cba0&clientId=u81d8c38b-8668-4&from=paste&height=480&id=u4258cd92&originHeight=480&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327605&status=done&style=none&taskId=u1d5d2e92-3afe-4a78-aa37-7c12c68df27&title=&width=1596" alt="image.png"><br>full 和 empty都是信号量<br>对这些临界区来执行PV操作 </p><h3 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712573353160-1f3c3798-43fd-4e8d-a9ec-c47cd86ff9f0.png#averageHue=%23d5d4d4&clientId=u81d8c38b-8668-4&from=paste&height=1304&id=ucf2a8148&originHeight=1304&originWidth=2503&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1739557&status=done&style=none&taskId=u98026ebd-8bf3-4941-b55e-845fa653281&title=&width=2503" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712573647046-60b19970-1b03-4558-b44c-8275e99d51c4.png#averageHue=%23d7d7d7&clientId=u81d8c38b-8668-4&from=paste&height=1195&id=ue94444be&originHeight=1195&originWidth=2234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=949202&status=done&style=none&taskId=u0edf4e1a-4cc5-48e9-8b1f-89fad08d88f&title=&width=2234" alt="image.png"><br>会发生死锁，因为当缓冲区已经放慢产品，生产者就不会再去放了， 但是mutex已经变为0了， 所以消费者也没有办法去消费， 所以就会导致发生死锁。</p><h3 id="知识回顾-5"><a href="#知识回顾-5" class="headerlink" title="知识回顾"></a>知识回顾</h3><p>PV 操作题目的解题思路：</p><ol><li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li><li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li></ol><p>3.’设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为<br>1，同步信号量的初始值要看对应资源的初始值是多少）生产者消费者问题是一个互斥、同步的综合问题。<br>对于初学者来说最难的是发现题目中隐含的两对同步关系。<br>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p><h2 id="多生产者-多消费者"><a href="#多生产者-多消费者" class="headerlink" title="多生产者-多消费者"></a>多生产者-多消费者</h2><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><h3 id="总揽-2"><a href="#总揽-2" class="headerlink" title="总揽"></a>总揽</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712560488388-67da8c82-2e6d-4bb6-817f-f35af4358a49.png#averageHue=%23d9d9d9&clientId=u94321b27-e9fa-4&from=paste&height=511&id=u21a36b56&originHeight=1022&originWidth=2038&originalType=binary&ratio=2&rotation=0&showTitle=false&size=566153&status=done&style=none&taskId=u839c4d36-ac3e-4bcd-80cd-33aa44090a9&title=&width=1019" alt="image.png"></p><h3 id="为什么引入管程"><a href="#为什么引入管程" class="headerlink" title="为什么引入管程"></a>为什么引入管程</h3><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的共享数据结构说明；</li><li>对该数据结构进行操作的一组过程；</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程有一个名字。<br>跨考Tips：“过程〞其实就是“函数”<br>管程的基本特征：</li><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><h3 id="用管程解决生产者消费者问题"><a href="#用管程解决生产者消费者问题" class="headerlink" title="用管程解决生产者消费者问题"></a>用管程解决生产者消费者问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712645365255-feffbba1-5519-4004-972e-c4fe2bd97675.png#averageHue=%23dfdedd&clientId=u55913563-8725-4&from=paste&height=790&id=u832c3b9c&originHeight=1580&originWidth=2768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1821309&status=done&style=none&taskId=u0b5eed29-c1f2-4cb3-9b59-22784d04a78&title=&width=1384" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712645850554-d0f9af27-0ad9-4b23-a8c3-1f02c2ce345c.png#averageHue=%23d6d5d5&clientId=u55913563-8725-4&from=paste&height=651&id=ubb153d00&originHeight=1302&originWidth=2460&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1555580&status=done&style=none&taskId=u047169d5-c766-4756-9090-21a79925580&title=&width=1230" alt="image.png"><br>总之就是避免发生并发问题。</p><p>来点跟Java有关的</p><ul><li>sychronized其实就事管程实现的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712645959997-9efc97bf-7cab-444b-834e-d6b16078fc80.png#averageHue=%23dfdfdf&clientId=u55913563-8725-4&from=paste&height=611&id=u8b73b519&originHeight=1222&originWidth=2686&originalType=binary&ratio=2&rotation=0&showTitle=false&size=922613&status=done&style=none&taskId=uade22616-da84-41f9-b2ae-27491257eee&title=&width=1343" alt="image.png"></p><h3 id="知识回顾-6"><a href="#知识回顾-6" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712646017027-f71b67df-3f45-4fa9-ba83-52e4e02d0579.png#averageHue=%23d1cac7&clientId=u55913563-8725-4&from=paste&height=623&id=ub814cdc2&originHeight=1246&originWidth=2606&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1147551&status=done&style=none&taskId=u19c57c6e-812e-4bcc-a750-8c78d8beea0&title=&width=1303" alt="image.png"> </p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。<br>比如：经典的哲学家进餐问题</p><h3 id="死锁、死循环、饥饿的区别"><a href="#死锁、死循环、饥饿的区别" class="headerlink" title="死锁、死循环、饥饿的区别"></a>死锁、死循环、饥饿的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712646550985-45757931-455e-4bf1-a401-b6a9a22617fb.png#averageHue=%23eaf1ec&clientId=u55913563-8725-4&from=paste&height=650&id=u106d85db&originHeight=1300&originWidth=2518&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2550299&status=done&style=none&taskId=ueb822214-a23a-4b56-bf90-cc8268a6cf5&title=&width=1259" alt="image.png"></p><h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><ol><li><p>对系统资源的竟争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资<br>原（CPU）的竟争是不会引起死锁的。<br>2.进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、<br>P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，<br>两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p></li><li><p>信号量的使用不当也会造成死锁。如生产者-消贵者问题中，如果实现互斥的P操作在实现同步的</p></li></ol><p>p操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资<br>源）<br>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="梳理-1"><a href="#梳理-1" class="headerlink" title="梳理"></a>梳理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712646952739-2a01b44b-9cb3-48bb-aabf-7fd2571a91bb.png#averageHue=%23e4e2de&clientId=u55913563-8725-4&from=paste&height=708&id=u4bd57858&originHeight=1416&originWidth=2372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1464894&status=done&style=none&taskId=u14c864a9-adde-4b33-a851-e604a5f5f56&title=&width=1186" alt="image.png"></p><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>死锁必须满足四个条件<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1712647008920-135a4f89-5886-43fc-8d67-2b15fb731a0e.png#averageHue=%23ccccca&clientId=u55913563-8725-4&from=paste&height=316&id=u6247cd5a&originHeight=632&originWidth=1376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=283401&status=done&style=none&taskId=u6e9a2a38-ff1b-4343-9ceb-6de54464579&title=&width=688" alt="image.png"></p><p>最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p> Java中怎么排查死锁？</p><blockquote><p> 步骤一：使用jsp查找程序进行 jps：jdk提供的一个工具，可以查看到正在运行的java进程 </p><p>步骤二：使用jstack查看线程堆栈信息 jstack：jdk提供的一个工具，可以查看java进程中线程堆栈信息。 更详细的用法见文档最后。 </p><p>$ jstack 96521复制代码 从上面的堆栈信息中我们可以发现这个内容：“Found one Java-level deadlock”，表示程序中发现了一个死锁，后面包含更多详细的信息，重点下面： 死</p><p>锁的代码是在DeadLock.java的32行和18行，此时我们就可以去优化代码，解决死锁问题。</p></blockquote><p>还可以通过jconsole</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写mini-HashMap</title>
      <link href="/posts/4a58d47c.html"/>
      <url>/posts/4a58d47c.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先来放一张图, 表示HashMap的内部的一些原理<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709686597764-a49cd6bf-1f00-4f81-a76c-3fc7282a752d.png#averageHue=%23afe18e&clientId=u7cf2bead-790a-4&from=ui&id=u4cd5a5ed&originHeight=1994&originWidth=2389&originalType=binary&ratio=2&rotation=0&showTitle=false&size=963091&status=done&style=none&taskId=ua5e5049a-0fda-4f0d-ade2-14d59e4682c&title=" alt="HashMap.png"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在本节中，我们将深入研究手写的HashMap实现，名为<strong>MyHashMap</strong>。我们将逐步解释其结构和工作原理，并对关键方法进行讲解。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709688599661-99d68e2c-c718-4022-9424-8832ebaff227.png#averageHue=%23e6e6e6&clientId=uad531aa4-9975-4&from=paste&height=820&id=uf675b92e&originHeight=1640&originWidth=2122&originalType=binary&ratio=2&rotation=0&showTitle=false&size=280363&status=done&style=none&taskId=u14bbd1f5-e0d7-4994-9643-1afea7a9e6b&title=&width=1061" alt="image.png"><br>( 此图来自：<a href="https://pdai.tech/md/java/collection/java-map-HashMap&HashSet.html">https://pdai.tech/md/java/collection/java-map-HashMap&HashSet.html</a>）</p><h2 id="MyHashMap的基础知识"><a href="#MyHashMap的基础知识" class="headerlink" title="MyHashMap的基础知识"></a>MyHashMap的基础知识</h2><h2 id="创建HashMap的基本结构"><a href="#创建HashMap的基本结构" class="headerlink" title="创建HashMap的基本结构"></a>创建HashMap的基本结构</h2><p><strong>MyHashMap</strong>的核心结构是一个数组，数组中的每个元素是一个链表的头节点，用于存储哈希冲突的键值对。</p><pre><code>javaCopy codeprivate Node&lt;K, V&gt;[] table;</code></pre><h2 id="哈希节点的定义"><a href="#哈希节点的定义" class="headerlink" title="哈希节点的定义"></a>哈希节点的定义</h2><p><strong>Node</strong>类用于表示链表节点，存储键、值、哈希码，以及指向下一个节点的引用。</p><pre><code class="java">static class Node&lt;K, V&gt; &#123;    int hash;    K key;    V value;    Node next;    // 构造方法和toString方法&#125;</code></pre><h2 id="put方法实现"><a href="#put方法实现" class="headerlink" title="put方法实现"></a>put方法实现</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709688633920-8178b4b6-7c01-4a41-8d7e-239522515220.png#averageHue=%23e4e4e4&clientId=uad531aa4-9975-4&from=paste&height=811&id=ub3cc6357&originHeight=1622&originWidth=1956&originalType=binary&ratio=2&rotation=0&showTitle=false&size=319547&status=done&style=none&taskId=u561e928f-5fbe-4078-b54e-f4961c03e73&title=&width=978" alt="image.png"><br>( 此图来自：<a href="https://pdai.tech/md/java/collection/java-map-HashMap&HashSet.html">https://pdai.tech/md/java/collection/java-map-HashMap&HashSet.html</a>）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709688047439-55e596e9-371e-4c17-9b9f-0bd0fb4161ed.png#averageHue=%23dfdddd&clientId=uad531aa4-9975-4&from=paste&height=538&id=uc5e0f5c3&originHeight=1076&originWidth=2006&originalType=binary&ratio=2&rotation=0&showTitle=false&size=211924&status=done&style=none&taskId=ufd2ca90b-ece2-4dbc-a616-b9448432ffe&title=&width=1003" alt="image.png"></p><pre><code class="java">public V put(K key, V value) &#123;    // 处理key为null的情况    if (key == null) &#123;        return putForNullKey(value);    &#125;    // 计算哈希值并获取索引位置    int index = Math.abs(key.hashCode()) % table.length;    Node&lt;K, V&gt; node = table[index];    // 如果对应位置上没有值    if (null == table[index]) &#123;        table[index] = new Node&lt;K, V&gt;(key.hashCode(), key, value, null);        size++;        return value;    &#125;    // 如果有链表    Node&lt;K, V&gt; pre = node;    while (node != null) &#123;        if (key.equals(node.key)) &#123;            // 如果键已存在，更新值并返回旧值            V oldValue = node.value;            node.value = value;            return oldValue;        &#125;        pre = node;        node = node.next;    &#125;    // 如果键不存在，将新节点添加到链表末尾    pre.next = new Node&lt;&gt;(key.hashCode(), key, value, null);    size++;    return value;&#125;</code></pre><p>在<strong>put</strong>方法中，我们首先处理了键为null的特殊情况，然后计算了键的哈希值，并根据取余操作找到对应的索引位置。接着，我们检查该位置是否已经有节点，如果没有，则直接创建新节点。如果已经有链表，我们遍历链表，查找是否存在相同的键，如果找到则更新其值，否则将新节点追加到链表末尾。</p><h2 id="putForNullKey方法实现"><a href="#putForNullKey方法实现" class="headerlink" title="putForNullKey方法实现"></a>putForNullKey方法实现</h2><pre><code class="java">private V putForNullKey(V value) &#123;Node&lt;K, V&gt; node = table[0];if (node == null) &#123;    // 如果对应位置上没有值，创建新节点    table[0] = new Node&lt;&gt;(0, null, value, null);    size++;    return value; // 返回新值&#125;// 说明有单向链表Node&lt;K, V&gt; pre = node;while (node != null) &#123;    if (node.key == null) &#123;        // 如果键已存在，更新值并返回旧值        V oldValue = node.value;        node.value = value;        return oldValue;    &#125;    pre = node;    node = node.next;&#125;// 如果键不存在，将新节点添加到链表末尾pre.next = new Node&lt;K, V&gt;(0, null, value, null);return value;  // 返回新值&#125;</code></pre><p><strong>putForNullKey</strong>方法用于处理键为null的情况。与<strong>put</strong>方法类似，我们首先判断是否已经有节点，如果没有，则创建新节点。如果有链表，我们遍历链表，查找是否存在null键，如果找到则更新其值，否则将新节点追加到链表末尾。</p><h2 id="get方法实现"><a href="#get方法实现" class="headerlink" title="get方法实现"></a>get方法实现</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709688417542-04cf80ba-0e65-4bae-8ae0-a0b2908f4c6f.png#averageHue=%23d8d7d6&clientId=uad531aa4-9975-4&from=paste&height=395&id=u146c0c82&originHeight=790&originWidth=1916&originalType=binary&ratio=2&rotation=0&showTitle=false&size=118849&status=done&style=none&taskId=ubbc1650c-d8e8-4255-8fcb-72ebec32a15&title=&width=958" alt="image.png"></p><pre><code class="java">public V get(K key) &#123;// key为nullif (null == key) &#123;    Node&lt;K, V&gt; node = table[0];    if (node == null) &#123;        return null;    &#125;    // 存在链表    while (node != null) &#123;        if (null == node.key) &#123;            // 如果找到null键，返回对应的值            return node.value;        &#125;        node = node.next;    &#125;&#125;// key不是nullint hash = key.hashCode();int index = Math.abs(hash % 16);Node&lt;K, V&gt; node = table[index];// 遍历链表查找键值对while (node != null) &#123;    if (node.key.equals(key)) &#123;        // 如果找到键，返回对应的值        return node.value;    &#125;    node = node.next;&#125;// 不存在keyreturn null;&#125;</code></pre><p>在<strong>get</strong>方法中，我们首先处理键为null的情况，遍历存储在索引0处的链表。如果键不为null，我们计算哈希值并获取索引位置，然后遍历对应的链表查找键值对。如果找到了相应的键，返回其对应的值，否则返回null。</p><h2 id="重写toString方法"><a href="#重写toString方法" class="headerlink" title="重写toString方法"></a>重写toString方法</h2><pre><code class="java">@Overridepublic String toString() &#123;    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; table.length; i++) &#123;        Node&lt;K, V&gt; node = table[i];        while (node != null) &#123;            sb.append(node);            node = node.next;        &#125;    &#125;    return sb.toString();&#125;</code></pre><p><strong>toString</strong>方法用于输出<strong>MyHashMap</strong>的字符串表示形式。我们遍历数组中的每个链表，将节点的字符串表示逐个添加到<strong>StringBuilder</strong>中。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="java">public class MyHashMap&lt;K, V&gt; &#123;    private Node&lt;K, V&gt;[] table;    private int size;    public MyHashMap() &#123;        this.table = new Node[16];    &#125;    static class Node&lt;K, V&gt; &#123;        int hash;        K key;        V value;        Node next;        @Override        public String toString() &#123;            return new StringBuilder()                    .append(&quot;[&quot;)                    .append(key)                    .append(&quot;,&quot;)                    .append(value)                    .append(&quot;]&quot;)                    .toString();        &#125;        public Node(int hash, K key, V value, Node next) &#123;            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        &#125;    &#125;    public V put(K key, V value) &#123;        // 处理key为null的情况        if (key == null) &#123;            return putForNullKey(value);        &#125;        // 不为null，取对应位置        int index = Math.abs(key.hashCode()) % table.length;        Node&lt;K, V&gt; node = table[index];        // 如果对应位置上没有值        if (null == table[index]) &#123;            table[index] = new Node&lt;K, V&gt;(key.hashCode(), key, value, null);            size++;            return value;        &#125;        // 如果有链表        Node&lt;K, V&gt; pre = node;        while (node != null) &#123;            if (key.equals(node.key)) &#123;                V oldValue = node.value;                node.value = value;                return oldValue;            &#125;            pre = node;            node = node.next;        &#125;        pre.next = new Node&lt;&gt;(key.hashCode(), key, value, null);        size++;        return value;    &#125;    private V putForNullKey(V value) &#123;        Node&lt;K, V&gt; node = table[0];        if (node == null) &#123;            table[0] = new Node&lt;&gt;(0, null, value, null);            size++;            return value; // 返回新值        &#125;        // 说明有单向链表        Node&lt;K, V&gt; pre = node;        while (node != null) &#123;            if (node.key == null) &#123;                V oldValue = node.value;                node.value = value; // 覆盖原有的值                return oldValue;            &#125;            pre = node;            node = node.next;        &#125;        // node为null后        pre.next = new Node&lt;K, V&gt;(0, null, value, null);        return value;  // 返回新值    &#125;    /**     * get方法     */    public V get(K key) &#123;        // key为null        if (null == key) &#123;            Node&lt;K, V&gt; node = table[0];            if (node == null) &#123;                return null;            &#125;            // 存在链表            while (node != null) &#123;                if (null == node.key) &#123;                    return node.value;                &#125;                node = node.next;            &#125;        &#125;        // key不是null        int hash = key.hashCode();        int index = Math.abs(hash % 16);        Node&lt;K, V&gt; node = table[index];        while (node != null) &#123;            if (node.key.equals(key)) &#123;                return node.value;            &#125;            node = node.next;        &#125;        // 不存在key        return null;    &#125;    /**     * 重写toString方法，输出map集合时会调用     *     * @return     */    @Override    public String toString() &#123;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; table.length; i++) &#123;            Node&lt;K, V&gt; node = table[i];            while (node != null) &#123;                sb.append(node);                node = node.next;            &#125;        &#125;        return sb.toString();    &#125;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1709693463718-14b50b1c-ad20-49eb-84ab-8204df285979.png?x-oss-process=image/resize,w_750,limit_0" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本节中，我们深入了解了<strong>MyHashMap</strong>的实现。我们介绍了其基本结构、<strong>put</strong>和<strong>get</strong>方法的实现，以及特殊情况下的处理。</p><blockquote><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，其由 数组+链表+红黑树组成，我们目前只实现了数组+链表的结构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还迷糊事务的并发问题以及隔离级别？</title>
      <link href="/posts/5fdd80a8.html"/>
      <url>/posts/5fdd80a8.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="还迷糊事务的并发问题以及隔离级别？"><a href="#还迷糊事务的并发问题以及隔离级别？" class="headerlink" title="还迷糊事务的并发问题以及隔离级别？"></a>还迷糊事务的并发问题以及隔离级别？</h1><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p><ul><li>脏读</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c310b3ff1d43855291560c1dde074245.png" alt="img"></p><p>因为A回滚， B读取的内容出现问题</p><ul><li>不可重复读</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6ad67464336fa8559b2c614ecae674e7.png" alt="img"></p><p>因为B修改后提交事务， A读取的内容出现问题</p><ul><li>幻读</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/1ea1122c84454ad88ce75852ac19f6a9.png" alt="img"></p><p>解决了不可重复读问题之后，前后读的内容一样，导致在别的事务提交修改后，出现幻读。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/0546e8e0a4ed1263a024c10cfad9b214.png" alt="img"></p><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p>这三个现象的严重性排序如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/98719422fb359ff61694f5e1cdd7c72b.png" alt="img"></p><pre><code class="java">--查看事务隔离级别select @@transaction_isolation;</code></pre><ul><li><strong>读未提交（</strong><em><strong>read uncommitted</strong></em><strong>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（</strong><em><strong>read committed</strong></em><strong>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（</strong><em><strong>repeatable read</strong></em><strong>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化</strong>（<em><strong>serializable</strong></em> <strong>）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>按隔离水平高低排序如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/04a6fc00e0619eaad0436c6a1f46f694.png" alt="img"></p><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/08db1fde6f13700386b4ec7eeefde9d8.png" alt="img"></p><ul><li>脏读演示</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/042f17be66edcb25f68a040fb576ad81.png" alt="img"></p><p>解决：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/586712fe8551838bb5462b73b8da81ee.png" alt="img"></p><ul><li>不可重复读</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/43a19a245244d4f64a4a0841e1ee9d44.png" alt="img"></p><p>解决：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/005798c149f06bfec7a16c8ab8347fda.png" alt="img"></p><ul><li>幻读</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/1b7801aab8da92c3b4b9243c89d77933.png" alt="img"></p><p>解决：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/39016bd9092d25b975364f5a46c2edb7.png" alt="img"></p><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p><p>参考：<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7</a></p><p>【黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括】 <a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?p=55&share_source=copy_web&vd_source=fcae3ca58a4c2446a58b5aaacbaa4bbe">https://www.bilibili.com/video/BV1Kr4y1i7ru/?p=55&amp;share_source=copy_web&amp;vd_source=fcae3ca58a4c2446a58b5aaacbaa4bbe</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常见问题</title>
      <link href="/posts/c31889ef.html"/>
      <url>/posts/c31889ef.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-JVM组成"><a href="#1-JVM组成" class="headerlink" title="1 JVM组成"></a>1 JVM组成</h2><h3 id="1-1-JVM由那些部分组成，运行流程是什么？"><a href="#1-1-JVM由那些部分组成，运行流程是什么？" class="headerlink" title="1.1 JVM由那些部分组成，运行流程是什么？"></a>1.1 JVM由那些部分组成，运行流程是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><strong>JVM是什么</strong></p><p>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</p><p>好处：</p><ul><li>一次编写，到处运行 </li><li>自动内存管理，垃圾回收机制</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729142-a43adb48-6f38-48ae-abf3-fb0d7fa313e7.png#averageHue=%23e2c8c7&id=XxRfQ&originHeight=346&originWidth=384&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>JVM由哪些部分组成，运行流程是什么？</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729234-2f0b0252-bb6f-4fda-8239-a4c5a20e2b30.png#averageHue=%23e6e2d8&id=hk6mw&originHeight=756&originWidth=1499&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>从图中可以看出 JVM 的主要组成部分</p><ul><li>ClassLoader（类加载器）</li><li>Runtime Data Area（运行时数据区，内存分区）</li><li>Execution Engine（执行引擎）</li><li>Native Method Library（本地库接口）</li></ul><p>运行流程：</p><p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p><p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><h3 id="1-2-什么是程序计数器？"><a href="#1-2-什么是程序计数器？" class="headerlink" title="1.2 什么是程序计数器？"></a>1.2 什么是程序计数器？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>程序计数器：线程私有的（每一个线程内部都有一个程序计数器），内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p><blockquote><p>javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729317-1fcfa81f-9eb4-4a00-861f-8b3af3ba19d5.png#averageHue=%23faf9f8&id=hLtXU&originHeight=585&originWidth=1073&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><pre><code>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</code></pre><h3 id="1-3-你能给我详细的介绍Java堆吗"><a href="#1-3-你能给我详细的介绍Java堆吗" class="headerlink" title="1.3 你能给我详细的介绍Java堆吗?"></a>1.3 你能给我详细的介绍Java堆吗?</h3><blockquote><p>Java堆事线程共享的区域，主要用来保存实例、数组等， 当堆中没有内存空间可分配给实例，也无法扩展的时候，会抛出OOM异常。</p></blockquote><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729394-343176a9-68e7-4b04-9f85-86579c7387c6.png#averageHue=%23ece1e0&id=pofoo&originHeight=427&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li><li>元空间保存的类信息、静态变量、常量、编译后的代码</li></ul><p>为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729469-cd806377-b488-45b1-9ed8-697262f0dfef.png#averageHue=%23eadfdf&id=WzSt8&originHeight=600&originWidth=1551&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h5 id="元空间-MetaSpace-介绍"><a href="#元空间-MetaSpace-介绍" class="headerlink" title="元空间(MetaSpace)介绍"></a>元空间(MetaSpace)介绍</h5><pre><code>在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</code></pre><p>官网给出了解释：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p><pre><code>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</code></pre><p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p><p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p><pre><code>准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如**类元信息、字段、静态属性、方法、常量**等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</code></pre><h3 id="1-4-什么是虚拟机栈"><a href="#1-4-什么是虚拟机栈" class="headerlink" title="1.4 什么是虚拟机栈"></a>1.4 什么是虚拟机栈</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出 </li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729545-a14e6f5c-1987-4a39-9001-6c4e3b3956cb.png#averageHue=%23f9f4f4&id=vkn41&originHeight=455&originWidth=701&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>垃圾回收是否涉及栈内存？</strong><br>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放 </li><li><strong>栈内存分配越大越好吗？</strong><br>未必，默认的栈内存通常为1024k（1M）<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半 </li><li>**方法内的局部变量是否线程安全？ **<ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的 </li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 </li><li>比如以下代码：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729612-f3685b80-637a-4844-9c26-e43969c176e7.png#averageHue=%23eaefdb&id=KDJEA&originHeight=550&originWidth=473&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li></ul></li></ol><p><strong>栈内存溢出情况</strong></p><ul><li>栈帧过多导致栈内存溢出，典型问题：递归调用<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729683-a7597118-5444-4be5-bc89-764f1a20c9e7.png#averageHue=%23f2eded&id=WJV1E&originHeight=98&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="1-5-堆和栈的区别"><a href="#1-5-堆和栈的区别" class="headerlink" title="1.5 堆和栈的区别"></a>1.5 堆和栈的区别</h3><blockquote><p>难易程度：☆☆☆<br>方面：<strong>线程是否私有， 异常， 处理的问题</strong><br>出现频率：☆☆☆</p></blockquote><blockquote><p>堆主要是解决实例管理的问题，<br>栈解决的是程序运行的问题<br>本地方法栈与栈功能相同，是一个Java调用接口调用非Java的代码</p><ul><li><strong>栈内存</strong>一般会用来存储局部变量和方法调用，但<strong>堆内存</strong>是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</li><li><strong>栈内存</strong>是线程私有的，而<strong>堆内存</strong>是线程共有的。</li><li><strong>两者异常错误不同</strong>，但如果栈内存或者堆内存不足都会抛出异常。<br>栈空间不足：java.lang.StackOverFlowError。<br>堆空间不足：java.lang.OutOfMemoryEr</li></ul></blockquote><p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p><p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。<br>2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。<br>3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。<br>4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。<br>5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p><h3 id="1-6-能不能解释一下方法区？"><a href="#1-6-能不能解释一下方法区？" class="headerlink" title="1.6 能不能解释一下方法区？"></a>1.6 能不能解释一下方法区？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h4><ul><li>方法区(Method Area)是各个线程共享的内存区域 </li><li>主要存储类的信息、运行时常量池 </li><li>虚拟机启动的时候创建，关闭虚拟机时释放 </li><li>如果<strong>方法区域中的内存无法满足分配请求</strong>，则会抛出OutOfMemoryError: <strong>Metaspace</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729754-e763e80c-cbcb-441b-9ba1-858cce328864.png#averageHue=%23f7eae8&id=LmdtQ&originHeight=352&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="1-5-2-常量池"><a href="#1-5-2-常量池" class="headerlink" title="1.5.2 常量池"></a>1.5.2 常量池</h4><p><strong>可以看作是一张表</strong>，虚拟机指令根据这张常量表找到要执行的<strong>类名、方法名、参数类型、字面量</strong>等信息</p><p>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p><p>比如下面是一个Application类的main方法执行，源码如下：</p><pre><code class="java">public class Application &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;hello world&quot;);    &#125;&#125;</code></pre><p>找到类对应的class文件存放目录，执行命令：<code>javap -v Application.class</code>   查看字节码结构</p><pre><code class="java">D:\code\jvm-demo\target\classes\com\heima\jvm&gt;javap -v Application.classClassfile /D:/code/jvm-demo/target/classes/com/heima/jvm/Application.class  Last modified 2023-05-07; size 564 bytes    //最后修改的时间  MD5 checksum c1b64ed6491b9a16c2baab5061c64f88   //签名  Compiled from &quot;Application.java&quot;   //从哪个源码编译public class com.heima.jvm.Application   //包名，类名  minor version: 0  major version: 52     //jdk版本  flags: ACC_PUBLIC, ACC_SUPER  //修饰符Constant pool:   //常量池   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #23            // hello world   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #26            // com/heima/jvm/Application   #6 = Class              #27            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               LocalVariableTable  #12 = Utf8               this  #13 = Utf8               Lcom/heima/jvm/Application;  #14 = Utf8               main  #15 = Utf8               ([Ljava/lang/String;)V  #16 = Utf8               args  #17 = Utf8               [Ljava/lang/String;  #18 = Utf8               SourceFile  #19 = Utf8               Application.java  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #21 = Class              #28            // java/lang/System  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;  #23 = Utf8               hello world  #24 = Class              #31            // java/io/PrintStream  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V  #26 = Utf8               com/heima/jvm/Application  #27 = Utf8               java/lang/Object  #28 = Utf8               java/lang/System  #29 = Utf8               out  #30 = Utf8               Ljava/io/PrintStream;  #31 = Utf8               java/io/PrintStream  #32 = Utf8               println  #33 = Utf8               (Ljava/lang/String;)V&#123;  public com.heima.jvm.Application();  //构造方法    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 3: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/heima/jvm/Application;  public static void main(java.lang.String[]);  //main方法    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #3                  // String hello world         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 7: 0        line 8: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  args   [Ljava/lang/String;&#125;SourceFile: &quot;Application.java&quot;</code></pre><p>下图，左侧是main方法的指令信息，右侧constant pool  是常量池</p><p>main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729824-54560ff6-8a35-4a58-8b11-9768fb2d4e95.png#averageHue=%23f7f4f2&id=ycQYo&originHeight=462&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="1-5-3-运行时常量池"><a href="#1-5-3-运行时常量池" class="headerlink" title="1.5.3 运行时常量池"></a>1.5.3 运行时常量池</h4><p>常量池是 *.class 文件中的，当该<strong>类被加载，它的常量池信息就会放入运行时常量池</strong>，并把里面的符号地址变为真实地址</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729899-29ff9193-e307-48f3-b727-ee907b8ff6dd.png#averageHue=%23f7f3f2&id=XOTMm&originHeight=498&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-7-你听过直接内存吗？"><a href="#1-7-你听过直接内存吗？" class="headerlink" title="1.7 你听过直接内存吗？"></a>1.7 你听过直接内存吗？</h3><ul><li>并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存</li><li>常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高（减少了从系统内存到Java堆内存的拷贝），不受JVM内存回收管理</li></ul><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p><p>举例：</p><p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656729982-ce4bbe25-6fd5-47dc-a39b-f6cc1429bcf6.png#averageHue=%23f9f6f6&id=RiGOC&originHeight=254&originWidth=862&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>代码如下：</p><pre><code class="java">/** * 演示 ByteBuffer 作用 */public class Demo1_9 &#123;    static final String FROM = &quot;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;;    static final String TO = &quot;E:\\a.mp4&quot;;    static final int _1Mb = 1024 * 1024;    public static void main(String[] args) &#123;        io(); // io 用时：1535.586957 1766.963399 1359.240226        directBuffer(); // directBuffer 用时：479.295165 702.291454 562.56592    &#125;    private static void directBuffer() &#123;        long start = System.nanoTime();        try (FileChannel from = new FileInputStream(FROM).getChannel();             FileChannel to = new FileOutputStream(TO).getChannel();        ) &#123;            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);            while (true) &#123;                int len = from.read(bb);                if (len == -1) &#123;                    break;                &#125;                bb.flip();                to.write(bb);                bb.clear();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        long end = System.nanoTime();        System.out.println(&quot;directBuffer 用时：&quot; + (end - start) / 1000_000.0);    &#125;    private static void io() &#123;        long start = System.nanoTime();        try (FileInputStream from = new FileInputStream(FROM);             FileOutputStream to = new FileOutputStream(TO);        ) &#123;            byte[] buf = new byte[_1Mb];            while (true) &#123;                int len = from.read(buf);                if (len == -1) &#123;                    break;                &#125;                to.write(buf, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        long end = System.nanoTime();        System.out.println(&quot;io 用时：&quot; + (end - start) / 1000_000.0);    &#125;&#125;io用时：182.7593directBuffer用时：98.4438T</code></pre><p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p><p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730051-579d6bae-b1de-483a-8b95-b28c91458a63.png#averageHue=%23e9d8d7&id=zrFzQ&originHeight=461&originWidth=1163&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730125-a0696157-c2e2-4be5-8a76-eb77b1fc03ea.png#averageHue=%23e9dad9&id=RuSSO&originHeight=460&originWidth=1163&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-8-堆栈的区别是什么？"><a href="#1-8-堆栈的区别是什么？" class="headerlink" title="1.8 堆栈的区别是什么？"></a>1.8 堆栈的区别是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>2、栈内存是线程私有的，而堆内存是线程共有的。</p><p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><h3 id="2-1-什么是类加载器，类加载器有哪些"><a href="#2-1-什么是类加载器，类加载器有哪些" class="headerlink" title="2.1 什么是类加载器，类加载器有哪些?"></a>2.1 什么是类加载器，类加载器有哪些?</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730221-063c349c-63d0-41be-b3e3-d9732d7dc6e0.png#averageHue=%23f2e2b3&id=GhjfB&originHeight=522&originWidth=1113&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>类加载器：用于装载字节码文件(.class文件)</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li></ul><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的主要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p><p><strong>类加载器种类</strong></p><p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><strong>启动类加载器(BootStrap ClassLoader)：</strong><br>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。 </li><li><strong>扩展类加载器(ExtClassLoader)：</strong><br>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。 </li><li><strong>应用类加载器(AppClassLoader)：</strong><br>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。 </li><li><strong>自定义类加载器：</strong><br>开发者自定义类继承ClassLoader，实现自定义类加载规则。</li></ul><p>上述三种类加载器的层次结构如下如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730288-844cc45c-f325-43d5-af09-eeb54810d792.png#averageHue=%23f1ded6&id=Qo2At&originHeight=646&originWidth=716&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p><h3 id="2-2-什么是双亲委派模型？"><a href="#2-2-什么是双亲委派模型？" class="headerlink" title="2.2 什么是双亲委派模型？"></a>2.2 什么是双亲委派模型？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，<strong>依次递归，</strong>如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730363-c2bf9eb2-b0b9-4494-aae2-c09818db6b27.png#averageHue=%23e9c3b3&id=Dzm3i&originHeight=630&originWidth=418&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="2-3-JVM为什么采用双亲委派机制"><a href="#2-3-JVM为什么采用双亲委派机制" class="headerlink" title="2.3 JVM为什么采用双亲委派机制"></a>2.3 JVM为什么采用双亲委派机制</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>（2）为了安全，保证类库API不会被修改</p><p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p><pre><code class="java">public class String &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;demo info&quot;);    &#125;&#125;</code></pre><pre><code>此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730445-79fe8094-7785-410f-85ed-c4159a027b12.png#averageHue=%23f8f4f2&id=Wz7IC&originHeight=144&originWidth=934&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><pre><code>出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能**防止恶意篡改核心API库**。</code></pre><h3 id="2-4-说一下类装载的执行过程？"><a href="#2-4-说一下类装载的执行过程？" class="headerlink" title="2.4 说一下类装载的执行过程？"></a>2.4 说一下类装载的执行过程？</h3><blockquote><p>难易程度：☆☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为<strong>连接（linking）。</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730530-ae310bd0-1069-4410-8a66-dddeefb3aeec.png#averageHue=%23f9f6f6&id=lmmbi&originHeight=401&originWidth=1028&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>类加载过程详解</strong></p><p>1.加载</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730610-b75e92e1-18f3-45e2-9737-3870c1dc355e.png#averageHue=%23f4e6e6&id=ywwc6&originHeight=171&originWidth=1229&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>通过类的全名，获取类的**二进制数据流。 **</li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型） </li><li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730698-2b1d500b-63d9-4941-9c36-08d4d4a107fd.png#averageHue=%23f3e3e1&id=Xm7ts&originHeight=395&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>2.验证</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730775-2ae53548-3e51-48b6-8455-17abcb9f83dd.png#averageHue=%23f4e8e8&id=fxQ56&originHeight=180&originWidth=1230&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>验证类是否符合JVM规范，安全性检查</strong></p><p>(1)文件格式验证:是否符合<strong>Class文件的规范</strong><br>(2)元数据验证<br>这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）<br>这个类是否继承（extends）了被<strong>final</strong>修饰过的类（被final修饰过的类表示类不能被继承）<br>类中的字段、方法是否与<strong>父类产生矛盾</strong>。（被final修饰过的方法或字段是不能覆盖的）<br>(3)字节码验证<br>主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。<br>(4)<strong>符号引用验证</strong>：符号引用以一组符号来描述所引用的目标（判断是否存在），符号可以是任何形式的字面量</p><blockquote><p>比如：int i &#x3D; 3;<br>字面量：3<br>符号引用：i</p></blockquote><p>3.准备</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730849-416c9323-e9f8-4e46-8011-8c1abc1da575.png#averageHue=%23f5eaea&id=V4Pco&originHeight=197&originWidth=1233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>为类变量分配内存并设置类变量初始值</strong></p><ul><li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成 </li><li>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成 </li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730922-275cf962-1c66-4a9d-95e9-9216f9f3901e.png#averageHue=%23eaf0dc&id=Il5Jk&originHeight=193&originWidth=442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>4.解析</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656730989-321d78e6-e215-44fa-a19d-21ee3a55c44b.png#averageHue=%23f5e9e9&id=BRzUj&originHeight=188&originWidth=1249&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>把类中的符号引用转换为直接引用</strong></p><p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731062-e4d1cfe1-2526-44ae-8d10-842bf7de1cbf.png#averageHue=%23f8f7f7&id=CL8Qu&originHeight=430&originWidth=1193&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>5.初始化</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731141-c0a26042-dfeb-4bd1-b3a3-35f2ec6447a0.png#averageHue=%23f4e8e8&id=RWd1l&originHeight=180&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>对类的静态变量，静态代码块执行初始化操作</strong><br><strong>前面的准备阶段做的是复制默认的便利，比如0，null,</strong><br><strong>这个阶段则是赋值变量所期待的值</strong></p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。 </li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li></ul><p>6.使用</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731219-4fb8b95f-42eb-40a7-9d75-e4c4d7d70626.png#averageHue=%23f3e6e6&id=pwxcB&originHeight=167&originWidth=1236&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>JVM 开始从入口方法开始执行用户的程序代码</p><ul><li>调用静态类成员信息（比如：静态字段、静态方法） </li><li>使用new关键字为其创建对象实例</li></ul><p>7.卸载</p><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><h2 id="3-垃圾收回"><a href="#3-垃圾收回" class="headerlink" title="3 垃圾收回"></a>3 垃圾收回</h2><h3 id="3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）"><a href="#3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）" class="headerlink" title="3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）"></a>3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p><p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p><h3 id="3-2-对象什么时候可以被垃圾器回收"><a href="#3-2-对象什么时候可以被垃圾器回收" class="headerlink" title="3.2 对象什么时候可以被垃圾器回收"></a>3.2 对象什么时候可以被垃圾器回收</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731337-6e69bdb0-392a-4a18-ab82-3675c7b235ce.png#averageHue=%23e4e5d0&id=lvfN8&originHeight=548&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h4 id="3-2-1-引用计数法"><a href="#3-2-1-引用计数法" class="headerlink" title="3.2.1 引用计数法"></a>3.2.1 引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p><pre><code class="java">String demo = new String(&quot;123&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731417-23dfd02f-9d7a-4281-9cc6-feaf1fea6c3b.png#averageHue=%23faf5f5&id=XRa3R&originHeight=466&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><pre><code class="java">String demo = null;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731493-7222f863-32bf-4146-84cd-c82594369c33.png#averageHue=%23f9f5f5&id=C725C&originHeight=460&originWidth=989&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>当对象间出现了循环引用的话，则引用计数法就会失效</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731622-d7499443-9ec6-432a-80fd-820b0280f4a3.png#averageHue=%23e8eedb&id=ImlQ5&originHeight=261&originWidth=1299&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>先执行右侧代码的前4行代码</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731690-16aeb998-fd5f-4f9f-9121-eb123cee5da4.png#averageHue=%23f7efed&id=YDMgr&originHeight=454&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>目前上方的引用关系和计数都是没问题的，但是，如果代码继续往下执行，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731766-9d5b2ee8-5547-4330-a517-c2770ad89f7c.png#averageHue=%23f8f2f1&id=KHNBi&originHeight=713&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p><p>优点：</p><ul><li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li><li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li><li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li><li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点）</li></ul><h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h4><pre><code>现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</code></pre><blockquote><p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p><p>局部变量，静态方法，静态变量，类信息</p><p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731851-c04fb99e-1cf3-4558-924a-6a5f856dcdbf.png#averageHue=%23f6f0ea&id=mJ87Z&originHeight=593&originWidth=436&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><pre><code>X,Y这两个节点是可回收的，但是**并不会马上的被回收！！** 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先**会判断这个对象是否执行了finalize方法**，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</code></pre><p><strong>GC ROOTS：</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li></ul><p>“局部变量的引用存储在虚拟机栈中，而对象存储在堆中。”</p><pre><code class="java">/** * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。 */public class Demo &#123;    public static  void main(String[] args) &#123;        Demo demo = new Demo();        demo = null;    &#125;&#125;</code></pre><ul><li>方法区中类静态属性引用的对象</li></ul><p>“静态变量的引用通常存储在元空间，而对象仍然存储在堆中。”</p><pre><code class="java">/** * 当栈帧中的本地变量 b = null 时， * 由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接， * 所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用， * a在此时是类静态属性引用，充当了 GC Root 的作用， * 它指向的对象依然存活! */public class Demo &#123;    public static Demo a;    public static  void main(String[] args) &#123;        Demo b = new Demo();        b.a = new Demo();        b = null;    &#125;&#125;</code></pre><ul><li>方法区中常量引用的对象</li></ul><p>常量和这里的demo没有什么关系，所以不会因为demo指向的对象被回收而回收</p><pre><code class="java">/** * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收 */public class Demo &#123;        public static final Demo a = new Demo();        public static  void main(String[] args) &#123;        Demo demo = new Demo();        demo = null;    &#125;&#125;</code></pre><ul><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><p>“ &#x2F;&#x2F; 只要 nativeMethod 还持有它的引用，它就不会被垃圾回收。”</p><h3 id="3-3-JVM-垃圾回收算法有哪些？"><a href="#3-3-JVM-垃圾回收算法有哪些？" class="headerlink" title="3.3 JVM 垃圾回收算法有哪些？"></a>3.3 JVM 垃圾回收算法有哪些？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="3-3-1-标记清除算法"><a href="#3-3-1-标记清除算法" class="headerlink" title="3.3.1 标记清除算法"></a>3.3.1 标记清除算法</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p><p>1.根据可达性分析算法得出的垃圾进行标记</p><p>2.对这些标记为可回收的内容进行垃圾回收</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656731937-9ce82623-8441-4d42-b671-e00cd42b7c38.png#averageHue=%23edecec&id=HYL13&originHeight=469&originWidth=1555&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p><p>同样，标记清除算法也是有缺点的：</p><ul><li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul><h4 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2 复制算法"></a>3.3.2 复制算法</h4><pre><code>复制算法的核心就是，**将原有的内存空间一分为二，每次只用其中的一块**，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732009-de643a46-6d2d-4696-97db-4fcc24d07c7e.png#averageHue=%23e1e6d6&id=vqvaq&originHeight=467&originWidth=1663&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>1）将内存区域分成两部分，每次操作其中一个。</p><p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p><p>3）周而复始。</p><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><ul><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li><li>对于存活率高的对象进行复制就会非常消耗时间</li></ul><h4 id="3-3-3-标记整理算法"><a href="#3-3-3-标记整理算法" class="headerlink" title="3.3.3 标记整理算法"></a>3.3.3 标记整理算法</h4><pre><code>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732079-2c2113db-d739-465b-b688-b0a5de10fc30.png#averageHue=%23ebebeb&id=F1aSz&originHeight=452&originWidth=1625&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>1）标记垃圾。</p><p>2）需要清除向右边走，不需要清除的向左边走。</p><p>3）清除边界以外的垃圾。</p><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p><p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理<br>如上三种GC算法则是JVM虚拟机的基础GC算法，综合对比来看：</p><ul><li>收集速度：复制算法 &gt; 标-清算法 &gt; 标-整算法</li><li>内存整齐度：复制算法 &#x3D; 标-整算法 &gt; 标-清算法</li><li>内存利用率：标-整算法 &gt; 标-清算法 &gt; 复制算法</li></ul><p>在GC算法中，速度快的需要用空间来换，空间利用率高且整齐度高的，则需要牺牲时间来换取，所以相对而言，在绝大部分算法中，<strong>时间与空间不可兼得</strong>。<br>在上述三种算法中，复制算法和标-整算法都是基于标-清算法进行优化的，所以在现代的高性能JVM中绝大多数虚拟机都采用复制或标-整算法进行垃圾收集工作。</p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>说一下JM中的分代回收一、堆的区域划分</p><ol><li>堆被分为了两份：新生代和老年代【1:2】</li><li>对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor（分成from和to）【8:1:1】</li></ol><p>  二、对象回收分代回收策略</p><ol start="3"><li>新创建的对象，都会先分配到eden区</li><li>当伊甸园内存不足，标记伊甸园与from（现阶段没有）的存活对象</li><li>将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和 from 内存都得到释放</li><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区</li><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会提前晋升）</li></ol><p>MinorGC、Mixed GC、FullGC的区别是什么</p><ul><li>MinorGC 【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</li><li>Mixed GC新生代＋老年代部分区域的垃圾回收，G1 收集器特有</li><li>FWGC：新生代＋老年代完整垃圾回收，暂</li></ul><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732154-4897bc03-f6e3-460a-ac4e-376242925d89.png#averageHue=%23f9f5f5&id=onl7L&originHeight=276&originWidth=1102&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p><p>当对新生代产生GC：MinorGC【young GC】</p><p>当对老年代代产生GC：Major GC</p><p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h4 id="3-4-2工作机制"><a href="#3-4-2工作机制" class="headerlink" title="3.4.2工作机制"></a>3.4.2工作机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732227-10d9e726-1bac-485f-9b6e-f64566e00f7c.png#averageHue=%23eceae5&id=lWqeu&originHeight=223&originWidth=1162&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li><strong>新创建的对象，都会先分配到eden区</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732310-3c8342d3-cddd-4a6c-ba66-497ac07b1e51.png#averageHue=%23f3f2f2&id=wYjvB&originHeight=274&originWidth=1561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象 </li><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732391-be77ce11-3529-47cb-951a-3e15f47393d9.png#averageHue=%23f2f1f1&id=Pg6zv&originHeight=280&originWidth=1569&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732468-d16f58a6-ff89-4e52-92e1-a33f511b1185.png#averageHue=%23e8e4dd&id=edpFL&originHeight=271&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732546-b39d8bd8-432e-4f80-97a1-0f95de9b31b4.png#averageHue=%23f2f1f1&id=AoZhQ&originHeight=269&originWidth=1540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><p><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732628-2f83650e-40eb-437c-80fc-06a599cd9df6.png#averageHue=%23f9f4f4&id=JgvFr&originHeight=356&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW） </li><li>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有 </li><li>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？</li></ul><blockquote><p>名词解释：</p><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p></blockquote><h3 id="3-5-说一下-JVM-有哪些垃圾回收器？"><a href="#3-5-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="3.5 说一下 JVM 有哪些垃圾回收器？"></a>3.5 说一下 JVM 有哪些垃圾回收器？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>在jvm中，实现了多种垃圾收集器，包括：</p><ul><li>串行垃圾收集器：Serial GC、Serial Old GC</li><li>并行垃圾收集器：Parallel Old GC、ParNew GC</li><li>CMS （并发）垃圾收集器：CMS GC，作用在老年代</li><li>G1垃圾回收器</li></ul><h4 id="3-5-1-串行垃圾收集器"><a href="#3-5-1-串行垃圾收集器" class="headerlink" title="3.5.1 串行垃圾收集器"></a>3.5.1 串行垃圾收集器</h4><p>Serial和Serial Old串行垃圾收集器，是指<strong>使用单线程进行垃圾回收，堆内存较小</strong>，适合个人电脑</p><ul><li>Serial 作用于新生代，采用复制算法 </li><li>Serial Old 作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（<strong>STW</strong>），等待垃圾回收的完成。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732696-7edfa831-96db-459c-95c5-f7f975cd75f6.png#averageHue=%23ebe8e8&id=XYPr8&originHeight=296&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-5-2-并行垃圾收集器"><a href="#3-5-2-并行垃圾收集器" class="headerlink" title="3.5.2 并行垃圾收集器"></a>3.5.2 并行垃圾收集器</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li>Parallel New作用于新生代，采用复制算法 </li><li>Parallel Old作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，多个线程在工作，并<strong>且java应用中的所有线程都要暂停（STW）</strong>，等待垃圾回收的完成。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732773-a03e3245-34b1-4337-b53c-829803166d69.png#averageHue=%23f0eaea&id=TygK9&originHeight=296&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-5-2-CMS（并发）垃圾收集器"><a href="#3-5-2-CMS（并发）垃圾收集器" class="headerlink" title="3.5.2 CMS（并发）垃圾收集器"></a>3.5.2 CMS（并发）垃圾收集器</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732855-7e26a9f6-5e52-47ec-ba77-afb64f746c5c.png#averageHue=%23eee7e6&id=zHTg4&originHeight=296&originWidth=1135&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656732933-8cb32867-f528-48f9-9997-7794572b4ccf.png#averageHue=%23f0f0f0&id=OB2tN&originHeight=411&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="3-6-详细聊一下G1垃圾回收器"><a href="#3-6-详细聊一下G1垃圾回收器" class="headerlink" title="3.6 详细聊一下G1垃圾回收器"></a>3.6 详细聊一下G1垃圾回收器</h3><p>总结<br>详细聊一下G1垃圾回收器</p><ul><li>应用于新生代和老年代，在JDK9之后默认使用G1</li><li>划分成多个区域，每个区域都可以充当 eden,survivor,old,humongous<br>，其中 humongous 专为大对象准备</li><li>采用复制算法</li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：新生代回收（stw）、并发标记（重新标记stw）、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象</li></ul><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h4><ul><li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong> </li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备 </li><li>采用复制算法 </li><li>响应时间与吞吐量兼顾 </li><li>分成三个阶段：新生代回收、并发标记、混合收集 </li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733004-01d7461f-7c4e-46f5-b605-a5d3845b8bd7.png#averageHue=%23f1ece2&id=WxS8I&originHeight=445&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-6-2-Young-Collection-年轻代垃圾回收"><a href="#3-6-2-Young-Collection-年轻代垃圾回收" class="headerlink" title="3.6.2 Young Collection(年轻代垃圾回收)"></a>3.6.2 Young Collection(年轻代垃圾回收)</h4><ul><li>初始时，所有区域都处于空闲状态<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733078-1c78dec1-b878-4a19-8ca1-146257a65f66.png#averageHue=%23f7e5e5&id=GvYin&originHeight=437&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </li><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733171-d0db9d7c-0a22-4297-9989-4ecb22a3d0d9.png#averageHue=%23f7e4e4&id=JTNk4&originHeight=432&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </li><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733243-2582bcea-c063-45ec-9e11-072fa28f87d2.png#averageHue=%23f7e3e3&id=MCspK&originHeight=431&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733358-f8168fdb-1a37-4933-a095-df89096d456b.png#averageHue=%23f7e4e4&id=eps5g&originHeight=428&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </li><li>随着时间流逝，伊甸园的内存又有不足 </li><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733434-fb559900-9ae8-461f-b16c-2cc3c2446418.png#averageHue=%23f7e3e3&id=d0QU0&originHeight=433&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733507-938f570f-56f0-42c0-804d-96e3a988f7b8.png#averageHue=%23f6e2e1&id=Ii9yy&originHeight=429&originWidth=669&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733575-86697a72-3061-4e03-967c-51ce93775050.png#averageHue=%23f7e4e3&id=jB1gz&originHeight=430&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li></ul><h4 id="3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记"><a href="#3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记" class="headerlink" title="3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)"></a>3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</h4><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733658-ab2d5762-9d85-4753-844d-63168426091e.png#averageHue=%23f4cebf&id=PacpS&originHeight=425&originWidth=668&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。 </li><li>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733730-a4105a6c-ed0f-4ff2-8bdc-83ff709955bd.png#averageHue=%23f2ccbf&id=YoUBb&originHeight=429&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li></ul><h4 id="3-6-4-Mixed-Collection-混合垃圾回收"><a href="#3-6-4-Mixed-Collection-混合垃圾回收" class="headerlink" title="3.6.4 Mixed Collection (混合垃圾回收)"></a>3.6.4 Mixed Collection (混合垃圾回收)</h4><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733807-702dfda8-f548-4c07-a804-7416ce7a8e49.png#averageHue=%23f4d2c4&id=jmDLR&originHeight=430&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733875-b67d040e-41aa-4361-87ba-9fe9808a0217.png#averageHue=%23f4cbbd&id=uksWE&originHeight=419&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="3-7-强引用、软引用、弱引用、虚引用的区别？"><a href="#3-7-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="3.7 强引用、软引用、弱引用、虚引用的区别？"></a>3.7 强引用、软引用、弱引用、虚引用的区别？</h3><p>强引用、软引用、弱引用、虚引用的区别？</p><ul><li>强引用：只要所有 GC Roots 能找到，就不会被回收</li><li>软引用：需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象</li><li>弱引用：需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收</li><li>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引</li></ul><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="3-7-1-强引用"><a href="#3-7-1-强引用" class="headerlink" title="3.7.1 强引用"></a>3.7.1 强引用</h4><p>强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><pre><code class="java">User user = new User();</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656733941-59def2dc-68b9-4629-b987-9573a6604a23.png#averageHue=%23f4eded&id=J6TS9&originHeight=95&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-7-2-软引用"><a href="#3-7-2-软引用" class="headerlink" title="3.7.2 软引用"></a>3.7.2 软引用</h4><p>软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p><pre><code class="java">User user = new User();SoftReference softReference = new SoftReference(user);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734025-a81a4fb0-e0f0-4fe9-8ba1-0c221564c1e6.png#averageHue=%23f3ebeb&id=YR11J&originHeight=82&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-7-3-弱引用"><a href="#3-7-3-弱引用" class="headerlink" title="3.7.3 弱引用"></a>3.7.3 弱引用</h4><p>弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><pre><code class="java">User user = new User();WeakReference weakReference = new WeakReference(user);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734092-24ab0e89-7a1a-4a13-869c-6fd502c60248.png#averageHue=%23f2ebeb&id=e2yWd&originHeight=84&originWidth=785&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>延伸话题：ThreadLocal内存泄漏问题</p></blockquote><p>ThreadLocal用的就是弱引用，看以下源码：</p><pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;         super(k);         value = v; //强引用，不会被回收     &#125;&#125;</code></pre><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p><p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p><blockquote><p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p></blockquote><h4 id="3-7-4-虚引用"><a href="#3-7-4-虚引用" class="headerlink" title="3.7.4 虚引用"></a>3.7.4 虚引用</h4><p>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734165-dd3c47c6-f77f-48e7-864b-6813df5fd300.png#averageHue=%23eaefdb&id=wcciH&originHeight=92&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734230-88c43adf-0c3f-4469-beb7-96be731e881f.png#averageHue=%23f7f2f2&id=ghlO3&originHeight=328&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="4-JVM实践（调优）"><a href="#4-JVM实践（调优）" class="headerlink" title="4 JVM实践（调优）"></a>4 JVM实践（调优）</h2><h3 id="4-1-JVM-调优的参数可以在哪里设置参数值？"><a href="#4-1-JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="4.1 JVM 调优的参数可以在哪里设置参数值？"></a>4.1 JVM 调优的参数可以在哪里设置参数值？</h3><ul><li>难易程度：☆☆</li></ul><blockquote><p> 出现频率：☆☆☆</p></blockquote><h4 id="4-1-1-tomcat的设置vm参数"><a href="#4-1-1-tomcat的设置vm参数" class="headerlink" title="4.1.1 tomcat的设置vm参数"></a>4.1.1 tomcat的设置vm参数</h4><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p><p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;</code></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734302-772c8315-6ea3-4328-a49b-2bc16bdb7a40.png#averageHue=%23faf9f8&id=p72z2&originHeight=555&originWidth=1667&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="4-1-2-springboot项目jar文件启动"><a href="#4-1-2-springboot项目jar文件启动" class="headerlink" title="4.1.2 springboot项目jar文件启动"></a>4.1.2 springboot项目jar文件启动</h4><p>通常在linux系统下直接加参数启动springboot项目</p><pre><code class="shell">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</code></pre><blockquote><p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p><p>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h3 id="4-2-用的-JVM-调优的参数都有哪些？"><a href="#4-2-用的-JVM-调优的参数都有哪些？" class="headerlink" title="4.2 用的 JVM 调优的参数都有哪些？"></a>4.2 用的 JVM 调优的参数都有哪些？</h3><ul><li>设置堆空间大小</li><li>虚拟机栈的设置</li><li>年轻代中Eden区和两个Survivor区的大小比例</li><li>年轻代晋升老年代阈值</li></ul><blockquote></blockquote><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><pre><code>对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</code></pre><p><a href="https://_www.oracle.com_java_technologies_javase_vmoptions-jsp/">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p><p>1）<strong>设置堆的初始大小和最大大小</strong>，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><pre><code>-Xms：设置堆的初始化大小-Xmx：设置堆的最大大小</code></pre><p>2） <strong>设置年轻代中Eden区和两个Survivor区的大小比例</strong>。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><pre><code>-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</code></pre><p>3）<strong>年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</strong></p><pre><code>-XX:newSize   设置年轻代的初始大小-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</code></pre><p>4）<strong>线程堆栈的设置</strong>：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><pre><code>-Xss   对每个线程stack大小的调整,-Xss128k</code></pre><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使<strong>用-Xmn设置年轻代的大小</strong></p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><pre><code>（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</code></pre><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><pre><code>-XX:+LargePageSizeInBytes 设置内存页的大小</code></pre><p>10）使用非占用的垃圾收集器。</p><pre><code>-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</code></pre><h3 id="4-3-说一下-JVM-调优的工具？"><a href="#4-3-说一下-JVM-调优的工具？" class="headerlink" title="4.3 说一下 JVM 调优的工具？"></a>4.3 说一下 JVM 调优的工具？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="4-3-1-命令工具"><a href="#4-3-1-命令工具" class="headerlink" title="4.3.1 命令工具"></a>4.3.1 命令工具</h4><h5 id="4-3-1-1-jps（Java-Process-Status）"><a href="#4-3-1-1-jps（Java-Process-Status）" class="headerlink" title="4.3.1.1 jps（Java Process Status）"></a>4.3.1.1 jps（Java Process Status）</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734374-61741ff8-4098-407e-8ac7-70a4ab6d1118.png#averageHue=%23161311&id=ADLj3&originHeight=133&originWidth=278&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h5 id="4-3-1-2-jstack"><a href="#4-3-1-2-jstack" class="headerlink" title="4.3.1.2 jstack"></a>4.3.1.2 jstack</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><pre><code class="shell">jstack [option] &lt;pid&gt;</code></pre><p>java案例</p><pre><code class="java">package com.heima.jvm;public class Application &#123;    public static void main(String[] args) throws InterruptedException &#123;        while (true)&#123;            Thread.sleep(1000);            System.out.println(&quot;哈哈哈&quot;);        &#125;    &#125;&#125;</code></pre><p>使用jstack查看进行堆栈运行信息</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734449-788ae465-ada2-421e-8854-806facfc6794.png#averageHue=%231a1816&id=GbZNK&originHeight=792&originWidth=1256&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h5 id="4-3-1-3-jmap"><a href="#4-3-1-3-jmap" class="headerlink" title="4.3.1.3 jmap"></a>4.3.1.3 jmap</h5><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid  内存映像信息</p><p>jmap -heap pid   显示Java堆的信息</p><p>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid</p><pre><code>    format=b表示以hprof二进制格式转储Java堆的内存file=用于指定快照dump文件的文件名。</code></pre></blockquote><p>例：显示了某一个java运行的堆信息</p><pre><code class="java">C:\Users\yuhon&gt;jmap -heap 53280Attaching to process ID 53280, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.321-b07using thread-local object allocation.Parallel GC with 8 thread(s)   //并行的垃圾回收器Heap Configuration:  //堆配置   MinHeapFreeRatio         = 0   //空闲堆空间的最小百分比   MaxHeapFreeRatio         = 100  //空闲堆空间的最大百分比   MaxHeapSize              = 8524922880 (8130.0MB) //堆空间允许的最大值   NewSize                  = 178257920 (170.0MB) //新生代堆空间的默认值   MaxNewSize               = 2841640960 (2710.0MB) //新生代堆空间允许的最大值   OldSize                  = 356515840 (340.0MB) //老年代堆空间的默认值   NewRatio                 = 2 //新生代与老年代的堆空间比值，表示新生代：老年代=1：2   SurvivorRatio            = 8 //两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8   MetaspaceSize            = 21807104 (20.796875MB) //元空间的默认值   CompressedClassSpaceSize = 1073741824 (1024.0MB) //压缩类使用空间大小   MaxMetaspaceSize         = 17592186044415 MB //元空间允许的最大值   G1HeapRegionSize         = 0 (0.0MB)//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。Heap Usage:PS Young GenerationEden Space: //Eden使用情况   capacity = 134217728 (128.0MB)   used     = 10737496 (10.240074157714844MB)   free     = 123480232 (117.75992584228516MB)   8.000057935714722% usedFrom Space: //Survivor-From 使用情况   capacity = 22020096 (21.0MB)   used     = 0 (0.0MB)   free     = 22020096 (21.0MB)   0.0% usedTo Space: //Survivor-To 使用情况   capacity = 22020096 (21.0MB)   used     = 0 (0.0MB)   free     = 22020096 (21.0MB)   0.0% usedPS Old Generation  //老年代 使用情况   capacity = 356515840 (340.0MB)   used     = 0 (0.0MB)   free     = 356515840 (340.0MB)   0.0% used3185 interned Strings occupying 261264 bytes.</code></pre><h5 id="4-3-1-4-jhat"><a href="#4-3-1-4-jhat" class="headerlink" title="4.3.1.4 jhat"></a>4.3.1.4 jhat</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h5 id="4-3-1-5-jstat"><a href="#4-3-1-5-jstat" class="headerlink" title="4.3.1.5 jstat"></a>4.3.1.5 jstat</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p><p><strong>常见参数</strong>：</p><p>①总结垃圾回收统计</p><pre><code class="shell">jstat -gcutil pid</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734528-c33ee29e-81ee-4201-a4d3-ba0606b8ce7d.png#averageHue=%2312100f&id=uADT3&originHeight=74&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><p>②垃圾回收统计</p><pre><code class="shell">jstat -gc pid</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734597-c1c0a537-8959-4b17-aaa7-af547a4d73e3.png#averageHue=%2312100e&id=xEqG3&originHeight=78&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="4-3-2-可视化工具"><a href="#4-3-2-可视化工具" class="headerlink" title="4.3.2 可视化工具"></a>4.3.2 可视化工具</h4><h5 id="4-3-2-1-jconsole"><a href="#4-3-2-1-jconsole" class="headerlink" title="4.3.2.1 jconsole"></a>4.3.2.1 jconsole</h5><p>用于对<strong>jvm的内存，线程，类 的监控</strong>，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734710-3fa67532-04da-4088-a5db-f8c77d04b8d2.png#averageHue=%23bfe8e4&id=OdRjZ&originHeight=753&originWidth=890&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>可以内存、线程、类等信息</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734784-186219f7-7934-4288-9c15-80f41cae440f.png#averageHue=%23f7f7f7&id=iFKOC&originHeight=750&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>还可以在线程部分检查死锁问题</p><h5 id="4-3-2-2-VisualVM：故障处理工具"><a href="#4-3-2-2-VisualVM：故障处理工具" class="headerlink" title="4.3.2.2 VisualVM：故障处理工具"></a>4.3.2.2 VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656734895-4cb23de3-5684-452a-907b-f8e9e33bcee6.png#averageHue=%23f3f3f2&id=JR0XA&originHeight=750&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>监控程序运行情况</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735063-1d1a1b9d-5530-4e0e-a70e-f946a2abdfce.png#averageHue=%23f6f3f0&id=BsnhD&originHeight=968&originWidth=1911&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>查看运行中的dump</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735146-50a98c2c-ebf0-4bd0-ab1b-2e73c9b5f7e2.png#averageHue=%23f5f0ea&id=DoYD0&originHeight=566&originWidth=1521&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>查看堆中的信息</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735222-4b5a89ae-b0bc-4293-a7ce-419a57e240c5.png#averageHue=%23f7f7f6&id=BHNyd&originHeight=900&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="4-4-java内存泄露的排查思路？"><a href="#4-4-java内存泄露的排查思路？" class="headerlink" title="4.4 java内存泄露的排查思路？"></a>4.4 java内存泄露的排查思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>原因：</p><p>如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常</p><p>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常</p><p>如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735305-8053188d-e39a-43c5-8b60-bdbfadcafb2e.png#averageHue=%23f6f2ee&id=a542D&originHeight=471&originWidth=1233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>1、通过jmap指定打印他的内存快照 dump</p><blockquote><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p><p>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;app&#x2F;dumps&#x2F;      指定生成后文件的保存目录</p></blockquote><p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p><p>VisualVM可以加载离线的dump文件，如下图</p><p>文件–&gt;装入—&gt;选择dump文件即可查看堆快照信息</p><blockquote><p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735427-9096a534-722c-4331-8673-fab9156f8191.png#averageHue=%23f3f2f1&id=TtCgS&originHeight=435&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735508-3e4e2045-0e7e-430f-9138-7ffeae72e088.png#averageHue=%23f7f7f6&id=i7ezy&originHeight=770&originWidth=874&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p><h3 id="4-5-CPU飙高排查方案与思路？"><a href="#4-5-CPU飙高排查方案与思路？" class="headerlink" title="4.5 CPU飙高排查方案与思路？"></a>4.5 CPU飙高排查方案与思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1.使用top命令查看占用cpu的情况</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735579-f1b24ff1-a44c-4edc-bb19-9a8a2daeab64.png#averageHue=%23274a60&id=Au6tC&originHeight=378&originWidth=963&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p><p>3.查看当前线程中的进程信息</p><pre><code class="shell">ps H -eo pid,tid,%cpu | grep 40940</code></pre><blockquote><p>pid  进行id</p><p>tid   进程中的线程id</p><p>%  cpu使用率</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735677-2edcadfa-ae64-432b-921d-c622d890990e.png#averageHue=%23244053&id=SWKSd&originHeight=339&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p><blockquote><p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p><p>转换方式：</p><p>在linux中执行命令</p><p><code>printf &quot;%x\n&quot; 30979</code></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735756-cb265c36-63ae-4ce0-85c0-7ebaef8aad2f.png#averageHue=%231c3244&id=RgZlE&originHeight=106&originWidth=454&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></blockquote><p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>执行命令</p><pre><code class="shell">jstack 30978   此处是进程id</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1707656735835-7b03ae3d-81ba-4756-bd39-bf8f0ddd164d.png#averageHue=%2329485c&id=kveRe&originHeight=577&originWidth=1056&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="5-面试现场"><a href="#5-面试现场" class="headerlink" title="5.面试现场"></a>5.面试现场</h2><h3 id="5-1-JVM组成"><a href="#5-1-JVM组成" class="headerlink" title="5.1 JVM组成"></a>5.1 JVM组成</h3><blockquote><p><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</p><p><strong>候选人:</strong></p><p>嗯，好的~~</p><p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p><p>它们的运行流程是：</p><p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p><p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><p><strong>面试官</strong>：好的，你能详细说一下 JVM 运行时数据区吗？</p><p><strong>候选人:</strong></p><p>嗯，好~</p><p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p><ul><li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li><li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li><li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li><li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li></ul></blockquote><blockquote><p><strong>面试官</strong>：好的，你再详细介绍一下程序计数器的作用？</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p><p><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</p><p><strong>候选人:</strong></p><p>好的~</p><p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><pre><code>在JAVA8中堆内会存在年轻代、老年代    1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。    2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</code></pre><p><strong>面试官</strong>：能不能解释一下方法区？</p><p><strong>候选人:</strong></p><p>好的~</p><p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p><p><strong>面试官</strong>：你听过直接内存吗？</p><p><strong>候选人:</strong></p><p>嗯~~</p><p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p><pre><code>所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</code></pre><p><strong>面试官</strong>：什么是虚拟机栈</p><p><strong>候选人:</strong></p><p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p><p><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</p><p><strong>候选人:</strong></p><p>嗯，好的，有这几个区别</p><p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p><p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p></blockquote><h3 id="5-2-类加载器"><a href="#5-2-类加载器" class="headerlink" title="5.2 类加载器"></a>5.2 类加载器</h3><blockquote><p><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</p><p><strong>候选人:</strong></p><p>嗯，是这样的</p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><p>常见的类加载器有4个</p><p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的类库。</p><p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。</p><p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p><p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p><p><strong>面试官</strong>：说一下类装载的执行过程？</p><p><strong>候选人:</strong></p><p>嗯，这个过程还是挺多的。</p><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p><p>1.加载：查找和导入class文件</p><p>2.验证：保证加载类的准确性</p><p>3.准备：为类变量分配内存并设置类变量初始值</p><p>4.解析：把类中的符号引用转换为直接引用</p><p>5.初始化：对类的静态变量，静态代码块执行初始化操作</p><p>6.使用：JVM 开始从入口方法开始执行用户的程序代码</p><p>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><p><strong>面试官</strong>：什么是双亲委派模型？</p><p><strong>候选人:</strong></p><p>嗯，它是是这样的。</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p><p><strong>面试官</strong>：JVM为什么采用双亲委派机制</p><p><strong>候选人:</strong></p><p>主要有两个原因。</p><p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>第二、为了安全，保证类库API不会被修改</p></blockquote><h3 id="5-3-垃圾回收"><a href="#5-3-垃圾回收" class="headerlink" title="5.3 垃圾回收"></a>5.3 垃圾回收</h3><blockquote><p><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</p><p><strong>候选人:</strong></p><p>嗯嗯~</p><p>强引用最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p><p>软引用表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p><p>弱引用表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p><p>虚引用表示一个对象处于<strong>无用</strong>的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</p><p><strong>面试官</strong>：对象什么时候可以被垃圾器回收</p><p><strong>候选人:</strong></p><p>思考一会~~</p><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><p>通常都使用可达性分析算法来确定是不是垃圾</p><p><strong>面试官</strong>： JVM 垃圾回收算法有哪些？</p><p><strong>候选人:</strong></p><p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p><p><strong>面试官</strong>： 你能详细聊一下分代回收吗？</p><p><strong>候选人:</strong></p><p>关于分代回收是这样的</p><p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p><p>具体的工作机制是有些情况：</p><p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p><p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p><p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p><p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p><p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p><p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p><p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p><p><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</p><p><strong>候选人:</strong></p><p>嗯！是这样的，简单说就是</p><p><strong>新生代</strong>主要用来存放新生的对象。</p><p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p><p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p><p><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？</p><p><strong>候选人:</strong></p><p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p><p><strong>面试官</strong>：Minor GC、Major GC、Full GC是什么</p><p><strong>候选人:</strong></p><p>嗯，其实它们指的是不同代之间的垃圾回收</p><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p><p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></blockquote><h3 id="5-4-JVM实践（调优）"><a href="#5-4-JVM实践（调优）" class="headerlink" title="5.4 JVM实践（调优）"></a>5.4 JVM实践（调优）</h3><blockquote><p><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</p><p><strong>候选人:</strong></p><p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p><p><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</p><p><strong>候选人:</strong></p><p>嗯，这些参数是比较多的</p><p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p><p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p><p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p><p><strong>面试官</strong>：嗯，好的，你们平时调试 JVM都用了哪些工具呢？</p><p><strong>候选人:</strong></p><p>嗯，我们一般都是使用jdk自带的一些工具，比如</p><p>jps 输出JVM中运行的进程状态信息</p><p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p><p>jmap 用于生成堆转存快照</p><p>jstat用于JVM统计监测工具</p><p>还有一些可视化工具，像jconsole和VisualVM等</p><p><strong>面试官</strong>：假如项目中产生了java内存泄露，你说一下你的排查思路？</p><p><strong>候选人:</strong></p><p>嗯，这个我在之前项目排查过</p><p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p><p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p><p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p><p><strong>面试官</strong>：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？</p><p><strong>候选人:</strong></p><p>嗯，我思考一下~~</p><p>可以这么做~~</p><p>第一可以使用使用top命令查看占用cpu的情况</p><p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p><p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p><p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型在项目中不怎么用？这次结合实战！</title>
      <link href="/posts/20748c35.html"/>
      <url>/posts/20748c35.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>泛型在项目中用的确实相对没有那么多，但是也可以提供一些便捷，本文先从基础介绍，然后在文章最后讲解项目实战中的一些使用，超级详细！🌟</p></blockquote><p>[TOC]</p><h1 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h1><h2 id="为什么引入泛型"><a href="#为什么引入泛型" class="headerlink" title="为什么引入泛型"></a>为什么引入泛型</h2><ul><li><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</li><li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li><li>Java泛型也是一种语法糖，在<strong>编译阶段完成类型的转换的工作</strong>，避免在运行时强制类型转换而出现ClassCastException,类型转化异常。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>不引入泛型</li></ul><pre><code class="java">public class target_01 &#123;    public static void main(String[] args) &#123;        List list = new ArrayList();        list.add(11);        list.add(&quot;落雨既然&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.println((String)list.get(i));        &#125;    &#125;&#125;</code></pre><p>会报类型转换异常：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46b5cd26895e468a86a1d210994cc6b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1432&h=262&s=35825&e=png&b=202124" alt="image.png"></p><ul><li>使用泛型</li></ul><pre><code class="java">public class target_01 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList();        list.add(&quot;落雨既然&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.println((String)list.get(i));        &#125;    &#125;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b342e5999f74c66a171e95f213e2c51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=236&s=12681&e=png&b=1e1f22" alt="image.png"><br>在上述的实例中，我们只能添加String类型的数据，否则编译器会报错。</p><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li>泛型类概述：把泛型定义在类上</li><li>定义格式：</li></ul><blockquote><p>注意事项：泛型类型必须是引用类型（非基本数据类型）</p></blockquote><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul><li>泛型方法概述：把泛型定义在方法上</li><li>定义格式：</li></ul><blockquote><p>注意要点：<strong>方法声明</strong>中定义的<strong>形参只能在该方法里使用</strong>，而<strong>接口、类声明中定义的类型形参</strong>则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p></blockquote><pre><code class="java">class Demo &#123;  // 泛型方法，可以接收任意类型的数据  public &lt;T&gt; T fun(T t) &#123;    // 直接将参数返回    return t;  &#125;&#125;public class GenericsDemo26 &#123;  public static void main(String args[]) &#123;    // 实例化Demo对象    Demo d = new Demo();    // 传递字符串    String str = d.fun(&quot;落雨既然&quot;);    // 传递数字，自动装箱    int i = d.fun(30);    // 输出字符串内容    System.out.println(str);    // 输出数字内容    System.out.println(i);  &#125;//  输出：//  落雨既然//  30&#125;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075218b91c3a42418fe096972490a7fd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1199&h=543&s=25686&e=png&b=fefefe" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de3e70bb1a0c4e27b035264405a907f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=248&s=22406&e=png&b=ffffff" alt="image.png"><br>说明一下，定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。<br>Class<T>的作用就是指明泛型的具体类型，而Class<T>类型的变量c，可以用来创建泛型类的对象。<br>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。<br>泛型方法要求的参数是Class<T>类型，而Class.forName()方法的返回值也是Class<T>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<T>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<User>类型的对象，因此调用泛型方法时，变量c的类型就是Class<User>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。<br>当然，泛型方法不是仅仅可以有一个参数Class<T>，可以根据需要添加其他参数。<br><strong>为什么要使用泛型方法呢</strong>？<br>因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p><h3 id="泛型上下限"><a href="#泛型上下限" class="headerlink" title="泛型上下限"></a>泛型上下限</h3><pre><code class="java">    public static void funC(List&lt;? extends A&gt; listA) &#123;        // ...              &#125;    public static void funD(List&lt;B&gt; listB) &#123;        funC(listB); // OK        // ...                 &#125;</code></pre><p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。<br>如果不用泛型就会报错：</p><p>上界：</p><pre><code class="java">class Info&lt;T extends Number&gt;&#123;    // 此处泛型只能是数字类型</code></pre><p>下界：</p><pre><code class="java">    public static void fun(Info&lt;? super String&gt; temp)&#123;    // 只能接收String或Object类型的泛型，String类的父类只有Object类</code></pre><p>小结：</p><pre><code class="java">&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</code></pre><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><pre><code class="java">List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误，需要强转类型 List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告</code></pre><ul><li>使用场景</li></ul><pre><code class="java">public class GenericsDemo30&#123;      public static void main(String args[])&#123;          Integer i[] = fun1(1,2,3,4,5,6) ;   // 返回泛型数组          fun2(i) ;      &#125;      public static &lt;T&gt; T[] fun1(T...arg)&#123;  // 接收可变参数          return arg ;            // 返回泛型数组      &#125;      public static &lt;T&gt; void fun2(T param[])&#123;   // 输出          System.out.print(&quot;接收泛型数组：&quot;) ;          for(T t:param)&#123;              System.out.print(t + &quot;、&quot;) ;          &#125;      &#125;  &#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da0e9136ae784482a65592dd47561d02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1756&h=1130&s=248753&e=png&b=222427" alt="image.png"></p><h1 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="深入理解泛型"></a>深入理解泛型</h1><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p><strong>泛型的类型擦除原则</strong>是：</p><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2dc031266c04baf8fca9ac12a25ad22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776&h=223&s=30986&e=png&a=1&b=000000" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ac4d20ae2a479fb71d9ff2f7a7101e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=236&s=31204&e=png&a=1&b=000000" alt="image.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a56013c830d44a2fa84bac6bc42eb717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=144&s=20440&e=png&a=1&b=fb9f00" alt="image.png"></p><h2 id="类型擦除保留的原始类型"><a href="#类型擦除保留的原始类型" class="headerlink" title="类型擦除保留的原始类型"></a>类型擦除保留的原始类型</h2><p>原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p><h2 id="泛型在编译器的检查"><a href="#泛型在编译器的检查" class="headerlink" title="泛型在编译器的检查"></a>泛型在编译器的检查</h2><p>java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。<br>例如：</p><pre><code class="java">public static  void main(String[] args) &#123;      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();      list.add(&quot;123&quot;);      list.add(123);//编译错误  &#125;</code></pre><p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><h1 id="项目中的泛型实战"><a href="#项目中的泛型实战" class="headerlink" title="项目中的泛型实战"></a>项目中的泛型实战</h1><p>泛型很多都是理论，在项目中怎么用呢？<br>比如对于常见的缓存穿透，缓存击穿，我们就可以使用泛型将其封装到一个类里面。<br>比如下面代码，是黑马点评项目中的一个点：<strong>通过泛型 + 函数式编程封装成通用解决方案。</strong><br><strong>难点：</strong></p><ul><li><strong>泛型方法</strong>的使用：返回值类型不确定、id类型不确定。所以就声明泛型，<strong>让调用者告诉我们泛型</strong>是什么；</li><li><strong>使用函数式接口</strong>：牵扯到数据库查询，需要参数和返回值，使用函数式接口Function&lt;ID,R&gt;<ul><li>四大函数式接口 Function&lt;T,R&gt;   Predicate<T>    Consumer<T>    Supplier<T></li></ul></li></ul><pre><code class="java">/** * 缓存工具封装 */@Slf4j@Componentpublic class CacheClient &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    //缓存击穿使用的线程池    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    /**     * 将任意java对象序列化为json字符串并存储在string类型的key中，并设置TTL     *     * @param key   string类型的key     * @param value 任意java对象     * @param time  时间     * @param unit  单位     */    public void set(String key, Object value, Long time, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);    &#125;    /**     * 将任意java对象序列化为json字符串并存储在string类型的key中，并设置逻辑过期时间，用于处理缓存击穿     *     * @param key   string类型的key     * @param value 任意java对象     * @param time  逻辑时间     * @param unit  单位     */    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;        // RedisData对象，设置逻辑过期        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        // 写入Redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    /**     * 解决缓存穿透     *     * @param keyPrefix  key前缀     * @param id         id不知道什么类型，所以需要声名泛型ID，名字随意起     * @param type       是什么类型     * @param dbFallback 如果redis查询的不是&quot;&quot;，那就需要查询数据库，函数式接口指定逻辑     * @param time       重建缓存后的有效时间     * @param unit       时间单位     * @param &lt;R&gt;        返回值类型，例如Shop类型     * @param &lt;ID&gt;       id不知道什么类型，所以需要声名泛型ID，名字随意起     * @return     */    public &lt;R, ID&gt; R queryWithPassThrough(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false        if (StrUtil.isNotBlank(json)) &#123;        // 3.存在，直接返回            return JSONUtil.toBean(json, type);        &#125;        //      3.2  如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则        if (&quot;&quot;.equals(json)) &#123;            // 解决缓存穿透，不会再去查数据库            return null;        &#125;        // 4.如果不存在，且不是&quot;&quot; ；那么原因可能是缓存中为null，需要根据id去查询数据库        R r = dbFallback.apply(id);        // 5.不存在，返回错误        if (r == null) &#123;            // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);            // 返回错误信息            return null;        &#125;        // 6.存在，写入redis，调用已经写好的方法,超时剔除        this.set(key, r, time, unit);        return r;    &#125;    /**     * 逻辑过期 解决缓存击穿     */    public &lt;R, ID&gt; R queryWithLogicalExpire(            String keyPrefix, ID id, Class&lt;R&gt; type,String lockKeyPrefix, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            //  3.1 不存在直接返回null，不是热点key            return null;        &#125;            //  3.2 存在，反序列化为RedisData对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        //        得到R对象        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 4.判断是否过期        if (expireTime.isAfter(LocalDateTime.now())) &#123;            // 4.1.未过期，直接返回            return r;        &#125;        // 5. 已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = lockKeyPrefix + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock) &#123;            // 6.3.成功，开启独立线程，实现缓存重建//            在这之前需要DoubleCheck，再次查看redis缓存是否过期            json = stringRedisTemplate.opsForValue().get(key);//            判断是否存在            if (StrUtil.isNotBlank(json)) &#123;                //            5.2.2.1 存在则判断是否过期，未过期就直接返回，不需要缓存构建                redisData = JSONUtil.toBean(json, RedisData.class);                r = JSONUtil.toBean((JSONObject) redisData.getData(), type);                expireTime = redisData.getExpireTime();                if (expireTime.isAfter(LocalDateTime.now())) &#123;                    //   未过期，直接返回                    return r;                &#125;            &#125;            //   6.4 已过期 || 不存在  则重新构建，开启线程池（如果自己new 线程，性能不好）            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;                try &#123;                    // 查询数据库                    R newR = dbFallback.apply(id);                    // 重建缓存--热点key                    this.setWithLogicalExpire(key, newR, time, unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125; finally &#123;                    // 释放锁                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的信息        return r;    &#125;    /**     * 互斥锁 解决缓存击穿     */    public &lt;R, ID&gt; R queryWithMutex(            String keyPrefix, ID id, Class&lt;R&gt; type,String lockKeyPrefix, long sleepTime,Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询缓存        String json = stringRedisTemplate.opsForValue().get(key);//        2.判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false        if (StrUtil.isNotBlank(json)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(json, type);        &#125;//      3.2  如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则        if (&quot;&quot;.equals(json)) &#123;//            解决缓存穿透，不会再去查数据库            return null;        &#125;//        4.如果不存在，且不是&quot;&quot; ；那么原因可能是缓存中为null，需要根据id去查询数据库//        ==========解决缓存击穿==========//        4.1 获取互斥锁        String lockKey = lockKeyPrefix + id;        R r = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2.判断是否获取成功            if (!isLock) &#123;                // 4.3.获取锁失败，休眠并重试                Thread.sleep(sleepTime);                return queryWithMutex(keyPrefix, id ,type,lockKeyPrefix,sleepTime, dbFallback, time, unit);            &#125;            // 4.4 成功，做双重检查锁，查看redis缓存是否存在，存在则无需重建缓存            json = stringRedisTemplate.opsForValue().get(key);            // 判断是否存在 。isNotBlank只有在 字符串 才返回true。 换行 ，null, &quot;&quot;等都是false            if (StrUtil.isNotBlank(json)) &#123;                //   存在直接返回                r = JSONUtil.toBean(json, type);                return r;            &#125;            //   如果不存在，则有  null，&quot;&quot;,换行  等可能性。如果是&quot;&quot;， 则是为了解决缓存穿透而约定的规则            if (&quot;&quot;.equals(json)) &#123;                //           解决缓存穿透，不会再去查数据库                return null;            &#125;            //  5. 到这里说明通过双重检查锁，代表是第一个线程，则根据id查询数据库            r = dbFallback.apply(id);            // 不存在，返回错误            if (r == null) &#123;                // 将空值写入redis                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);                // 返回错误信息                return null;            &#125;            // 6.存在，写入redis            this.set(key, r, time, unit);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            // 7.释放锁            unlock(lockKey);        &#125;        // 8.返回        return r;    &#125;    private boolean tryLock(String key) &#123;        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);//        不要直接返回，因为会自动拆箱，如果为null，会报空指针异常。//        使用工具类        return BooleanUtil.isTrue(flag);    &#125;    private void unlock(String key) &#123;        stringRedisTemplate.delete(key);    &#125;&#125;</code></pre><p>参考文章：<br><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html#%E6%B3%9B%E5%9E%8B%E7%B1%BB">https://pdai.tech/md/java/basic/java-basic-x-generic.html#泛型类</a><br>    <a href="https://juejin.cn/post/6844903925666021389?searchId=202402142156151370FABE70EBA2501841#heading-8">https://juejin.cn/post/6844903925666021389?searchId=202402142156151370FABE70EBA2501841#heading-8</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收入门（爱上JVM！！）</title>
      <link href="/posts/63f114ae.html"/>
      <url>/posts/63f114ae.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><meta name="referrer" content="no-referrer" /><h1 id="如何判断对象可回收"><a href="#如何判断对象可回收" class="headerlink" title="如何判断对象可回收"></a>如何判断对象可回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>如果一个对象被其他变量所引用，则让该对象的引用计数+1，如果该对象被引用2次则其引用计数为2，依次类推。<br>某个变量不再引用该对象，则让该对象的引用计数-1，当该对象的引用计数变为0时，则表示该对象没用被其他变量所引用，这时候该对象就可以被作为垃圾进行回收。<br>引用计数法弊端：循环引用时，两个对象的引用计数都为1，导致两个对象都无法被释放回收。最终就会造成内存泄漏！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706285104990-31a78b77-2fa1-4cdf-95ed-5796e62cca6f.png#averageHue=%23f8f8f7&clientId=u30874917-ba43-4&from=paste&height=173&id=ua318ec17&originHeight=346&originWidth=718&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41902&status=done&style=none&taskId=u5e50c46c-531b-4b80-8438-a79c782602a&title=&width=359" alt="image.png"></p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法：就是JVM中判断对象是否是垃圾的算法：该算法首先要确定GC Root(根对象，就是肯定不会被当成垃圾回收的对象)。<br>在垃圾回收之前，JVM会先对堆中的所有对象进行扫描，判断每一个对象是否能被GC Root直接或者间接的引用，如果能被根对象直接或间接引用则表示该对象不能被垃圾回收，反之则表示该对象可以被回收：<br>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象。<br>扫描堆中的对象，看能否沿着GC Root为起点的引用链找到该对象，如果找不到，则表示可以回收，否则就可以回收。<br>可以作为GC Root的对象：<br>虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象<br>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p><blockquote><p>可以理解成一个葡萄，从根出发能到达各个葡萄的位置。</p></blockquote><p>案例演示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286510162-965b841c-3f1b-4c05-90cc-da4fb616d941.png#averageHue=%23faf9f9&clientId=u9964b7dd-f54e-4&from=paste&height=636&id=uca5ea950&originHeight=1272&originWidth=2810&originalType=binary&ratio=2&rotation=0&showTitle=false&size=721676&status=done&style=none&taskId=u1b2faba7-4158-476c-b9ea-706e1393da6&title=&width=1405" alt="image.png"><br>这里在list1有无值两方面抓取快照。<br>然后通过eclipse提供的MAT工具来 <code>GCRoot</code>，哪些可以作为<code>GCRoot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286861093-06406389-103f-4a01-abf0-dad164d4f4de.png#averageHue=%23ece9e2&clientId=u9964b7dd-f54e-4&from=paste&height=262&id=u1d8e0269&originHeight=524&originWidth=1204&originalType=binary&ratio=2&rotation=0&showTitle=false&size=234129&status=done&style=none&taskId=ua9ee7593-c0ac-404a-9ca8-c06fc092092&title=&width=602" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706286775480-81f7544c-d99f-44e1-aa5b-e186d932bc12.png#averageHue=%23eae8e2&clientId=u9964b7dd-f54e-4&from=paste&height=467&id=u08ab5f86&originHeight=934&originWidth=2308&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1147449&status=done&style=none&taskId=u7c022eb1-cce0-48fe-863b-fe141f1e59f&title=&width=1154" alt="image.png"><br>这些都可以作为<code>gcroot</code><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287024040-9700c11d-1fcb-41df-9314-24ab95d9f363.png#averageHue=%23edede8&clientId=u9964b7dd-f54e-4&from=paste&height=761&id=u2aa131a4&originHeight=1522&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1286962&status=done&style=none&taskId=uefd0b948-48df-401f-84cc-eb2f1f850b0&title=&width=1273" alt="image.png"></p><ul><li>所以以后我们查看跟对象就可以通过MAT工具啦。</li></ul><h1 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341743263-6f3e11ef-731f-4948-9b2a-92758904999c.png#averageHue=%23dedad4&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=gTuV2&originHeight=1288&originWidth=2066&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1168397&status=done&style=none&taskId=u6b208f64-cea3-4c93-bf18-e96e793340f&title=&width=1033" alt="image.png"></p><h2 id="强软弱"><a href="#强软弱" class="headerlink" title="强软弱"></a>强软弱</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287702315-3b3cbca2-5e11-48e5-b188-6afc037d3d97.png#averageHue=%23f9f7f0&clientId=u9964b7dd-f54e-4&from=paste&height=614&id=u969b987b&originHeight=1228&originWidth=2376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=580538&status=done&style=none&taskId=u7a15e292-5bcc-4dc6-9b5a-2e578847c76&title=&width=1188" alt="image.png"></p><ul><li>强引用：对于A1对象，只有两个<code>GC Root</code>都不在引用它，才会释放。</li><li>软引用和弱引用，当内存不够的时候，看你就会释放A2,A3对象，之后软引用和弱引用就会进入到引用队列，如果要释放二者，就需要通过引用队列遍历，然后释放两个引用（因为它们俩也是对象）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706287970236-c1deb335-9fff-415c-b008-8eb8b173eef1.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=583&id=ud2beb0e6&originHeight=1166&originWidth=2348&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472767&status=done&style=none&taskId=u18d56396-e792-44ca-8363-a3ffbab3f01&title=&width=1174" alt="image.png"></p><h2 id="虚终"><a href="#虚终" class="headerlink" title="虚终"></a>虚终</h2><ul><li>虚引用和终引用必须配合引用队列使 用</li></ul><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340580486-818f346a-e34f-4cad-8e88-343a2b7460d2.png#averageHue=%23f9f7f3&clientId=u9964b7dd-f54e-4&from=paste&height=339&id=u8641f669&originHeight=678&originWidth=1480&originalType=binary&ratio=2&rotation=0&showTitle=false&size=221705&status=done&style=none&taskId=ucca23a33-d880-46b3-80cc-d1963d16cf8&title=&width=740" alt="image.png"><br>当引用的对于ByteBuffer被回收以后，直接内存还没有被回收，虚引用对象（Cleaner)就会被放入到引用队列中，<br>然后就会由线程<code>ReferencHandler</code>定时去引用队列寻找是否有<code>Cleaner</code>对象，如果有，就会调用Cleaner对象的clean方法，而clean方法就会根据前面记录的直接内存地址，调用Unsafe.freeMemory()方法，来释放直接内存。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706340798493-29f35654-5f12-4f6c-88e9-5b03b2f1eb25.png#averageHue=%23f9f8f4&clientId=u9964b7dd-f54e-4&from=paste&height=316&id=u2f462385&originHeight=632&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=208623&status=done&style=none&taskId=uae20db02-e918-45e7-8dbc-ddc52855982&title=&width=754" alt="image.png"><br>总之虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存。<br>根据上面的图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用 队列中，然后调用它的clean方法来释放直接内存。</p><blockquote><p>可以回顾一下之前学的直接内存，和Cleaner底层原理。</p></blockquote><h3 id="终引用"><a href="#终引用" class="headerlink" title="终引用"></a>终引用</h3><p>所有的类都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706341322729-5dbafcfd-a4af-4ee5-968a-f77ed1995c06.png#averageHue=%23faf8f6&clientId=u9964b7dd-f54e-4&from=paste&height=500&id=u1816a410&originHeight=1000&originWidth=2268&originalType=binary&ratio=2&rotation=0&showTitle=false&size=275505&status=done&style=none&taskId=ub155ae2c-26a6-48c6-a24a-14e8f67e575&title=&width=1134" alt="image.png"><br>当一个对象重写了finalize方法，肯定是希望通过终结器应用释放。<br>例如上图，当A4对象没有强引用的时候，这时候会进行垃圾回收，虚拟机会对这个对象创建终结器引用，终结器应用会进入到引用队列，但这时候A4对象还没有被释放！！<br>只有当优先级很低的FinallizeHandler线程来应用队列寻找是否有终结器应用，然后调用A4对象的finallize()方法，在下一次垃圾回收的时候A4对象才会得到释放。</p><blockquote><p>所以也就有一个弊端，因为FinallizeHandler线程优先级很低，而且第一次内存回收的时候并不能完全释放。所以有时候对象迟迟得不到释放，内存就会一直被占用，所以这个终结器应用在日常用的并不多。</p></blockquote><hr><h2 id="软引用案例"><a href="#软引用案例" class="headerlink" title="软引用案例"></a>软引用案例</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347165062-a9a75e54-7b71-42cc-9407-bfccde1f4fc9.png#averageHue=%23f0ecdf&clientId=u9964b7dd-f54e-4&from=paste&height=508&id=u63d2e236&originHeight=1016&originWidth=2220&originalType=binary&ratio=2&rotation=0&showTitle=false&size=648652&status=done&style=none&taskId=u136180f6-a625-4acd-af36-d0755c7acb8&title=&width=1110" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347325360-08e2b093-3ff1-4595-9702-44c59b9ebafb.png#averageHue=%23fafaf8&clientId=u9964b7dd-f54e-4&from=paste&height=664&id=u7ab57e66&originHeight=1328&originWidth=2672&originalType=binary&ratio=2&rotation=0&showTitle=false&size=801552&status=done&style=none&taskId=u7e118bab-2526-4e05-906c-19afdfbf113&title=&width=1336" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347369906-fac8d4c4-76e5-4680-9be5-3f7a95d827ad.png#averageHue=%23fcfbfb&clientId=u9964b7dd-f54e-4&from=paste&height=551&id=u1923440c&originHeight=1102&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=439484&status=done&style=none&taskId=uaaff3dc5-e4fa-4dcc-948c-5d857a752d7&title=&width=1153" alt="image.png"><br>让我们细看一下细节。打印gc详情<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347638207-0bf901a4-88df-454f-90e1-857b6149be68.png#averageHue=%23e1dfd8&clientId=u9964b7dd-f54e-4&from=paste&height=473&id=u1690702f&originHeight=946&originWidth=2880&originalType=binary&ratio=2&rotation=0&showTitle=false&size=994686&status=done&style=none&taskId=uc35aa18b-e351-4c35-85db-91a4d54e303&title=&width=1440" alt="image.png"><br>所以在处理一些不重要的对象的时候，就可以通过软引用来降低内存压力。</p><h2 id="软引用-引用队列"><a href="#软引用-引用队列" class="headerlink" title="软引用_引用队列"></a>软引用_引用队列<img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348021334-2093d593-def0-49e1-81eb-2b2c3efa9a7b.png#averageHue=%23edece6&clientId=u9964b7dd-f54e-4&from=paste&height=446&id=u641eca1e&originHeight=892&originWidth=1680&originalType=binary&ratio=2&rotation=0&showTitle=false&size=524549&status=done&style=none&taskId=ucba936bc-e745-4ee3-86fe-70ef89a69d9&title=&width=840" alt="image.png"></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706347973037-6d201545-2b9b-467c-b5e2-000e71b58f26.png#averageHue=%23f1eee1&clientId=u9964b7dd-f54e-4&from=paste&height=605&id=uc14935a2&originHeight=1210&originWidth=2628&originalType=binary&ratio=2&rotation=0&showTitle=false&size=635074&status=done&style=none&taskId=u6478809c-8762-44e2-bd04-5b2c42d8562&title=&width=1314" alt="image.png"></p><h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706348447712-e4db3f90-ab7a-4edc-9622-a70b6db345fa.png#averageHue=%23eeece3&clientId=u9964b7dd-f54e-4&from=paste&height=600&id=u7b445252&originHeight=1200&originWidth=2416&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1236319&status=done&style=none&taskId=u9773bbed-0dbb-41ca-8e06-23ff6565402&title=&width=1208" alt="image.png"><br>弱引用一般会发生在垃圾回收的时候，当内存紧张时，就会回收弱引用对象，同时也会回收弱引用自身。</p><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>首先有两步</p><ul><li>先标记哪些对象可以是垃圾</li><li>然后清除垃圾回收对象（这里的腾出内存空间并不是将内存空间的字节清 0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。）</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349164883-994f2c35-6859-427d-8ddd-5453e0629fba.png#averageHue=%23f8f8f6&clientId=u9964b7dd-f54e-4&from=paste&height=644&id=ua8b12acc&originHeight=1288&originWidth=1782&originalType=binary&ratio=2&rotation=0&showTitle=false&size=295572&status=done&style=none&taskId=ua30e9cb0-4773-46f5-9471-13046710775&title=&width=891" alt="image.png"></p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349501497-21a252ea-cc5b-467e-a68f-b982d7752814.png#averageHue=%23f8f8f7&clientId=ud1c445ad-4364-4&from=paste&height=510&id=u69fd961f&originHeight=1020&originWidth=2166&originalType=binary&ratio=2&rotation=0&showTitle=false&size=383709&status=done&style=none&taskId=u5d3ff6a0-6269-496a-8da3-286446eb84e&title=&width=1083" alt="image.png">会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是牵扯到对象的整理移动，需要消耗一定的时间，所以效率较低。 </p><h2 id="复制回收"><a href="#复制回收" class="headerlink" title="复制回收"></a>复制回收</h2><ul><li>第一步，分两个区，From区和 To区</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349661483-d9b3176e-5827-49f4-bdf9-0b4b679c3ccc.png#averageHue=%23faf9f8&clientId=ud1c445ad-4364-4&from=paste&height=204&id=uc1ec8f95&originHeight=408&originWidth=1534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128470&status=done&style=none&taskId=uceee1eac-d330-46ba-9fad-52660c0ff8a&title=&width=767" alt="image.png"></p><ul><li>第二步，将From区存活的对象复制到To区，完成碎片的整理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349713486-70ce3114-9d57-4f04-b3ad-67d6f577fcad.png#averageHue=%23f6f6f6&clientId=ud1c445ad-4364-4&from=paste&height=200&id=uffb1c45b&originHeight=400&originWidth=1430&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126655&status=done&style=none&taskId=uecf4a7da-fbf5-4b88-a812-41e5cd0df2a&title=&width=715" alt="image.png"></p><ul><li>第三步，交换From区和To区，使To区总是空闲的一块空间</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706349723740-6b5d89dd-5c39-447d-9858-49eeb46cf6c7.png#averageHue=%23f9f9f8&clientId=ud1c445ad-4364-4&from=paste&height=183&id=u0fec0796&originHeight=366&originWidth=1472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=128196&status=done&style=none&taskId=u8c7d6052-9e5f-4483-8d43-b9b7fe02819&title=&width=736" alt="image.png"><br>复制算法：将内存分为等大小的两个区域，<strong>FROM</strong>和<strong>TO</strong>（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。<strong>这样也可以避免内存碎片的问题，但是会占用双倍的内存空间</strong>。</p><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><p>长时间使用的对象放在老年代中（长时间回收一次，回收花费时间久），在内存不足的时候也可能回收，用完即可丢弃的对象放在新生代中（频繁需要回收，回收速度相对较快）：</p><h2 id="堆内存大致分为两块："><a href="#堆内存大致分为两块：" class="headerlink" title="堆内存大致分为两块："></a>堆内存大致分为两块：</h2><p>新生代、老年代；新生代又划分为伊甸园、幸存区from、幸存区to。<br>长时间使用的对象放在老年代中，用完了就丢弃的对象放在新生代中。根据对象生命周期的不同特点，采用不同的垃圾回收算法，老年代发生次数少，新生代比较频繁。不同区域采用不同算法，更有效的对垃圾回收进行管理<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881007627-58238735-ea09-46ba-8a18-eb949359a3d5.png#averageHue=%23f8f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=287&id=uc287fade&originHeight=359&originWidth=1575&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68146&status=done&style=none&taskId=u7422b092-03c8-4cc3-ba33-46651a1163b&title=&width=1260" alt="image.png"></p><h2 id="分代垃圾回收怎么工作："><a href="#分代垃圾回收怎么工作：" class="headerlink" title="分代垃圾回收怎么工作："></a>分代垃圾回收怎么工作：</h2><p>java虚拟机本身就是一个小的操作系统吧？</p><ul><li>新创建的对象首先分配在 伊甸园 区；</li><li>伊甸园 区空间不足时，触发 minor gc ，使用可达性分析算法沿着GC root引用链去找，进行标记的动作；</li><li>采用复制算法将 伊甸园 区 和幸存区from 区存活的对象复制到幸存区to 中，存活的对象年龄加一，然后交换 from to（这里很细节，实际变的不是两块物理地址，而是指针引用）；</li><li>minor gc 会引发 stop the world，因为垃圾回收的时候对象地址发生改变，如果其他线程也在运行，会造成混乱。暂停其他线程，等垃圾回收结束后，恢复用户线程运行；</li><li>新生代触发的STW的时间较短  </li><li>每次minorGC后，eden和from对象都清除干净了 </li><li>每次都把不需要回收和幸存区from留下的移到To中，然后交换From和To的位置</li><li>当幸存区to对象的寿命超过阈值时，会晋升到老年代，最大寿命是15（4bit）</li><li>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li><li>如果老年代空间不足时，会先尝试触发 minor gc，如果空间仍然不足，那么就触发 full fc ，STW停止的时间更长！</li><li>from和to每次都要留一个空的，空间不足就触发gc，还不足就会触发提前晋升老年代，老年代如果放不下先触发full gc 然后再尝试提前晋升，还不行就Java heap space outofmemoryerror异常</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648881771672-021f9d70-7ed1-45bb-a8b4-669bee5ffa8f.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=638&id=uc808cb5a&originHeight=798&originWidth=1573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161287&status=done&style=none&taskId=u8cb047b9-4dfd-4147-ac34-1ff98b7e2ec&title=&width=1258.4" alt="image.png"></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><p>**含义 **                                      <strong>参数</strong><br>堆初始大小                      -Xms<br>堆最大大小                      -Xmx 或 -XX:MaxHeapSize&#x3D;size<br>新生代大小                      -Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )<br>幸存区比例（动态）       -XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy<br>幸存区比例                      -XX:SurvivorRatio&#x3D;ratio<br>晋升阈值                              -XX:MaxTenuringThreshold&#x3D;threshold<br>晋升详情                              -XX:+PrintTenuringDistribution<br>GC详情                             -XX:+PrintGCDetails -verbose:gc<br>FullGC 前 MinorGC              -XX:+ScavengeBeforeFullGC</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>程序刚加载时的堆内存情况：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648887378100-37e3a00f-3c41-43d5-8c39-92f11622161a.png#averageHue=%23dfdfd7&clientId=u64d6ddc7-8e02-4&from=paste&height=215&id=a9BI9&originHeight=269&originWidth=1365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=285016&status=done&style=none&taskId=udf81d81a-5c97-47f1-8349-81474096d8f&title=&width=1092" alt="image.png"></p><ul><li>代码分析</li></ul><p>通过如下代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，什么时候 幸存区放不下，直接晋升老年代，使用前需要设置 jvm 参数。</p><pre><code class="java">public class Code_10_GCTest &#123;    private static final int _512KB = 512 * 1024;    private static final int _1MB = 1024 * 1024;    private static final int _6MB = 6 * 1024 * 1024;    private static final int _7MB = 7 * 1024 * 1024;    private static final int _8MB = 8 * 1024 * 1024;    // -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc    public static void main(String[] args) &#123;        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();        list.add(new byte[_6MB]);        list.add(new byte[_512KB]);        list.add(new byte[_6MB]);        list.add(new byte[_512KB]);        list.add(new byte[_6MB]);    &#125;&#125;</code></pre><ul><li>大对象处理策略：</li></ul><p>当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371753545-75535f45-80d2-489c-8f35-d314afe78f87.png#averageHue=%23e8e5db&clientId=uf95f9f13-d64b-4&from=paste&height=553&id=u38548cc0&originHeight=1106&originWidth=2760&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1337545&status=done&style=none&taskId=u54c391be-757f-44d5-8341-db97e939c9a&title=&width=1380" alt="image.png"></p><ul><li>线程内存溢出：</li></ul><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行<br>这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371871415-adbf0b45-1eca-4777-b023-54ef6b489891.png#averageHue=%23e9e6dc&clientId=uf95f9f13-d64b-4&from=paste&height=440&id=ufb6758c1&originHeight=880&originWidth=2612&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1083308&status=done&style=none&taskId=u9cfd524a-0556-40ac-9981-6ac5abb0606&title=&width=1306" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706371900932-82995376-8d3f-41fe-bd9a-ca5458dec7aa.png#averageHue=%23edeae1&clientId=uf95f9f13-d64b-4&from=paste&height=505&id=u0aa26855&originHeight=1010&originWidth=2768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1449389&status=done&style=none&taskId=u4d7acb62-58d5-4aa4-b142-34e636f4208&title=&width=1384" alt="image.png"></p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706404931105-79675091-00d1-4596-afff-336934f7f63b.png#averageHue=%23fcfcfc&clientId=uf95f9f13-d64b-4&from=paste&height=350&id=u11683edb&originHeight=700&originWidth=1396&originalType=binary&ratio=2&rotation=0&showTitle=false&size=178508&status=done&style=none&taskId=u3728362f-4a56-439f-85b8-564cf624063&title=&width=698" alt="image.png"> </p><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p> 在谈论垃圾收集器的上下文语境中， 它们可以理解为：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>并行（Parallel） ：<br>并行描述的是多条垃圾收集器线程之间的关系， 说明同一时间有多条这样的线程在协同工作， 通常默认此时用户线程是处于等待状态。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>并发（Concurrent） ：<br> 并发描述的是垃圾收集器线程与用户线程之间的关系， 说明同一时间垃圾收集器线程与用户线程都在运行（不一定是并行的可能会交替执行）。 由于用户线程并未被冻结， 所以程序仍然能响应服务请求， 但由于垃圾收集器线程占用了一部分系统资源， 此时应用程序的处理的吞吐量将受到一定影响。 </p><h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><p>即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</p><h2 id="1）串行"><a href="#1）串行" class="headerlink" title="1）串行"></a>1）串行</h2><p>单线程<br>适用于堆内存较小，如个人电脑（CPU核数较少也可以，因为单线程）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648902517820-ef16f7d9-6770-4e5a-a046-a0e24fb4d5c5.png#averageHue=%23fafafa&clientId=u64d6ddc7-8e02-4&from=paste&height=405&id=ZMcbG&originHeight=506&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138942&status=done&style=none&taskId=u83ad8bce-fe92-4f80-9ae8-05716981832&title=&width=1027.2" alt="image.png"></p><pre><code class="java">-XX:+UseSerialGC=serial + serialOld</code></pre><h3 id="安全点："><a href="#安全点：" class="headerlink" title="安全点："></a>安全点：</h3><p>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p><h3 id="Serial-收集器："><a href="#Serial-收集器：" class="headerlink" title="Serial 收集器："></a>Serial 收集器：</h3><p>Serial 收集器是最基本的、发展历史最悠久的收集器<br>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p><h3 id="ParNew-收集器："><a href="#ParNew-收集器：" class="headerlink" title="ParNew 收集器："></a>ParNew 收集器：</h3><ul><li>ParNew 收集器其实就是 Serial 收集器的多线程版本</li><li>除了Serial收集器外， 目前只有它能与CMS收集器配合工作。 </li><li>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</li></ul><h3 id="Serial-Old-收集器："><a href="#Serial-Old-收集器：" class="headerlink" title="Serial Old 收集器："></a>Serial Old 收集器：</h3><p>Serial Old 是 Serial 收集器的老年代版本<br>特点：同样是单线程收集器，采用标记-整理算法</p><p>在服务端模式下，它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用</p><h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><p><strong>parallel：并行的   Pause：停顿</strong></p><ul><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>让单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li>JDK1.8默认使用的垃圾回收器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648905756956-5700f0dd-4a7a-4a73-b0b2-844407cd7d14.png#averageHue=%23fbfafa&clientId=u64d6ddc7-8e02-4&from=paste&height=633&id=UuKmC&originHeight=791&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=332475&status=done&style=none&taskId=u7778844b-e4a1-4067-b788-23755ea24c4&title=&width=1096.8" alt="image.png"></p><pre><code class="java">//第一个是新生代的垃圾回收器,复制算法；第二个是老年代的垃圾回收器，标记整理算法//都是多线程的，只要开启一个，另外一个就会开启//工作开启的回收线程数目，与cpu核数有关。回收时，cpu占有率100%-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC  -XX:+UseAdaptiveSizePolicy   //GC自适应调节策略，伊甸园和幸存区占比-XX:GCTimeRatio=ratio  // 垃圾回收和总时间占比 1/(1+radio)-XX:MaxGCPauseMillis=ms  //  垃圾回收暂停200ms-XX:ParallelGCThreads=n   //回收线程数 控制</code></pre><h3 id="Parallel-Scavenge-收集器："><a href="#Parallel-Scavenge-收集器：" class="headerlink" title="Parallel Scavenge 收集器："></a>Parallel Scavenge 收集器：</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同， CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput） 。 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值 。</p><p>与吞吐量关系密切，故也称为吞吐量优先收集器<br>特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与 ParNew 收集器最重要的一个区别）</p><h3 id="GC自适应调节策略："><a href="#GC自适应调节策略：" class="headerlink" title="GC自适应调节策略："></a>GC自适应调节策略：</h3><p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、<br>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p><h3 id="Parallel-Scavenge-收集器使用两个参数控制吞吐量："><a href="#Parallel-Scavenge-收集器使用两个参数控制吞吐量：" class="headerlink" title="Parallel Scavenge 收集器使用两个参数控制吞吐量："></a>Parallel Scavenge 收集器使用两个参数控制吞吐量：</h3><p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）：<br><strong>回收器一般会让堆变小，减少每次停顿的时间</strong><br>XX:GCTimeRatio&#x3D;radio 垃圾收集时间占总时间的比率，相当于吞吐量的倒数<br><strong>回收器一般会让堆变大，去减少垃圾回收次数，从而减少时间</strong></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本<br>特点：多线程，采用标记-整理算法</p><h2 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h2><ul><li>CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。 </li><li>CMS作为老年代的收集器，新生代只能选择ParNew或者Serial收集器中的一个来配合工作。</li><li>多线程</li><li>适合堆内存较大，需要多核 cpu支持</li><li>面向并发设计的程序都对处理器资源比较敏感。 在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计算能力） 而导致应用程序变慢， 降低总吞吐量。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1648890886592-6db2f622-b3fb-443a-b8fd-7e7f4a023df6.png#averageHue=%23f9f8f8&clientId=u64d6ddc7-8e02-4&from=paste&height=485&id=u5ffb9327&originHeight=606&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347954&status=done&style=none&taskId=u34ec76e5-2f38-4258-b48f-49a9f14f81a&title=&width=1040" alt="image.png"></p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><pre><code class="java">//第一个CMS是并发标记清除算法，用户线程与垃圾回收线程并发进行，老年代浮动垃圾过多，退化为 SerialOld//第二个是parnew新生代多线程回收器-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld//第一个是并行的垃圾回收线程数，一般跟cpu核数一样；第二个是并发的垃圾回收线程数,一般设置为并行线程数的四分之一//比如：核数为4，那就占用一个cpu核进行垃圾回收。其他用于用户线程-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads//同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。//设置得太高将会很容易导致大量的并发失败产生，性能反而降低;//设置太低将导致内存回收频率增加，性能降低-XX:CMSInitiatingOccupancyFraction=percent//重新标记前对新生代 先做一次垃圾回收（UseParNewGC），新生代存活对象少了，减轻重新标记的压力-XX:+CMSScavengeBeforeRemark</code></pre><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器<br>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片<br>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p><h3 id="CMS-收集器的运行过程分为下列4步："><a href="#CMS-收集器的运行过程分为下列4步：" class="headerlink" title="CMS 收集器的运行过程分为下列4步："></a>CMS 收集器的运行过程分为下列4步：</h3><h4 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h4><p>标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</p><h4 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h4><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p><h4 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h4><p>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题，这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短。</p><h4 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h4><p>并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的 </p><h3 id="浮动垃圾："><a href="#浮动垃圾：" class="headerlink" title="浮动垃圾："></a>浮动垃圾：</h3><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。 </p><h3 id="并发失败："><a href="#并发失败：" class="headerlink" title="并发失败："></a>并发失败：</h3><h4 id="浮动垃圾过多："><a href="#浮动垃圾过多：" class="headerlink" title="浮动垃圾过多："></a>浮动垃圾过多：</h4><p>如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><h4 id="内存碎片过多："><a href="#内存碎片过多：" class="headerlink" title="内存碎片过多："></a>内存碎片过多：</h4><p>CMS是一款基于“标记-清除”算法实现的收集器， 这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很多剩余空间， 但就是无法找到足够大的连续空间来分配当前对象， 而不得不提前触发一次Full GC的情况。 退化为SerialOld，进行标记整理，很耗费时间，本来是响应优先的垃圾回收器，响应时间变得更长了，这也是CMS存在的问题。</p><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中， 垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的。  </p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410637194-2dbc95a7-b84c-402d-874b-57919eb1efd7.png#averageHue=%23f9f9f8&clientId=ub86ce6bc-f0e5-4&from=paste&height=668&id=u7218fd82&originHeight=1336&originWidth=1768&originalType=binary&ratio=2&rotation=0&showTitle=false&size=544533&status=done&style=none&taskId=ufe5e1cb2-722f-4b3f-bc4b-a6f653613a2&title=&width=884" alt="image.png"><br><strong>相关参数</strong>：JDK8 并不是默认开启的，需要参数开启：</p><pre><code class="java">// G1开关-XX:+UseG1GC// 所划分的每个堆内存大小：-XX:G1HeapRegionSize=size// 垃圾回收最大停顿时间-XX:MaxGCPauseMillis=time</code></pre><h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706410858075-d732e623-989c-4cc7-8178-1b6b1c57cd1b.png#averageHue=%23faf8f4&clientId=ub86ce6bc-f0e5-4&from=paste&height=548&id=u5ca16fdb&originHeight=1096&originWidth=1560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=379155&status=done&style=none&taskId=ud0fa9d8a-81b3-498e-a14f-4875a606ea3&title=&width=780" alt="image.png"><br><strong>新生代伊甸园垃圾回收</strong>—–&gt;<strong>内存不足，新生代回收+并发标记</strong>—–&gt;<strong>回收新生代伊甸园、幸存区、老年代内存</strong>——&gt;<strong>新生代伊甸园垃圾回收</strong>(重新开始)。</p><h3 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706426885157-a745faef-0948-4621-b83d-0196c3b9fa80.png#averageHue=%23f2efec&clientId=u27dd8642-2384-4&from=paste&height=686&id=ud84899dd&originHeight=1372&originWidth=1934&originalType=binary&ratio=2&rotation=0&showTitle=false&size=472988&status=done&style=none&taskId=u3c3bd328-bfb4-45ed-87d2-3a283a1a749&title=&width=967" alt="image.png"></p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>会对E、S 、O 进行<strong>全面的回收</strong>。</p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><pre><code class="java">//  用于指定GC最长的停顿时间-XX:MaxGCPauseMillis=ms</code></pre><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？<br>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的最大停顿时间，会根据最大停顿时间，有选择的<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）。<br>G1在老年代内存不足时（老年代所占内存超过阈值）：</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理。</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC。</li></ul><h3 id="FullGC概念解析"><a href="#FullGC概念解析" class="headerlink" title="FullGC概念解析"></a>FullGC概念解析</h3><p><strong>SerialGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>ParallelGC</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc<br><strong>CMS</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍<br><strong>G1</strong><br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集，需要分2种情况，这里不做详细介绍</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/posts/e614237b.html"/>
      <url>/posts/e614237b.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="程序计数器作用"><a href="#程序计数器作用" class="headerlink" title="程序计数器作用"></a>程序计数器作用</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068166843-cbd811f0-fbc1-4e3a-9098-49bd82b4859f.png#averageHue=%23f6f5f4&clientId=ubb321bbb-5d23-4&from=paste&height=604&id=u1ce3a504&originHeight=1208&originWidth=2710&originalType=binary&ratio=2&rotation=0&showTitle=false&size=857500&status=done&style=none&taskId=u26e39ae6-aeb9-4ab2-837b-0d869bc92dc&title=&width=1355" alt="image.png"></p><h2 id="程序计数器特点"><a href="#程序计数器特点" class="headerlink" title="程序计数器特点"></a>程序计数器特点</h2><p>会通过计数器来记录线程已经执行的位置。<br>加入线程1执行到10的时候，cpu时间片被线程2抢走了，那么当程序计数器就会记录线程1现在执行到了10，当线程2执行完了，就切换回道线程1的10位置继续执行。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068507034-9d51f170-0fa5-4f27-a4f8-a0cb7799e246.png#averageHue=%23fcfbfa&clientId=ubb321bbb-5d23-4&from=paste&height=623&id=u1e352509&originHeight=1246&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=626019&status=done&style=none&taskId=u6d61bb48-f6d2-4ffc-beb3-b2448fbdac9&title=&width=1153" alt="image.png"></p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068849024-af493dac-e10e-4ca3-9a3c-86d0ce525bbf.png#averageHue=%23e2dfd8&clientId=ubb321bbb-5d23-4&from=paste&height=184&id=ue10ac1ae&originHeight=368&originWidth=1636&originalType=binary&ratio=2&rotation=0&showTitle=false&size=332469&status=done&style=none&taskId=u9e0cf4fa-2e21-4828-8d3e-63d77e83bfa&title=&width=818" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/38717174/1706069201893-7df9fbfe-8a9e-43ad-8740-096786c993e3.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706068791865-23031138-06fe-45d1-9edc-bf3f30ee7cad.png#averageHue=%23fbfbfb&clientId=ubb321bbb-5d23-4&from=paste&height=516&id=u35efbc41&originHeight=1032&originWidth=1984&originalType=binary&ratio=2&rotation=0&showTitle=false&size=290459&status=done&style=none&taskId=ud43319b0-6887-415b-a60d-3d401963780&title=&width=992" alt="image.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>垃圾回收是否涉及栈内存？</li></ol><p>不涉及，因为方法执行完之后，对应的栈帧就会自己弹出回收，并没有进行垃圾回收机制。垃圾回收一般是对堆内存的处理</p><ol start="2"><li>栈分配内存越大越好嘛？</li></ol><p>并不是，因为内存是固定的，帧分配内存的增多，也代表着线程占有的内存就减少，线程数量减少，也会减少一定的性能。</p><ol start="3"><li>方法内的局部变量是否线程安全？</li></ol><p>需要看变量是否是线程共享的。还要看是否逃离方法作用范围。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706071725265-0270b390-e87a-4930-9f05-a97b160497b7.png#averageHue=%23f7f4e5&clientId=u31b1620a-440f-4&from=paste&height=153&id=u506c9ea9&originHeight=306&originWidth=1354&originalType=binary&ratio=2&rotation=0&showTitle=false&size=130279&status=done&style=none&taskId=ucfd68fec-9ab2-4da8-86f1-e509ba7a661&title=&width=677" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706069846402-38a6c6b0-0404-4468-8641-5df5dbdb4360.png#averageHue=%23fafafa&clientId=u31b1620a-440f-4&from=paste&height=513&id=ud4fc194c&originHeight=1026&originWidth=1992&originalType=binary&ratio=2&rotation=0&showTitle=false&size=221425&status=done&style=none&taskId=ubf517727-b321-4d5a-aa52-0523f850644&title=&width=996" alt="image.png"></p><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706080173901-24b69618-3a90-4bf4-ad4a-f05a307a7315.png#averageHue=%23f8f8f7&clientId=u31b1620a-440f-4&from=paste&height=508&id=u4a8690e9&originHeight=1016&originWidth=824&originalType=binary&ratio=2&rotation=0&showTitle=false&size=189249&status=done&style=none&taskId=u712fba70-5fb7-4f6d-84d9-883189ac550&title=&width=412" alt="image.png"></p><ul><li>方法递归调用可能会造成栈内存溢出，比如无限递归。</li></ul><h2 id="线程诊断"><a href="#线程诊断" class="headerlink" title="线程诊断"></a>线程诊断</h2><h3 id="CPU占占用过多"><a href="#CPU占占用过多" class="headerlink" title="CPU占占用过多"></a>CPU占占用过多</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167252300-451dad54-a3a3-44ad-a119-32e94568d6a6.png#averageHue=%23000000&clientId=u1de935df-8cd2-4&from=paste&height=78&id=u4fbef33c&originHeight=172&originWidth=1968&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=38601&status=done&style=none&taskId=u46abd4f4-0517-41d0-8e46-a7ac3203c25&title=&width=894.5454351567045" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167298278-43ef52bc-f91a-4f7b-bbea-2956c6317cd5.png#averageHue=%2397958c&clientId=u1de935df-8cd2-4&from=paste&height=96&id=uc1de3923&originHeight=212&originWidth=1982&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=246888&status=done&style=none&taskId=u765c10d4-3ffd-4e36-87c2-81711d97423&title=&width=900.9090713824127" alt="image.png"><br>但只能查看编号。<br>定位到具体的线程<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167387393-72b1f6f0-a593-43d4-969a-1e6e4dfcf9b1.png#averageHue=%23030303&clientId=u1de935df-8cd2-4&from=paste&height=313&id=Mt9F8&originHeight=688&originWidth=1972&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=395776&status=done&style=none&taskId=u21508314-d4a5-4661-a2f3-e539d0f7d75&title=&width=896.3636169354781" alt="image.png"><br>通过jstack,展示具体的线程。<br>通过线程id找到有问题的线程，然后进入到问题代码的源码行数。</p><blockquote><p>注意： 需要将上面操作查到的编号转化为16进制，进而查找到有问题的线程。<br>jstack 【进程id】：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706167818182-03f35511-b555-407f-9e17-62aa41c81700.png#averageHue=%23615a51&clientId=u1de935df-8cd2-4&from=paste&height=400&id=u31352e6f&originHeight=880&originWidth=2812&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=1045051&status=done&style=none&taskId=uabba7dc3-c3e1-4b67-9afe-e6e5fff65f6&title=&width=1278.181790477974" alt="image.png"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>通过jstack 进程号<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706168213873-47fdd144-3cc8-47f9-b8cb-2271bcbed257.png#averageHue=%235d554c&clientId=u1de935df-8cd2-4&from=paste&height=529&id=u91f6d248&originHeight=1164&originWidth=2396&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=1164260&status=done&style=none&taskId=u8817d1b5-6b16-41f8-9df3-9b30214f32a&title=&width=1089.0908854855" alt="image.png"><br>排查死锁问题。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>native方法，由C语言实现。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706080927259-a02dbe3b-0a81-41cd-855c-54ff8b12f893.png#averageHue=%23e3e5bb&clientId=u31b1620a-440f-4&from=paste&height=619&id=u16c6b193&originHeight=1238&originWidth=2122&originalType=binary&ratio=2&rotation=0&showTitle=false&size=608129&status=done&style=none&taskId=u85466131-ecbf-4a0c-9c31-79aa2abbbe8&title=&width=1061" alt="image.png"></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706081006420-8ef6d956-28c9-4246-9250-aa8d6fb83700.png#averageHue=%23fafaf9&clientId=u31b1620a-440f-4&from=paste&height=262&id=u209252e8&originHeight=524&originWidth=1162&originalType=binary&ratio=2&rotation=0&showTitle=false&size=205511&status=done&style=none&taskId=u2f1cbeca-1dff-4c9e-8a46-c29e2e235d0&title=&width=581" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706168543664-9e9d9da2-7137-4830-8bcc-3f99fff5a094.png#averageHue=%23f6f4e7&clientId=u1de935df-8cd2-4&from=paste&height=218&id=udc6d6332&originHeight=480&originWidth=1648&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=241833&status=done&style=none&taskId=u55731055-3e36-413a-a254-6bb3e396372&title=&width=749.0908928548013" alt="image.png"><br>自定义内存大小：</p><pre><code>//限制 限制：-Xms  规定的空间大小</code></pre><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><ol><li><strong>jps 工具</strong>查看当前系统中有哪些 java 进程</li><li><strong>jmap 工具</strong>查看堆内存占用情况 jmap - heap 进程id</li><li><strong>jconsole 工具</strong>图形界面的，多功能的监测工具，可以连续监测</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706169692583-4db72f45-c9d2-4e5d-8ab1-4005d723bdb5.png#averageHue=%23fafaf9&clientId=u1de935df-8cd2-4&from=paste&height=299&id=u0d0a30f7&originHeight=658&originWidth=1184&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=356227&status=done&style=none&taskId=uc3a5f5e8-731b-4eeb-ac1e-a1334cf88ce&title=&width=538.1818065170417" alt="image.png"></p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>方法区是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类信息(比如class文件)、常量、静态变量、即时编译器编译后的代码等数据。（什么是类信息：<strong>类版本号、方法、接口</strong>。）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706171339614-3e0df9b8-47ad-4cb6-9924-cafece6a3295.png#averageHue=%23e8f1c1&clientId=u1de935df-8cd2-4&from=paste&height=366&id=u5bfb1624&originHeight=806&originWidth=1232&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=246267&status=done&style=none&taskId=u7a7a9d8c-9ca2-4fdb-bef2-b2a6bb9758e&title=&width=559.9999878623271" alt="image.png"></p><h2 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h2><pre><code class="java">-XX:MaxMetaspaceSize=1m</code></pre><pre><code class="java">public class MethodOverFlow extends ClassLoader &#123;//可以用来加载类的二进制字节码        public static void main(String[] args) &#123;            int j = 0;            try &#123;                MethodOverFlow test = new MethodOverFlow();                for (int i = 0; i &lt; 10000; i++,j++) &#123;                    //ClassWriter 作用是生产类的二进制字节码                    ClassWriter cw = new ClassWriter(0);                    //版本号，public，类名                    cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);                    //返回 byte[]                    byte[] code = cw.toByteArray();                    //执行类的加载                    test.defineClass(&quot;Class&quot; + i, code, 0, code.length);                &#125;            &#125; finally &#123;                System.out.println(j);            &#125;        &#125;    &#125;</code></pre><p>场景：<br>Spring<br>Mabatis</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>学会阅读反编译的字字节码与在常量池的对应关系。</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>常量池中的字符串仅是符号，只有在被用到时才会转化为对象<br>利用串池的机制，来避免重复创建字符串对象<br><strong>字符串变量拼接的原理是StringBuilder</strong><br><strong>字符串常量拼接的原理是编译器优化</strong><br><strong>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</strong><br>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回<br>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706179848133-12b0a2f5-5396-42bc-abc4-de92d9c118f2.png#averageHue=%23faf9f8&clientId=ubf022d95-0954-4&from=paste&height=576&id=u8cacca97&originHeight=1268&originWidth=1828&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=583009&status=done&style=none&taskId=ue49c3e37-4fe6-45b5-8551-37c0797a8f1&title=&width=830.9090728996217" alt="image.png"><br>先到串池找，找到了就不创建了。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180110018-ca780935-9ac1-42cd-bde3-5a2bd5366c4f.png#averageHue=%23fbfbfa&clientId=ubf022d95-0954-4&from=paste&height=560&id=u0f191c65&originHeight=1232&originWidth=2602&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=730159&status=done&style=none&taskId=ub3ea0cf1-0c1e-4c50-8e15-b1072eb4cc2&title=&width=1182.7272470923501" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180368897-e61b89f2-211b-4b04-8280-ff356905d069.png#averageHue=%23fcfbf9&clientId=ubf022d95-0954-4&from=paste&height=230&id=u691d4ea0&originHeight=506&originWidth=2588&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=286843&status=done&style=none&taskId=u57683fea-a763-42af-baa2-6bce12d8509&title=&width=1176.3636108666417" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706180510319-6b0ce27f-ee0b-4c8c-8dea-8a40c536318d.png#averageHue=%23f3f1e9&clientId=ubf022d95-0954-4&from=paste&height=491&id=u51e85250&originHeight=1080&originWidth=2756&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=670056&status=done&style=none&taskId=uefde02df-f82d-4e52-b565-5ee9f18b99d&title=&width=1252.7272455751408" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706195341809-a1ad57f3-9089-476b-910d-edbfe77aec97.png#averageHue=%23f8f7ec&clientId=u515cb933-7cc6-4&from=paste&height=223&id=uf0022656&originHeight=446&originWidth=2190&originalType=binary&ratio=2&rotation=0&showTitle=false&size=343977&status=done&style=none&taskId=u68116973-0802-4c04-bcbc-04dc3870c16&title=&width=1095" alt="image.png"><br>面试问类似的话就比较实在堆区还是在串池中。<br>可以通过以下检验自己：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706195621110-c6928310-f606-4f20-b1d0-f4334e89bb82.png#averageHue=%23fcfbfb&clientId=u515cb933-7cc6-4&from=paste&height=405&id=u5989f7a4&originHeight=810&originWidth=2140&originalType=binary&ratio=2&rotation=0&showTitle=false&size=440100&status=done&style=none&taskId=u29bee30c-7bb5-4f72-bce1-1788ec8f1ea&title=&width=1070" alt="image.png"></p><h3 id="StringTable-位置"><a href="#StringTable-位置" class="headerlink" title="StringTable 位置"></a>StringTable 位置</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706197911734-d199a8c1-10e9-4471-ac10-df2007945a32.png#averageHue=%23e9f1c4&clientId=uc914b68f-3c65-4&from=paste&height=688&id=u1927b1ba&originHeight=1376&originWidth=2260&originalType=binary&ratio=2&rotation=0&showTitle=false&size=452452&status=done&style=none&taskId=u4e29a2ec-2027-4a86-902d-6e4ba7beee2&title=&width=1130" alt="image.png"></p><ul><li>为什么需要metaspace？</li></ul><p>因为永久代的回收效率不高，如果产生太多的字符串常量，可能就会出现内存不足的情况。<br>而在1.8,StringTable在堆中，可以通过minorgc来提高回收效率，降低内存不足的概率。</p><p>案例证明；<br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706198156060-7a8da379-4e89-4f79-92c0-d34b4d5a12a5.png#averageHue=%23fafaf9&clientId=uc914b68f-3c65-4&from=paste&height=543&id=uaaac0896&originHeight=1086&originWidth=2646&originalType=binary&ratio=2&rotation=0&showTitle=false&size=826908&status=done&style=none&taskId=ub15b161e-4df9-4dc6-8627-9a3c58604c3&title=&width=1323" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706198356218-bc8256f0-7e2e-4a71-913c-e2b32e87c480.png#averageHue=%23f9f8f6&clientId=uc914b68f-3c65-4&from=paste&height=454&id=u3efc1940&originHeight=908&originWidth=2730&originalType=binary&ratio=2&rotation=0&showTitle=false&size=775095&status=done&style=none&taskId=u5f2a8059-2f34-4546-ba0a-776b7a5f9c6&title=&width=1365" alt="image.png"></p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706234647220-7cc2df98-1965-4e92-a14a-ac70b4907bcb.png#averageHue=%23f1f1f1&clientId=uc914b68f-3c65-4&from=paste&height=418&id=uaac15721&originHeight=836&originWidth=2144&originalType=binary&ratio=2&rotation=0&showTitle=false&size=405082&status=done&style=none&taskId=u18de8e93-3ccc-468e-ba02-20bca185527&title=&width=1072" alt="image.png"></p><ul><li>如果需要加入很多相同的字符串，使用intern能够很大程度减少内存占用空间。</li></ul><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不数据Java虚拟机的内存管理，而是属于系统内存。</p><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235612677-d46dc5e4-7cd5-434b-88c4-ce7d41f4baaa.png#averageHue=%23eeede1&clientId=ue26e552d-4b6b-4&from=paste&height=538&id=u6942394a&originHeight=1076&originWidth=1554&originalType=binary&ratio=2&rotation=0&showTitle=false&size=753507&status=done&style=none&taskId=u01b78b50-534a-4ca1-b6f2-3c9bd05daa4&title=&width=777" alt="image.png"><br>很明显directBuffer用时更短，效率更高。<br>那么为什么呢？后面会讲</p><h3 id="io和directbuffer"><a href="#io和directbuffer" class="headerlink" title="io和directbuffer"></a>io和directbuffer</h3><ul><li>文件读写流程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235865500-c5724c71-b197-4feb-a3a4-42d15ed5588b.png#averageHue=%23eae9e5&clientId=ue26e552d-4b6b-4&from=paste&height=583&id=u038a2b19&originHeight=1166&originWidth=1866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=353102&status=done&style=none&taskId=ube228090-155c-49d9-99a6-ff7fff6d756&title=&width=933" alt="image.png"></p><ul><li>使用DirectBuffer</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706235923694-f1d96a0b-1b70-46e3-8a3b-9a7d6f225bbb.png#averageHue=%23ededea&clientId=ue26e552d-4b6b-4&from=paste&height=622&id=ucbeaf507&originHeight=1244&originWidth=2070&originalType=binary&ratio=2&rotation=0&showTitle=false&size=414334&status=done&style=none&taskId=u2be3e637-22ac-4316-957e-db6931f15d8&title=&width=1035" alt="image.png"><br>Java代码可以直接访问。</p><h3 id="直接内存释放"><a href="#直接内存释放" class="headerlink" title="直接内存释放"></a>直接内存释放</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38717174/1706236547363-6bffad9a-eb9e-44a4-a602-8597e6424207.png#averageHue=%23f7f3e6&clientId=ue26e552d-4b6b-4&from=paste&height=617&id=ufa3892ef&originHeight=1234&originWidth=2748&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1414676&status=done&style=none&taskId=ub05e31e3-fece-4331-986b-7369bad5482&title=&width=1374" alt="image.png"></p><ul><li>直接内存的回收机制总结</li></ul><p>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法。<br>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM</title>
      <link href="/posts/13a1a5fd.html"/>
      <url>/posts/13a1a5fd.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="本章内容-："><a href="#本章内容-：" class="headerlink" title="本章内容 ："></a>本章内容 ：</h1><p> Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性<br>这一章进一步深入学习<strong>共享变量</strong>在多线程间的【可见性】问题与多条指令执行时的【有序性】问题 </p><p><strong>JMM</strong> 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的<strong>原子性、可见性</strong>、<strong>有序性</strong>的<strong>规则和保障。</strong></p><h1 id="1、Java-内存模型（JMM）"><a href="#1、Java-内存模型（JMM）" class="headerlink" title="1、Java 内存模型（JMM）"></a>1、Java 内存模型（JMM）</h1><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><ol><li>JMM 即 Java Memory Model，从java层面，定义两个抽象概念。</li><li>它定义了<strong>主存（所有线程共享的数据，即共享内存）</strong>、<strong>工作内存（线程私有的数据）</strong>抽象概念。</li><li>为什么要做这个抽象，因为在底层物理上非常复制，如果程序员直接面对底层，那就疯了，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。经过抽象，就可以<strong>用简单的关键字，来控制</strong>是否要缓存？是否要禁止指令优化？ 等等。例如：volatile syn等</li></ol><h2 id="JMM-体现在以下三方面："><a href="#JMM-体现在以下三方面：" class="headerlink" title="JMM 体现在以下三方面："></a>JMM 体现在以下三方面：</h2><p>原子性 - 保证指令<strong>不会受到线程上下文切换</strong>的影响<br>可见性 - 保证指令<strong>不会受 cpu 缓存</strong>的影响<br>有序性 - 保证指令<strong>不会受 cpu 指令并行优化</strong>的影响</p><h1 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h1><h2 id="退出不出的循环："><a href="#退出不出的循环：" class="headerlink" title="退出不出的循环："></a>退出不出的循环：</h2><pre><code class="java">public static boolean run = true;    public static void main(String[] args) &#123;        Thread t1 = new Thread(() -&gt; &#123;            while(run) &#123;            &#125;        &#125;, &quot;t1&quot;);        t1.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        log.info(&quot;t1 Stop&quot;);        run = false;    &#125;</code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649909440350-247e77c9-f82c-4e22-9a4b-f8c0150d1553.png#averageHue=%23eaea9e&clientId=ud10f7835-6559-4&from=paste&id=u403da049&originHeight=1142&originWidth=1043&originalType=url&ratio=1&rotation=0&showTitle=false&size=501369&status=done&style=none&taskId=u1df38cca-f3e4-4926-960a-6fdf1792c4e&title=" alt="image.png"></p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="1-syn也可解决可见性问题："><a href="#1-syn也可解决可见性问题：" class="headerlink" title="1. syn也可解决可见性问题："></a>1. syn也可解决可见性问题：</h3><p><strong>在Java内存模型中，synchronized规定， 线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存  →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</strong></p><h3 id="2-使用volitile：推荐"><a href="#2-使用volitile：推荐" class="headerlink" title="2. 使用volitile：推荐"></a>2. 使用volitile：推荐</h3><ul><li>使用 volatile （易变的   关键字）</li><li>它<strong>可以</strong>用来<strong>修饰成员变量和静态成员变量（放在主存中的变量</strong>），<strong>不能</strong>修饰<strong>局部变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作 主存，解决可见性问题</li></ul><pre><code class="java">//使用易变关键字volatile static Boolean run = true;public static void main(String[] args) throws InterruptedException &#123;    new Thread(()-&gt;&#123;        while (run) &#123;            //如果run为真，则一直执行        &#125;    &#125;).start();     Thread.sleep(1000);    System.out.println(&quot;改变run的值为false&quot;);    run = false; &#125;</code></pre><h2 id="可见性-vs-原子性："><a href="#可见性-vs-原子性：" class="headerlink" title="可见性 vs 原子性："></a>可见性 vs 原子性：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703409850730-6c512767-2f6c-4bdf-8d6c-93a58d2f313d.png#averageHue=%23f7f7f7&clientId=u714f9d90-acae-4&from=paste&height=664&id=uec0d832a&originHeight=1328&originWidth=1988&originalType=binary&ratio=2&rotation=0&showTitle=false&size=612873&status=done&style=none&taskId=u641ce794-2848-4f94-bd7b-f8b76d26535&title=&width=994" alt="image.png"><br>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</li><li>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</li><li>如果在前面示例的<strong>死循环中加入 System.out.println() <strong>会发现</strong>即使不加 volatile 修饰符</strong>，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？ 等烟的示例 为啥没有出现可见性问题?和synchrozized是一个道理。</li></ul><h3 id="因为-println-使用syn关键字："><a href="#因为-println-使用syn关键字：" class="headerlink" title="因为 println() 使用syn关键字："></a>因为 println() 使用syn关键字：</h3><p><strong>在Java内存模型中，synchronized规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</strong></p><pre><code class="java">public void println(String x) &#123;        //使用了synchronized关键字        synchronized (this) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre><p>[</p><p>](<a href="https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN">https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN</a>)</p><h2 id="两阶终止模式之-volatile-优化："><a href="#两阶终止模式之-volatile-优化：" class="headerlink" title="两阶终止模式之 volatile 优化："></a>两阶终止模式之 volatile 优化：</h2><h3 id="对-interrupt-回顾："><a href="#对-interrupt-回顾：" class="headerlink" title="对 interrupt() 回顾："></a>对 interrupt() 回顾：</h3><p><a href="https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN">https://www.yuque.com/hetayiqixueka/il5kwi/gp6k5c#TmOQN</a></p><h3 id="利用停止标志-优化："><a href="#利用停止标志-优化：" class="headerlink" title="利用停止标志 优化："></a>利用停止标志 优化：</h3><p>之前的 interrupt() ，需要重新设置打断标记为真，很容易遗漏。<br>现在使用 volatile 关键字来实现两阶段终止模式。</p><pre><code class="java">public class Test7 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Monitor monitor = new Monitor();        monitor.start();        Thread.sleep(3500);        monitor.stop();    &#125;&#125;// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性// 我们的例子中，即主线程把它修改为 true 对  子线程可见class Monitor &#123;    Thread monitor;    //设置停止标志，用于判断是否被终止了。必须为volatile，因为一个线程启动监控，另外一个线程暂停监控，相当于一个线程读，一个线程写，写的操作要被读线程感知，所以必须为volatile    private volatile boolean stop = false;    /**     * 启动监控器线程     */    public void start() &#123;        //设置线控器线程，用于监控线程状态        monitor = new Thread() &#123;            @Override            public void run() &#123;                //开始不停的监控                while (true) &#123;                    if(stop) &#123;                        System.out.println(&quot;处理后续任务&quot;);                        break;                    &#125;                    System.out.println(&quot;监控器运行中...&quot;);                    try &#123;                        //线程休眠                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                         System.out.println(&quot;被打断了&quot;); //不需要重新设置打断标记，因为优化                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    /**     * 用于停止监控器线程     */    public void stop() &#123;        //打断线程，就是当监控线程在sleep时，那也会被立刻终止        monitor.interrupt();        //修改标记        stop = true;    &#125;&#125;</code></pre><h2 id="同步模式之-犹豫模式："><a href="#同步模式之-犹豫模式：" class="headerlink" title="同步模式之 犹豫模式："></a>同步模式之 犹豫模式：</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>Balking （犹豫）模式：用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><h3 id="前面volatile优化存在的问题："><a href="#前面volatile优化存在的问题：" class="headerlink" title="前面volatile优化存在的问题："></a>前面volatile优化存在的问题：</h3><ul><li>若多次调用 start() ，监控程序会有多个，没有意义。</li><li>需要解决的问题是，某个方法只被执行一次，下次执行的时候直接返回，不要往下执行，这就是犹豫模式</li><li>防止反射破坏单例时候，也是这套路。</li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ul><li>用一个标志来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题，若两个线程同时执行到 if(starting) ，那就会有线程安全问题，需要加锁处理。此时，volitile 不能解决问题，因为不能保证原子性<ul><li>并且，加锁的代码块要尽量的小，以保证性能。</li><li>双重检查锁更好，在外面加个if，可以减少频繁获取锁的情况</li></ul></li></ul><pre><code class="java">public class Test7 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Monitor monitor = new Monitor();        monitor.start();        monitor.start();        Thread.sleep(3500);        monitor.stop();    &#125;&#125;class Monitor &#123;    Thread monitor;    //设置标记，用于判断是否被终止了    private volatile boolean stop = false;    //设置标记，用于判断是否已经启动过了    private boolean starting = false;    /**     * 启动监控器线程     */    public void start() &#123;        //双重检查锁        if(!starting)&#123;            //上锁，避免多线程运行时出现线程安全问题            synchronized (this) &#123;                if (starting) &#123;                    //已被启动，直接返回                    return;                &#125;                //第一次启动监视器，改变标记                starting = true;            &#125;        &#125;        //设置线控器线程，用于监控线程状态        monitor = new Thread() &#123;            @Override            public void run() &#123;                //开始不停的监控                while (true) &#123;                    if(stop) &#123;                        System.out.println(&quot;处理后续任务&quot;);                        break;                    &#125;                    System.out.println(&quot;监控器运行中...&quot;);                    try &#123;                        //线程休眠                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        System.out.println(&quot;被打断了&quot;);                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    /**     * 用于停止监控器线程     */    public void stop() &#123;        //打断线程        monitor.interrupt();        stop = true;    &#125;&#125;</code></pre><h3 id="犹豫模式-应用："><a href="#犹豫模式-应用：" class="headerlink" title="犹豫模式 应用："></a>犹豫模式 应用：</h3><p><strong>保证监控线程只启动一次</strong></p><h4 id="对于以下Tomcat监控线程："><a href="#对于以下Tomcat监控线程：" class="headerlink" title="对于以下Tomcat监控线程："></a>对于以下Tomcat监控线程：</h4><ul><li>监控线程停止时，设 starting 为false ，此时 starting 变量没有在同步代码块内，不能保证可见性，所以也加 volatile 关键字</li><li>如果不保证可见性那么下一次点击 开始 按钮tomcat运行同步代码块里的staring还是true，就不能启动监控线程了</li><li>那为什么不用syn？因为用syn性能消耗大，使用 volatile 轻量级的保证可见性即可</li></ul><pre><code class="java">package cn.itcast.monitor.service;import cn.itcast.monitor.controller.MonitorController;import cn.itcast.monitor.vo.Info;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;/** * @author yihang */@Service@Slf4jpublic class MonitorService &#123;    private volatile boolean stop;    private volatile boolean starting;    private Thread monitorThread;    public void start() &#123;        // 双重检查锁        if(!starting)&#123;            // 缩小同步范围，提升性能            synchronized (this) &#123;                log.info(&quot;该监控线程已启动?(&#123;&#125;)&quot;, starting);                if (starting) &#123;                    return;                &#125;                starting = true;            &#125;        &#125;        // 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥        monitorThread = new Thread(() -&gt; &#123;            while (!stop) &#123;                report();                sleep(2);            &#125;            // 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性            log.info(&quot;监控线程已停止...&quot;);            starting = false;        &#125;);        stop = false;        log.info(&quot;监控线程已启动...&quot;);        monitorThread.start(); //启动监控线程    &#125;    private void report() &#123;        Info info = new Info();        info.setTotal(Runtime.getRuntime().totalMemory());        info.setFree(Runtime.getRuntime().freeMemory());        info.setMax(Runtime.getRuntime().maxMemory());        info.setTime(System.currentTimeMillis());        MonitorController.QUEUE.offer(info);    &#125;    private void sleep(long seconds) &#123;        try &#123;            TimeUnit.SECONDS.sleep(seconds);        &#125; catch (InterruptedException e) &#123;        &#125;    &#125;    public synchronized void stop() &#123;        stop = true;        // 不加打断需要等到下一次 sleep 结束才能退出循环，这里是为了更快结束        monitorThread.interrupt();    &#125;&#125;</code></pre><h4 id="实现线程安全的单例："><a href="#实现线程安全的单例：" class="headerlink" title="实现线程安全的单例："></a>实现线程安全的单例：</h4><pre><code class="java">public final class Singleton &#123;    private Singleton() &#123;    &#125;    private static Singleton INSTANCE = null;    public static synchronized Singleton getInstance() &#123;        //优化        if (INSTANCE != null) &#123;            return INSTANCE;        &#125;        INSTANCE = new Singleton();        return INSTANCE;    &#125;&#125;</code></pre><h1 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h1><h2 id="3-1-指令重排："><a href="#3-1-指令重排：" class="headerlink" title="3.1 指令重排："></a>3.1 指令重排：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703465371216-28d49e05-c15d-45af-81b4-a7eeebfae9e5.png#averageHue=%23f7f6f4&clientId=ue31d7846-9f43-4&from=paste&height=334&id=u2ae422e1&originHeight=668&originWidth=2240&originalType=binary&ratio=2&rotation=0&showTitle=false&size=579732&status=done&style=none&taskId=u7714e233-09b2-4cd0-b9c9-c2c9d8e29ed&title=&width=1120" alt="image.png"></p><ul><li>JVM 会在<strong>不影响结果正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序，</strong>这种特性称之为『<strong>指令重排</strong>』</li><li>但是在<strong>多线程下『指令重排』会影响正确性。</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649924182419-4b9e3d2e-2907-45b6-8bb9-8ad285b2130e.png#averageHue=%23f7f7f6&clientId=ud10f7835-6559-4&from=paste&id=ud4bd176e&originHeight=586&originWidth=1039&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1ee2594c-eef6-4b2a-91af-a67373d196d&title="></p><h2 id="3-2-那为什么要有-指令重排-优化呢？"><a href="#3-2-那为什么要有-指令重排-优化呢？" class="headerlink" title="3.2 那为什么要有 指令重排 优化呢？"></a>3.2 那为什么要有 指令重排 优化呢？</h2><p>从cpu角度，看 CPU执行指令 的原理来理解一下</p><h3 id="指令重排序优化："><a href="#指令重排序优化：" class="headerlink" title="指令重排序优化："></a>指令重排序优化：</h3><ul><li>现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649926023127-7b8a2fb9-0a75-40d3-b36e-da46caa3dc92.png#averageHue=%23f5f5f5&clientId=ud10f7835-6559-4&from=paste&id=u378d7b24&originHeight=225&originWidth=1145&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u221ed5c8-e766-4ad6-a18c-c759b9aaa32&title="><br>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。<br> <img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649934793764-970b1769-f240-4f1a-82d1-11efd67976a7.png#averageHue=%23f2f2f2&clientId=ud10f7835-6559-4&from=paste&height=291&id=u57f92fc0&originHeight=327&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38744&status=done&style=none&taskId=uc37d119c-e9ca-44ee-8944-39215c15db0&title=&width=939.5555555555555" alt="image.png"></p><ul><li>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行,提高并发度</strong></li><li>流水线有时候会因为指令间的依赖关系被阻塞，重排可以减少阻塞</li><li>指令重排的<strong>前提</strong>是，重排指令<strong>不能影响结果</strong>，例如</li></ul><pre><code class="java">// 可以重排的例子 int a = 10; int b = 20; System.out.println( a + b );// 不能重排的例子 int a = 10;int b = a - 5;</code></pre><h2 id="3-3-多线程下指令重排问题："><a href="#3-3-多线程下指令重排问题：" class="headerlink" title="3.3 多线程下指令重排问题："></a>3.3 多线程下指令重排问题：</h2><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="首先看一段代码："><a href="#首先看一段代码：" class="headerlink" title="首先看一段代码："></a>首先看一段代码：</h3><pre><code class="java">int num = 0;// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序boolean ready = false; // 线程1 执行此方法public void actor1(I_Result r) &#123; if(ready) &#123;     r.r1 = num + num; &#125;  else &#123;     r.r1 = 1; &#125;&#125;// 线程2 执行此方法public void actor2(I_Result r) &#123; num = 2; ready = true;&#125;</code></pre><h3 id="在多线程环境下，以上的代码-r1-的值有三种情况："><a href="#在多线程环境下，以上的代码-r1-的值有三种情况：" class="headerlink" title="在多线程环境下，以上的代码 r1 的值有三种情况："></a>在多线程环境下，以上的代码 r1 的值有三种情况：</h3><p>第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4；<br>第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1；<br>第三种：线程 2 先执行，但是发送了指令重排，num &#x3D; 2 与 ready &#x3D; true 这两行代码语序发生装换，</p><pre><code class="java">ready = true; // 前num = 2; // 后</code></pre><p>然后执行 ready &#x3D; true 后，线程 1 运行了，那么 r1 的结果是为 0。<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1703466012493-c87d1923-8917-4ab1-b1b4-d17b2726dac1.png#averageHue=%23fdfdfd&clientId=uf81aeecb-5d94-4&from=paste&height=376&id=u5e4903d9&originHeight=752&originWidth=2656&originalType=binary&ratio=2&rotation=0&showTitle=false&size=341401&status=done&style=none&taskId=u4ad2738f-07e0-4639-b082-f6690553e7b&title=&width=1328" alt="image.png"></p><h2 id="3-4-解决方法："><a href="#3-4-解决方法：" class="headerlink" title="3.4 解决方法："></a>3.4 解决方法：</h2><p>volatile 修饰的变量，可以<strong>禁用指令重排</strong>，<strong>禁止</strong>的是 加 volatile 关键字的变量 <strong>之前的代码进行</strong>重排序<br>这里也就是ready之前的代码禁止重排序</p><h2 id="3-5-volatile-原理："><a href="#3-5-volatile-原理：" class="headerlink" title="3.5 volatile 原理："></a>3.5 volatile 原理：</h2><p><strong>volatile可以保证 共享变量的可见性、有序性，底层如何实现？</strong><br>答：volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后  会加入写屏障</li><li>对 volatile 变量的读指令前  会加入读屏障</li></ul><h3 id="先看一下内存屏障："><a href="#先看一下内存屏障：" class="headerlink" title="先看一下内存屏障："></a>先看一下内存屏障：</h3><ul><li>可见性<ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后的</strong>，对共享变量的读取，加载的是主存中的最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h3 id="如何保证可见性："><a href="#如何保证可见性：" class="headerlink" title="如何保证可见性："></a>如何保证可见性：</h3><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936015305-62534166-2f53-470e-a096-cfdaa7ffb4c8.png#averageHue=%23f4f3f1&clientId=u2908829a-b6ac-4&from=paste&id=ua99e1cbf&originHeight=343&originWidth=1157&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc0ae16b0-4252-4fb5-9326-11d760cb91d&title="></p><ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中的最新数据</li></ul><pre><code class="java">public void actor1(I_Result r) &#123;    // 读屏障    // ready 是 volatile 读取值带读屏障    if(ready) &#123;        r.r1 = num + num;    &#125; else &#123;        r.r1 = 1;    &#125;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936027298-cdd29306-6019-4fda-a99a-0a65e9efd74c.png#averageHue=%23f8efa9&clientId=u2908829a-b6ac-4&from=paste&id=u18500d7d&originHeight=716&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7a1b9dd7-d32a-42a7-bb17-10b5ce40706&title="></p><h3 id="如何保证有序性："><a href="#如何保证有序性：" class="headerlink" title="如何保证有序性："></a>如何保证有序性：</h3><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936043737-e0f7a843-afc6-42d6-a4df-48923dc4b291.png#averageHue=%23f4f3f1&clientId=u2908829a-b6ac-4&from=paste&id=u53639ad9&originHeight=233&originWidth=760&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3223ba4b-068a-465b-a7e3-511ab611186&title="></p><ul><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936055748-fc78c467-778f-469a-ba71-43b1475ed191.png#averageHue=%23f5f4f3&clientId=u2908829a-b6ac-4&from=paste&id=uf680dff8&originHeight=380&originWidth=659&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubf0964af-09aa-4dbd-af37-0deb5bf5f35&title="><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649936066371-31aea7ce-e5ae-404d-9d29-02c4d0a859df.png#averageHue=%23f8efa9&clientId=u2908829a-b6ac-4&from=paste&id=u818c4e63&originHeight=701&originWidth=1201&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8dcc9f71-b00b-4f7e-8e7c-f8ad5e5a04b&title="></p><h4 id="只保证了本线程的有序性，线程间的交错无法保证："><a href="#只保证了本线程的有序性，线程间的交错无法保证：" class="headerlink" title="只保证了本线程的有序性，线程间的交错无法保证："></a>只保证了本线程的有序性，线程间的交错无法保证：</h4><ul><li>jvm 无法控制线程调度，即线程上下文切换。是由cpu的时间片决定的，A线程的时间片用完了，切换到B线程，在线程间的代码就会交错执行</li><li>而有序性的保证也<strong>只是保证了本线程内</strong>相关代码不被重排序</li></ul><h3 id="不能解决指令交错问题：原子性"><a href="#不能解决指令交错问题：原子性" class="headerlink" title="不能解决指令交错问题：原子性"></a>不能解决指令交错问题：原子性</h3><ul><li>即不能保证原子性。写屏障仅仅是保证<strong>之后的读能够读到新的结果</strong>，但<strong>不能保证另外线程的读跑到它前面去，进而不能解决线程安全问题</strong></li></ul><h2 id="syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。"><a href="#syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。" class="headerlink" title="syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。"></a>syn可以保证原子性、可见性、有序性，前提是共享变量完全交给syn管理，但syn代码块内不能禁用指令重排，volatile才可以禁用！！！！如果一个共享变量完全被syn所管理，那么共享变量在使用过程中不会有原子性、可见性、有序性问题。因为完全由synchronized管理的话只有一个线程在代码块内，一个线程就算指令重排也没问题。syn的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同。</h2><h2 id="3-6-double-checked-locking-问题"><a href="#3-6-double-checked-locking-问题" class="headerlink" title="3.6 double-checked locking 问题:"></a>3.6 double-checked locking 问题:</h2><h3 id="最初代码："><a href="#最初代码：" class="headerlink" title="最初代码："></a>最初代码：</h3><pre><code class="java">    // 最开始的单例模式是这样的    public final class Singleton &#123;        private Singleton() &#123; &#125;        private static Singleton INSTANCE = null;        public static Singleton getInstance() &#123;        // 首次访问会同步，而之后的使用可以不用进入synchronized，减少性能损耗        synchronized(Singleton.class) &#123;            if (INSTANCE == null) &#123; // t1                INSTANCE = new Singleton();            &#125;        &#125;            return INSTANCE;        &#125;    &#125;</code></pre><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p>上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked locking：</p><h3 id="改进1："><a href="#改进1：" class="headerlink" title="改进1："></a>改进1：</h3><pre><code class="java">    public final class Singleton &#123;        private Singleton() &#123; &#125;        private static Singleton INSTANCE = null;        public static Singleton getInstance() &#123;            if(INSTANCE == null) &#123; // t2                // 首次访问会同步，而之后的使用没有 synchronized                synchronized(Singleton.class) &#123;                    if (INSTANCE == null) &#123; // t1                        INSTANCE = new Singleton();                    &#125;                &#125;            &#125;            return INSTANCE;        &#125;    &#125;</code></pre><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h4><p>懒惰实例化<br>首次使用 getInstance() 才使用 synchron ized 加锁，后续使用时无需加锁。里面的if是为了防止前面的线程重复创建对象，而外面的if是为了后面的线程重复加锁,损耗性能<br><strong>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外，</strong>不能享有synchronized保证的原子性，可见性、有序性，可能会由于syn代码块中 new 过程 产生指令重排 导致获取到一个半成品对象。</p><h3 id="getInstance-方法对应的字节码为："><a href="#getInstance-方法对应的字节码为：" class="headerlink" title="getInstance 方法对应的字节码为："></a>getInstance 方法对应的字节码为：</h3><pre><code class="java">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;3: ifnonnull 37// ldc是获得类对象6: ldc #3 // class cn/itcast/n5/Singleton// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份8: dup// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中// 将类对象的引用地址存储了一份，是为了将来解锁用9: astore_010: monitorenter11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;14: ifnonnull 27// 新建一个实例17: new #3 // class cn/itcast/n5/Singleton// 复制了一个实例的引用20: dup// 通过这个复制的引用调用它的构造方法21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V// 最开始的这个引用用来进行赋值操作24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;27: aload_028: monitorexit29: goto 3732: astore_133: aload_034: monitorexit35: aload_136: athrow37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;40: areturn</code></pre><h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ul><li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton</li><li>20 表示复制一份对象引用 &#x2F;&#x2F; 复制了引用地址到栈中</li><li>21 表示利用一个对象引用，调用构造方法 &#x2F;&#x2F; 根据复制的引用地址调用 构造方法()</li><li>24 表示利用一个对象引用，**赋值给 static INSTANCE **</li></ul><h4 id="多线程环境下，是有问题的："><a href="#多线程环境下，是有问题的：" class="headerlink" title="多线程环境下，是有问题的："></a>多线程环境下，是有问题的：</h4><p>也许 jvm 会优化为：在syn代码块中发生 指令重排，先执行 24，再执行 21。   **  **<br><strong>并且 两个线程 t1，t2  按如下时间序列执行：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649940127913-311c97d3-1655-44fb-b66f-b419e9f0b69e.png#averageHue=%23fafafa&clientId=u2908829a-b6ac-4&from=paste&id=uc746b838&originHeight=820&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&size=141258&status=done&style=none&taskId=ud3ea8fec-dadf-4267-b6fa-66d071b4e0f&title=" alt="image.png"></p><h3 id="最终解决方案："><a href="#最终解决方案：" class="headerlink" title="最终解决方案："></a>最终解决方案：</h3><ol><li>关键在于** 0: getstatic <strong>这行字节码 在 monitor 控制之外，它就像之前举例中不守规则的人，</strong>可以越过 monitor 读取 INSTANCE 变量的值**</li><li>这时 t1 <strong>还未完全将构造方法执行完毕</strong>，如果在构造方法中要执行很多初始化操作，那么 **t2 <strong>拿到的是将是一个</strong>未初始化完毕的单例 **</li><li>对 INSTANCE 使用 volatile 修饰即可，<strong>volatile可以禁用指令重排</strong>，底层是内存屏障。但要注意在 JDK 5 以上的版本的 volatile 才会真正有效。</li></ol><h4 id="代码：加volatile就行了"><a href="#代码：加volatile就行了" class="headerlink" title="代码：加volatile就行了"></a>代码：加volatile就行了</h4><pre><code class="java"> public final class Singleton &#123;        private Singleton() &#123;            //可以在构造方法里面加个判断，如果INSTANCE != null，就抛个异常。因为反射可以拿到私有的构造方法，从而创建对象。        &#125;        private static volatile Singleton INSTANCE = null;        public static Singleton getInstance() &#123;            // 实例没创建，才会进入内部的 synchronized代码块            if (INSTANCE == null) &#123;                synchronized (Singleton.class) &#123; // t2                    // 也许有其它线程已经创建实例，所以再判断一次                    if (INSTANCE == null) &#123; // t1                        INSTANCE = new Singleton();                    &#125;                &#125;            &#125;            return INSTANCE;        &#125;    &#125;</code></pre><h4 id="字节码上看不出来-volatile-指令的效果："><a href="#字节码上看不出来-volatile-指令的效果：" class="headerlink" title="字节码上看不出来 volatile 指令的效果："></a>字节码上看不出来 volatile 指令的效果：</h4><pre><code class="java">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;3: ifnonnull 376: ldc #3 // class cn/itcast/n5/Singleton8: dup9: astore_010: monitorenter -----------------------&gt; 保证原子性、可见性11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;14: ifnonnull 2717: new #3 // class cn/itcast/n5/Singleton20: dup21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障27: aload_028: monitorexit ------------------------&gt; 保证原子性、可见性29: goto 3732: astore_133: aload_034: monitorexit35: aload_136: athrow37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;40: areturn</code></pre><h5 id="从底层内存屏障分析："><a href="#从底层内存屏障分析：" class="headerlink" title="从底层内存屏障分析："></a>从底层内存屏障分析：</h5><p>如上面的注释内容所示，读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier（Memory Fence）），<strong>保证下面两点：</strong></p><ol><li>可见性<ol><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ol></li><li><strong>有序性</strong><ol><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ol></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649943204849-2a5ee5b4-f5fe-430d-b2ce-5e12249fe9c9.png#averageHue=%23fafafa&clientId=u2908829a-b6ac-4&from=paste&height=783&id=u6bc6a86a&originHeight=881&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132190&status=done&style=none&taskId=udeada633-0be2-428d-94b2-3ac559e8e79&title=&width=837.3333333333334" alt="image.png"></p><h5 id="volatile是保证线程内指令禁用重排序，管不到线程间："><a href="#volatile是保证线程内指令禁用重排序，管不到线程间：" class="headerlink" title="volatile是保证线程内指令禁用重排序，管不到线程间："></a>volatile是保证线程内指令禁用重排序，管不到线程间：</h5><p>就算cpu这样子调度，也是ok的，此时t2线程if（&#x3D;&#x3D;null） 判断成功<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649942964600-1a29b3dc-4b1f-4640-9488-3ec0cac0104d.png#averageHue=%23f8f8f8&clientId=u2908829a-b6ac-4&from=paste&height=757&id=u0c86551f&originHeight=852&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138939&status=done&style=none&taskId=u040aa0d6-d72a-4788-a3e2-fca26a85a7c&title=&width=807.1111111111111" alt="image.png"></p><h1 id="4、happens-before："><a href="#4、happens-before：" class="headerlink" title="4、happens-before："></a>4、happens-before：</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>happens-before 规定了对共享变量的<strong>写操作</strong>对其它线程的<strong>读操作</strong>可见，它是可见性与有序性的<strong>一套规则总结</strong>。抛开以下 happens-before 规则，JM </p><h2 id="几种规则："><a href="#几种规则：" class="headerlink" title="几种规则："></a>几种规则：</h2><p>下面说的变量都是指成员变量或静态成员变量，即共享变量<br>① 线程A 解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程B 对该变量的读可见<br>因为 线程A 解锁前将x变量的值保存到了主内存，在释放锁</p><pre><code class="java"> static int x;    static Object m = new Object();    new Thread(()-&gt;&#123;        synchronized(m) &#123;            x = 10;        &#125;    &#125;,&quot;t1&quot;).start();    new Thread(()-&gt;&#123;        synchronized(m) &#123;            System.out.println(x);        &#125;    &#125;,&quot;t2&quot;).start();</code></pre><p>② 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见<br>volatile 保证写入操作是写入主存</p><pre><code class="java">volatile static int x;new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;).start();new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start();</code></pre><p>③ 线程 start 前对变量的写，对该线程开始后对该变量的读可见<br>这是启动线程前将工作内存保存到了主内存</p><pre><code class="java">static int x;x = 10;new Thread(()-&gt;&#123; System.out.println(x);&#125;,&quot;t2&quot;).start();</code></pre><p>④ 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><pre><code class="java">static int x;Thread t1 = new Thread(()-&gt;&#123; x = 10;&#125;,&quot;t1&quot;);t1.start();t1.join();System.out.println(x);</code></pre><p>⑤ 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p><pre><code class="java"> static int x;    public static void main(String[] args) &#123;        Thread t2 = new Thread(()-&gt;&#123;            while(true) &#123;                if(Thread.currentThread().isInterrupted()) &#123;                    System.out.println(x);                    break;                &#125;            &#125;        &#125;,&quot;t2&quot;);        t2.start();        new Thread(()-&gt;&#123;            sleep(1);            x = 10;            t2.interrupt();        &#125;,&quot;t1&quot;).start();        while(!t2.isInterrupted()) &#123;            Thread.yield();        &#125;        System.out.println(x);    &#125;</code></pre><p>⑥ 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见<br>⑦ 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子<br>写屏障之上的代码对共享变量的改动都同步到主存中</p><pre><code class="java">   volatile static int x;   static int y;   new Thread(()-&gt;&#123;        y = 10;        x = 20;   &#125;,&quot;t1&quot;).start();   new Thread(()-&gt;&#123;       // x=20 对 t2 可见, 同时 y=10 也对 t2 可见       System.out.println(x);    &#125;,&quot;t2&quot;).start();</code></pre><h1 id="volatile总结："><a href="#volatile总结：" class="headerlink" title="volatile总结："></a>volatile总结：</h1><p>volatile<strong>主要用在</strong>一个线程写 多个线程读 时的来保证可见性，和double-checked locking模式中保证synchronized代码块外的共享变量的重排序问题。</p><h1 id="5、练习："><a href="#5、练习：" class="headerlink" title="5、练习："></a>5、练习：</h1><h2 id="1）balking-模式习题："><a href="#1）balking-模式习题：" class="headerlink" title="1）balking 模式习题："></a>1）balking 模式习题：</h2><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？<br>volatile 无法保证原子性，多线程下肯定要加synchronized<br>volatile 可以保存线程的可见性，有序性，但是不能保证原子性，doInit 方法没加锁，可能会被调用多次。</p><pre><code class="java">public class TestVolatile &#123;    volatile boolean initialized = false;    void init() &#123;        if (initialized) &#123;            return;        &#125;        doInit();        initialized = true;    &#125;    private void doInit() &#123;    &#125;&#125; </code></pre><h2 id="2）线程安全单例习题"><a href="#2）线程安全单例习题" class="headerlink" title="2）线程安全单例习题:"></a>2）线程安全单例习题:</h2><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试着分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建<ul><li>饿汉式依靠类加载时的clinit静态初始化时执行，保证了线程安全，对内存不友好，类准备阶段直接赋值</li></ul></li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul><h3 id="实现1：饿汉式"><a href="#实现1：饿汉式" class="headerlink" title="实现1：饿汉式"></a>实现1：饿汉式</h3><pre><code class="java">// 问题1：为什么加 final? 防止子类继承这个单例类 然后重写方法// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例?  进行反序列化的时候会生成新的对象，就破坏单例了。要解决直接加上readResolve()方法就行了，如下所示public final class Singleton implements Serializable &#123;    // 问题3：为什么设置为私有? 防止其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。    private Singleton() &#123;&#125;    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?可以，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性。clinit方法，线程安全的    private static final Singleton INSTANCE = new Singleton();    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。    //1.提供更好的封装性，可以进行懒惰的初始化；  2.提供范型的支持    public static Singleton getInstance() &#123;        return INSTANCE;    &#125;    //方法名是：readResolve()，是为了防止类在反序列化的时候创建对象。    //当用反序列化创建对象时，会调用readResovle()，因此我们直接给它重写，让它返回我们创建的对象就行了。    public Object readResolve() &#123;        return INSTANCE;    &#125;&#125;</code></pre><h3 id="实现2：枚举类-饿汉式"><a href="#实现2：枚举类-饿汉式" class="headerlink" title="实现2：枚举类-饿汉式"></a>实现2：枚举类-饿汉式<img src="https://cdn.nlark.com/yuque/0/2022/png/25949200/1649985872537-ac83cb76-b326-4fd2-ba85-4467753f110b.png#averageHue=%23faf5f2&clientId=uc3c01388-aa91-4&from=paste&height=610&id=u5a706353&originHeight=686&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&size=322387&status=done&style=none&taskId=ub599bb76-9739-468f-8472-d6ffdd76fba&title=&width=1188.4444444444443" alt="image.png"></h3><pre><code class="java">// 问题1：枚举单例是如何限制实例个数的？    创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量// 问题2：枚举单例在创建时是否有并发问题？    没有，这是静态成员变量，在类加载阶段创建，JVM保证线程安全// 问题3：枚举单例能否被反射破坏单例？    不能，枚举类型不能通过newInstance反射，Class#newInstance()方法会判断是否是枚举类，如果是   会抛出异常// 问题4：枚举单例能否被反序列化破坏单例？    枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例// 问题5：枚举单例属于懒汉式还是饿汉式？    饿汉式，类加载时就创建了// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？    加构造方法就行了enum Singleton &#123;  INSTANCE;&#125;</code></pre><h3 id="实现3：懒汉式"><a href="#实现3：懒汉式" class="headerlink" title="实现3：懒汉式"></a>实现3：懒汉式</h3><pre><code class="java">public final class Singleton &#123;    private Singleton() &#123; &#125;    private static Singleton INSTANCE = null;    // 分析这里的线程安全, 并说明有什么缺点？    synchronized加在静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能   比较低。    public static synchronized Singleton getInstance() &#123;        if( INSTANCE != null )&#123;            return INSTANCE;        &#125;        INSTANCE = new Singleton();        return INSTANCE;    &#125;&#125;</code></pre><h3 id="实现4：DCL-懒汉式"><a href="#实现4：DCL-懒汉式" class="headerlink" title="实现4：DCL 懒汉式"></a>实现4：DCL 懒汉式</h3><pre><code class="java">public final class Singleton &#123;    private Singleton() &#123; &#125;    // 问题1：解释为什么要加 volatile ?        为了防止重排序问题，保证拿到的对象是完整无缺的    private static volatile Singleton INSTANCE = null;    // 问题2：对比实现3, 说出这样做的意义：提高了效率，不用每次都加锁    public static Singleton getInstance() &#123;        if (INSTANCE != null) &#123;            return INSTANCE;        &#125;        synchronized (Singleton.class) &#123;            // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？            //    这是为了防止第一次判断时的并发问题。            if (INSTANCE != null) &#123; // t2                return INSTANCE;            &#125;            INSTANCE = new Singleton();            return INSTANCE;        &#125;    &#125;&#125;</code></pre><h3 id="实现5：静态内部类-懒汉式"><a href="#实现5：静态内部类-懒汉式" class="headerlink" title="实现5：静态内部类-懒汉式"></a>实现5：静态内部类-懒汉式</h3><p>静态内部类是在使用的时候才完成类加载，不会因为外部类的加载而加载。此例是调用getInstance() 方法才完成静态内部类的 类加载<br>这是 静态内部类 和 静态代码块、静态变量 的区别</p><pre><code class="java">public final class Singleton &#123;    private Singleton() &#123; &#125;    // 问题1：属于懒汉式还是饿汉式？    懒汉式，这是一个静态内部类，是在使用的时候才完成类加载，不会因为外部类的加载而加载。在没有 调用getInstance方法时，是不会执行LazyHolder内部类的类加载操作的。    private static class LazyHolder &#123;        static final Singleton INSTANCE = new Singleton();    &#125;    // 问题2：在创建时是否有并发问题？        这是线程安全的，类加载时，jvm保证类加载操作的线程安全    public static Singleton getInstance() &#123;        return LazyHolder.INSTANCE;    &#125;&#125;</code></pre><h1 id="6、结论："><a href="#6、结论：" class="headerlink" title="6、结论："></a>6、结论：</h1><p>本章重点讲解了 JMM 中的</p><ol><li>可见性 - 由 JVM 缓存优化引起</li><li>有序性 - 由 JVM 指令重排序优化引起</li><li>happens-before 规则 七条</li><li>原理方面<ol><li>CPU指令级别并行</li><li>volatile -&gt; 内存屏障</li></ol></li><li>模式方面<ol><li>两阶段终止模式的  volatile 改进</li><li>同步模式之 balking(犹豫模式)  –&gt; 保证某段代码只执行一次</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划理论</title>
      <link href="/posts/cc7ca809.html"/>
      <url>/posts/cc7ca809.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p><strong>常见题型:</strong></p><ul><li>背包问题</li><li>打家劫舍</li><li>股票问题</li><li>子序列问题</li></ul><p>态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，<br>动态规划中dp[j]是由<code>dp[j-weight[i]]</code>推导出来的，然后取<code>max(dp[j], dp[j - weight[i]] + value[i])</code>。<br>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。<br><strong>解题步骤</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p><strong>如何debug</strong><br>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！<br>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>题目链接: <a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><h2 id="动态规划五部曲"><a href="#动态规划五部曲" class="headerlink" title="动态规划五部曲"></a>动态规划五部曲</h2><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>入门题原因:  递推公式已经给了:** **dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p><ol start="3"><li>dp数组初始化</li></ol><p>题目给了: dp[0] &#x3D; 0; dp[1] &#x3D; 1;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2]，推导一下，当N为10的时候，dp数组应该是如下的数列：<br>0 1 1 2 3 5 8 13 21 34 55</p><pre><code class="cpp">class Solution &#123;    public :        int fib(int n) &#123;        vector&lt;int&gt; dp(n+1);        if( n &lt;= 1)&#123;            return n;        &#125;        dp[0] = 0;        dp[1] = 1;        for(int i = 2; i &lt;= n; i++)&#123;            dp[i] = dp[i-1] + dp[i-2];        &#125;        return dp[n];    &#125;&#125;;</code></pre><h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><p>题目链接:<br><a href="https://leetcode.cn/problems/climbing-stairs/description/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><h2 id="DP五部曲"><a href="#DP五部曲" class="headerlink" title="DP五部曲"></a>DP五部曲</h2><ul><li><ol><li>确定dp数组以及下标定义</li></ol></li></ul><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ul><li><ol start="2"><li>确定递推公式</li></ol></li></ul><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。<br>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！<br>所以**dp[i] &#x3D; dp[i - 1] + dp[i - 2] **。<br>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。<br>这体现出确定dp数组以及下标的含义的重要性！</p><ul><li><ol start="3"><li>dp数组如何初始化</li></ol></li></ul><p>题目说了, n是一个正整数<br>不考虑dp[0]如何初始化，只初始化dp[1] &#x3D; 1，dp[2] &#x3D; 2，然后从i &#x3D; 3开始递推，这样才符合dp[i]的定义。</p><ul><li><ol start="4"><li>确定遍历顺序</li></ol></li></ul><p>从递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ul><li><ol start="5"><li>推到dp数组</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697472840603-278be474-e26a-42bf-9b0e-e7f7df782d25.png#averageHue=%23f2f2f2&clientId=u35be678d-fe85-4&from=paste&height=384&id=u4b3a3af1&originHeight=384&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26258&status=done&style=none&taskId=u507c4ece-7908-43fb-b8b9-d0cffdc4b53&title=&width=814" alt="image.png"><br>这不就是斐波那契嘛</p><pre><code class="java">class Solution &#123;    public int climbStairs(int n) &#123;                if(n &lt;= 1) return n;        int[] dp = new int[n+1];        dp[1] = 1;        dp[2] = 2;        for(int i = 3; i &lt;= n; i++)&#123;            dp[i] = dp[i-2] + dp[i-1];        &#125;        return dp[n];    &#125;&#125;</code></pre><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>看不懂就先看动态视频的演示，注意max的含义。<br>【【算法演示】动态规划求解最长公共子序列】<br><a href="https://www.bilibili.com/video/BV1PA411w7CW?vd_source=fcae3ca58a4c2446a58b5aaacbaa4bbe">【算法演示】动态规划求解最长公共子序列_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点评项目实战</title>
      <link href="/posts/6bd5204f.html"/>
      <url>/posts/6bd5204f.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801356928-1038c401-76d3-4029-9ade-1af6e5c0280f.png#averageHue=%23e9e9e6&clientId=u023eb198-87b4-4&from=paste&height=538&id=u539f0ea2&originHeight=673&originWidth=300&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94508&status=done&style=none&taskId=ub2bffcf8-da03-4137-8da5-73895a1347d&title=&width=240" alt="image.png"></p><pre><code class="java">    @Override    public Result sendCode(String phone, HttpSession session) &#123;       // 1. 检验手机号码是否有效        if (RegexUtils.isPhoneInvalid(phone))&#123;            return Result.fail(&quot;手机号码无效&quot;);        &#125;        //2. 生成验证码        String code = RandomUtil.randomNumbers(6);        // 3. 保存到session中        session.setAttribute(&quot;code&quot;, code);        //4. 发送验证码        log.debug(&quot;发送验证码成功, 验证码是:&#123;&#125;&quot;, code);        // 5. 返回成功        return Result.ok();    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698801410162-5c8e46f4-74f7-42f6-8895-eef95eed91e9.png#averageHue=%23fcf6f5&clientId=u023eb198-87b4-4&from=paste&height=474&id=ufa498d0e&originHeight=593&originWidth=1366&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58225&status=done&style=none&taskId=u603ec55b-759d-49f3-8cbb-8911b4f3cac&title=&width=1092.8" alt="image.png"><br>将生成的验证码根据key-value的形式存入redis</p><blockquote><p>这里有一个小细节：<br><strong>这里虽然后端配置的端口时8081，但这里的请求仍然时8080，是因为前端使用nginx，反向代理，请求先发送到了nginx服务，然后反向代理再去请求tomcat服务器</strong></p></blockquote><p>补充：</p><blockquote><p>@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。<br>@Autowired只根据type进行注入，不会去匹配name</p></blockquote><h2 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825277887-0fd5dc23-0660-4ee6-b1dc-3bc7caa0ae8e.png#averageHue=%23eeeaea&clientId=u8fd209ed-60a0-4&from=paste&height=500&id=u90d93351&originHeight=500&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61551&status=done&style=none&taskId=ub8f396b4-717d-45a7-94b3-93c30f8ce35&title=&width=400" alt="image.png"></p><pre><code class="java"> @Override    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;        // 检验手机格式        String phone = loginForm.getPhone();        if(RegexUtils.isPhoneInvalid(phone))&#123;            return Result.fail(&quot;手机号格式错误&quot;);        &#125;        // 2. 校验验证码        String code = loginForm.getCode();        if (code==null  || !code.equals(session.getAttribute(&quot;code&quot;)))&#123;            // 3. 校验验证码失败            Result.fail(&quot;验证码错误&quot;);        &#125;        // 3. 根据手机号查询用户        User user =  query().eq(&quot;phone&quot;, phone).one();        // 用户不存在        if (user == null)&#123;           user =  createUserWithPhone(phone);        &#125;        // 4. 用户存在, 保存到session中        session.setAttribute(&quot;user&quot;, user);        return Result.ok();    &#125;</code></pre><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825445004-a6016290-a7e2-4fe7-9ad2-5baf4d03322f.png#averageHue=%23f5f4f4&clientId=u8fd209ed-60a0-4&from=paste&height=936&id=ubc9ca8c3&originHeight=936&originWidth=2111&originalType=binary&ratio=1&rotation=0&showTitle=false&size=390396&status=done&style=none&taskId=u281196a9-354a-4025-af73-c4739038dc8&title=&width=2111" alt="image.png"><br>这么做有问题, 当Controller层多的时候, 这样的业务逻辑就都得重写,<br>&#x3D;&gt; 可以加一个拦截器来解决<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698825629609-6369cd15-7ea9-4cdf-ba2c-80283907b44e.png#averageHue=%23f2ebea&clientId=u8fd209ed-60a0-4&from=paste&height=785&id=uc48a18cc&originHeight=981&originWidth=2229&originalType=binary&ratio=1&rotation=0&showTitle=false&size=299850&status=done&style=none&taskId=u74fe0f76-4930-4709-9978-758d1c82770&title=&width=1783.2" alt="image.png"><br>每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><pre><code class="java">package com.hmdp.utils;import com.hmdp.dto.Result;import com.hmdp.dto.UserDTO;import com.hmdp.entity.User;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.web.servlet.HandlerInterceptor;import com.hmdp.utils.UserHolder;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       Object user = request.getSession().getAttribute(&quot;user&quot;);       if (user == null)&#123;          response.setStatus(401);          return false;       &#125;        UserHolder.saveUser((UserDTO) user);        return true;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;       UserHolder.removeUser();    &#125;&#125;</code></pre><p>配置:</p><pre><code class="java">package com.hmdp.config;import com.hmdp.utils.LoginInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new  LoginInterceptor()).excludePathPatterns(                &quot;/shop/**&quot;,                &quot;/voucher/**&quot;,                &quot;/shop-type/**&quot;,                &quot;/blog/hot&quot;,                &quot;/user/code&quot;,                &quot;/user/login&quot;,                &quot;/upload/**&quot;        );    &#125;&#125;</code></pre><p>注意隐藏信息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828563629-a0f2d4c2-f931-4571-995d-dca9ebd7cd72.png#averageHue=%232c2b2b&clientId=u8fd209ed-60a0-4&from=paste&height=192&id=u967c724b&originHeight=192&originWidth=1256&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22166&status=done&style=none&taskId=u27b2f1ae-fd8f-4669-bf8c-0d819eefc48&title=&width=1256" alt="image.png"></p><blockquote><p>注意BeanUtil和BeanUtils区别</p></blockquote><p>使用ThreadLocal</p><blockquote><p><strong>ThreadLocal</strong>：为每个线程提供一份单独存储空间，只有在线程内才能获取对应的值</p></blockquote><pre><code class="java">package com.hmdp.utils;import com.hmdp.dto.UserDTO;public class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO userId)&#123;        tl.set(userId);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698828260112-414e2510-ddfd-49e5-984f-097b13fee144.png#averageHue=%23fcfaf9&clientId=u8fd209ed-60a0-4&from=paste&height=667&id=u63ffab52&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34061&status=done&style=none&taskId=udb64cb68-f96c-40d8-9d43-adfa17565b0&title=&width=375" alt="image.png"></p><h2 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h2><p>多台tomcat服务器之间并不共享数据, 容易造成切换服务器数据丢失的问题<br>session的替代方案应满足:</p><ul><li>数据共享</li><li>内存存储</li><li>key value结构</li></ul><p>解决办法 &#x3D;&gt; redis</p><h2 id="基于redis实现session共享登录"><a href="#基于redis实现session共享登录" class="headerlink" title="基于redis实现session共享登录"></a>基于redis实现session共享登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698829850748-a6352f14-367c-419a-abb1-32da0047725d.png#averageHue=%23c5918e&clientId=u8fd209ed-60a0-4&from=paste&height=1053&id=ueaf61fbb&originHeight=1053&originWidth=1799&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391683&status=done&style=none&taskId=ue0eea36f-38a4-41fc-9fd2-1f329f33447&title=&width=1799" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698846050148-bff23449-9187-4ead-8533-d7f57e910afd.png#averageHue=%23efeae9&clientId=u5a170d56-888a-4&from=paste&height=1108&id=u1c766697&originHeight=1108&originWidth=2089&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496399&status=done&style=none&taskId=u9056657b-38a3-48ca-8a27-07f62fd1dcb&title=&width=2089" alt="image.png"></p><h2 id="基于redis实现短信登录"><a href="#基于redis实现短信登录" class="headerlink" title="基于redis实现短信登录"></a>基于redis实现短信登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699027861571-80106832-60b3-4bee-a610-0de8c9ccd0b1.png#averageHue=%23ece6e6&clientId=uc77679ca-2224-4&from=paste&height=751&id=u5e8e06ac&originHeight=939&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208747&status=done&style=none&taskId=u69fc68a2-4a66-4abc-ba34-971cb892e11&title=&width=504" alt="image.png"><br>先生成UUID<br>转换成HashMap存储<br>存储token<br>设置有效期</p><pre><code class="java">//        // 4. 用户存在, 保存到session中//        session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));        // 保存用户信息到Redis中        String token = UUID.randomUUID().toString();        log.debug(&quot;token:&#123;&#125;&quot;,token);        // 转换HashMap存储        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);        Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO);        String tokenKey = LOGIN_USER_KEY+token;        stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);        //设置token有效期          stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);        return Result.ok(token);</code></pre><p><strong>但这段代码没有更新token有效期:</strong><br>在preHandle中实现;</p><pre><code class="java">    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       String token =  request.getHeader(&quot;authorization&quot;);       //判断用户是否存在       if (StrUtil.isBlank(token))&#123;          response.setStatus(401);          return false;       &#125;       // 基于token获取Hash数据的用户        String tokenKey = RedisConstants.LOGIN_USER_KEY+token;        Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);        // 判断用户是否存在        if (userMap.isEmpty())&#123;            response.setStatus(401);            return false;        &#125;        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(),false);        //保存        UserHolder.saveUser(userDTO);        // 刷新token有效期        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);        //放行        return true;    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031051581-9951aaef-bd4b-4f9d-9379-a1a44e51acfe.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=758&id=ub014d843&originHeight=947&originWidth=1814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146553&status=done&style=none&taskId=ua7d97c5d-ce29-44e6-a456-623f2a888f5&title=&width=1451.2" alt="image.png"><br><a href="https://blog.csdn.net/qq3434569/article/details/113940767">使用Hutool的BeanUtil优雅的讲Map转为javaBean_beanutil map转对象-CSDN博客</a><br>但是会报错服务器异常<br>解决:<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699031558738-b9faeca0-1063-41b7-9d18-c10d1aeb77bc.png#averageHue=%232d2c2c&clientId=uc77679ca-2224-4&from=paste&height=561&id=u94138825&originHeight=701&originWidth=1708&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118546&status=done&style=none&taskId=u0b8c18e8-4e47-446b-b156-004339a07a6&title=&width=1366.4" alt="image.png"></p><pre><code class="java"> Map&lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(),                CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((filename, fileValue)-&gt; fileValue.toString())                );</code></pre><h2 id="拦截器优化"><a href="#拦截器优化" class="headerlink" title="拦截器优化"></a>拦截器优化</h2><p><strong>问题: 如果用户访问一些不需要登录的界面, 那么过期时间到了之后, 就会自动退出登录</strong><br>**解决办法: **</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1698916213005-332df564-3b55-43a9-a60f-74d549dcbbbf.png#averageHue=%23e8d7d4&clientId=uc0c97467-78c9-4&from=paste&height=611&id=ud9121bae&originHeight=1222&originWidth=2366&originalType=binary&ratio=2&rotation=0&showTitle=false&size=671865&status=done&style=none&taskId=u1b7bf3be-3c11-424d-9b49-642a36aac1d&title=&width=1183" alt="image.png"></p><pre><code class="java">public class RefreshIntercepter implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshIntercepter(StringRedisTemplate stringRedisTemplate)&#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String token =  request.getHeader(&quot;authorization&quot;);        //判断用户是否存在        if (StrUtil.isBlank(token))&#123;`            return true;        &#125;        // 基于token获取Hash数据的用户        String tokenKey = RedisConstants.LOGIN_USER_KEY+token;        Map&lt;Object,Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);        // 判断用户是否存在        if (userMap.isEmpty())&#123;            return true;        &#125;        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(),false);        //保存        UserHolder.saveUser(userDTO);        // 刷新token有效期        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);        //放行        return true;    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033166224-6b311249-d8ac-4919-8bfb-01fde2904928.png#averageHue=%232c2b2b&clientId=uc77679ca-2224-4&from=paste&height=460&id=u7eeb875c&originHeight=575&originWidth=1535&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85465&status=done&style=none&taskId=u5687a791-fddf-43ee-82f9-4c29ac5ba08&title=&width=1228" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699033178566-858b9d04-7fa0-40c5-b495-538b8e77d349.png#averageHue=%232c2c2b&clientId=uc77679ca-2224-4&from=paste&height=382&id=u40b497e8&originHeight=478&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56335&status=done&style=none&taskId=uc9b1de4c-840a-493c-9bf1-1db531df6cb&title=&width=1007.2" alt="image.png"></p><h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>临时存储数据的地方<br><strong>缓存的作用: 降低后端负载,降低响应时间, 应对更多的并发请求</strong><br><strong>缓存的成本: 数据一致性成本, 代码维护下成本, 运维成本</strong></p><h2 id="添加用户缓存"><a href="#添加用户缓存" class="headerlink" title="添加用户缓存"></a>添加用户缓存</h2><pre><code>  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/38717174/1699082099728-62ad2f9e-259c-4e25-9e18-fcdce88f80cc.png#averageHue=%23f2f1f1&amp;clientId=u603f9972-ee0f-4&amp;from=paste&amp;height=826&amp;id=uec12dec0&amp;originHeight=1032&amp;originWidth=2120&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=398838&amp;status=done&amp;style=none&amp;taskId=u16271973-331e-47ac-b1d3-c7926ef6e65&amp;title=&amp;width=1696)</code></pre><pre><code class="java">  @Resource    StringRedisTemplate stringRedisTemplate;    @Override    public Result queryById(Long id) &#123;        String key  = CACHE_SHOP_KEY +id;        // 从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 判断是否存在        //如果存在, 返回商铺信息        if(StrUtil.isNotBlank(shopJson))&#123;            Shop shop = JSONUtil.toBean(shopJson,Shop.class);            return  Result.ok(shop);        &#125;        //如果不存在, 查询数据库        Shop shop = getById(id);        // 判断数据库信息是否存在        //不存在则返回404        if (shop == null)&#123;            return Result.fail(&quot;店铺不存在&quot;);        &#125;        // 存在, 则将商品信息写入redis        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));        return Result.ok(shop);    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699084036007-5f956627-b2b8-44ae-9dcb-cb15421c3fe5.png#averageHue=%23a3a2a2&clientId=uae1f6871-ad73-4&from=paste&height=500&id=ub61c05fe&originHeight=625&originWidth=1707&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=151609&status=done&style=none&taskId=uf1d67d00-ee1a-4615-a71f-20d43375455&title=&width=1365.6" alt="image.png"></p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>由于数据库数据改变,而缓存中数据没有改变,造成用户从缓存中得到的数据与数据库中的数据不一致<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103143774-ea4905f1-7972-4462-a657-662e7c59b612.png#averageHue=%23e1cdcc&clientId=uae1f6871-ad73-4&from=paste&height=598&id=uc5a9af08&originHeight=748&originWidth=2065&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=272856&status=done&style=none&taskId=u4a9bfdfe-d102-4ff0-882b-fe301ffa8f4&title=&width=1652" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699103259583-b9059fb3-2054-4d80-9340-ec3db709035e.png#averageHue=%23f0f0f0&clientId=uae1f6871-ad73-4&from=paste&height=199&id=ud4e5ebb2&originHeight=249&originWidth=1550&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137644&status=done&style=none&taskId=u733c391e-4a63-4269-868c-1d176ea5381&title=&width=1240" alt="image.png"><br>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。<br><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),但是当时间很长,缓存就不会被更新<br><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存<br>如果在设置的时间内,数据库发生变化,也会导致数据库不一致<br>**主动更新： 在修改数据库的同时,更新缓存 **我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题,<br><strong>主动更新业务实现:</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699108883261-845c3698-3df3-4bc3-af21-c6ee09a080bc.png#averageHue=%23f4f3f3&clientId=uae1f6871-ad73-4&from=paste&height=791&id=u99508fb0&originHeight=989&originWidth=2221&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=364799&status=done&style=none&taskId=ueb35e8bf-0e9a-4a31-a62a-732f7099e79&title=&width=1776.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109050443-3b914bfa-4354-40e2-a38e-e6c7188835bd.png#averageHue=%23f5f4f4&clientId=uae1f6871-ad73-4&from=paste&height=751&id=u932f7a09&originHeight=939&originWidth=2206&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=545799&status=done&style=none&taskId=u93e3d3fa-f060-4ce1-b661-eaa94b08374&title=&width=1764.8" alt="image.png"></p><p><strong>缓存安全问题</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109457009-b58327fb-1853-4230-8fae-c80c6d23bf87.png#averageHue=%23f3f2f2&clientId=uae1f6871-ad73-4&from=paste&height=828&id=u65c2a515&originHeight=1035&originWidth=2001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357984&status=done&style=none&taskId=ub9fec107-412a-436c-8def-1419a45a991&title=&width=1600.8" alt="image.png"><br>方案二相对来说发生概率低一些, 同时也可以加入超时时间, 万一发生旧数据进入 缓存,也可以进行清除<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699109497850-cc021bf3-3261-4972-af61-43df6990d8fa.png#averageHue=%23f1f1f1&clientId=uae1f6871-ad73-4&from=paste&height=563&id=uc77f74fc&originHeight=704&originWidth=1252&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276299&status=done&style=none&taskId=uf8d14cb0-461a-40f3-b58f-de404a6a33a&title=&width=1001.6" alt="image.png"></p><h2 id="实现商品缓存和数据库一致"><a href="#实现商品缓存和数据库一致" class="headerlink" title="实现商品缓存和数据库一致"></a>实现商品缓存和数据库一致</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150811280-843ac537-e79d-4bef-9afa-eacc07858936.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=550&id=u454baf3b&originHeight=687&originWidth=1805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106945&status=done&style=none&taskId=udb5f5a95-64d9-4f70-b5fa-552a75064d5&title=&width=1444" alt="image.png"></p><pre><code class="java">  @Override    @Transactional    public Result update(Shop shop) &#123;        if (shop.getId()==null)&#123;            return Result.fail(&quot;店铺不存在&quot;);        &#125;        // 更新数据库        updateById(shop);        //删除缓存        stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId());        return Result.ok();    &#125;</code></pre><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699150935337-7bba4650-cf0c-4b03-8c06-936b79a49b78.png#averageHue=%23fbfbfb&clientId=u8a7806e8-b16d-4&from=paste&height=716&id=u6d0ceee5&originHeight=895&originWidth=2130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170185&status=done&style=none&taskId=uea060b02-c509-4ab6-ab89-910cf0bcb89&title=&width=1704" alt="image.png"><br>如果通过并发,无限到达数据库, 就容易给数据库弄垮<br><strong>解决办法</strong></p><ol><li><strong>数据库返回NUll对象,缺点是有额外的内存消耗(可以设置TTL解决)</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151041627-5b3c3aea-5d04-4717-8afc-d6622bd35dc9.png#averageHue=%23fafafa&clientId=u8a7806e8-b16d-4&from=paste&height=576&id=uab32b173&originHeight=720&originWidth=1646&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172693&status=done&style=none&taskId=u32000052-6e1e-429a-b628-48817bc2525&title=&width=1316.8" alt="image.png"></p><ol start="2"><li><strong>布隆过滤器</strong></li></ol><p>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151188719-0e6360f7-7e8f-4ef4-b388-f2f880690a5a.png#averageHue=%23f7f4f2&clientId=u8a7806e8-b16d-4&from=paste&height=589&id=u8698caf1&originHeight=736&originWidth=641&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143003&status=done&style=none&taskId=u5dfcd73b-9d0f-4f28-a98c-ee4dc90faa2&title=&width=512.8" alt="image.png"><br>通过哈希算法,将计算出来的放到布隆过滤器, 但有一点的穿透风险</p><h2 id="编码解决缓存穿透问题"><a href="#编码解决缓存穿透问题" class="headerlink" title="编码解决缓存穿透问题"></a>编码解决缓存穿透问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151426970-975a19c5-190a-4cbc-9cb8-7730a4e0eeae.png#averageHue=%23eeeceb&clientId=u8a7806e8-b16d-4&from=paste&height=724&id=ufd2bf6d2&originHeight=905&originWidth=2216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=489525&status=done&style=none&taskId=ud00847b5-9d3d-4995-92a5-3208ec8b719&title=&width=1772.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699152411753-22724bfd-50be-4397-a9d3-de819dfb08c6.png#averageHue=%232c2b2b&clientId=u8a7806e8-b16d-4&from=paste&height=821&id=ueccd8b74&originHeight=1026&originWidth=1725&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=182832&status=done&style=none&taskId=ucfa5cf87-6015-449d-abdb-63ddb17a991&title=&width=1380" alt="image.png"></p><pre><code class="java">  public Result queryById(Long id) &#123;        String key  = CACHE_SHOP_KEY +id;        // 从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 判断是否存在        //如果存在, 返回商铺信息        if(StrUtil.isNotBlank(shopJson))&#123;            Shop shop = JSONUtil.toBean(shopJson,Shop.class);            return  Result.ok(shop);        &#125;        // 判断命中的是否是空值        if (shopJson != null)&#123;            Result.fail(&quot;店铺不存在&quot;);        &#125;        //如果不存在, 查询数据库        Shop shop = getById(id);        // 判断数据库信息是否存在        //不存在则返回404        if (shop == null)&#123;            stringRedisTemplate.opsForValue().set(key, null, CACHE_NULL_TTL,TimeUnit.MINUTES);            return Result.fail(&quot;店铺不存在&quot;);        &#125;        // 存在, 则将商品信息写入redis        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);        return Result.ok(shop);    &#125;</code></pre><p>shopJson !&#x3D; null改成shopJson&#x3D;&#x3D;”” 会好理解一些<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699151837524-18fef19d-e4f4-44a6-9d1b-59bd831ed3b5.png#averageHue=%23f3f3f3&clientId=u8a7806e8-b16d-4&from=paste&height=606&id=ua6e3adc9&originHeight=757&originWidth=1159&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=258097&status=done&style=none&taskId=u63150d66-1512-4adc-8e89-cde31dd00fd&title=&width=927.2" alt="image.png"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时段大量的缓存key同时失效或者redis服务宕机, 导致大量请求数据库, 带来巨大的压力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699156133884-03a9e60a-e486-4753-855f-cb3d665e4f55.png#averageHue=%23f4f1f1&clientId=u8a7806e8-b16d-4&from=paste&height=708&id=u21bd2e8b&originHeight=885&originWidth=2131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=428063&status=done&style=none&taskId=ud80e8200-7410-4930-a7a7-94d2a5fff06&title=&width=1704.8" alt="image.png"></p><h2 id="2-8-缓存击穿"><a href="#2-8-缓存击穿" class="headerlink" title="2.8 缓存击穿"></a>2.8 缓存击穿</h2><p>某一个key在同一时间内被多次访问,这个key突然失效了, 就会在这个时间给数据库带来巨大的冲击力<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699164935235-f9e69e3a-9839-4988-bcf3-05fcc8bbe7e5.png#averageHue=%23eee7e0&clientId=u8a7806e8-b16d-4&from=paste&height=634&id=uedae8863&originHeight=792&originWidth=1375&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=184549&status=done&style=none&taskId=u07604b7c-d211-4032-a2fb-2c54e505ba2&title=&width=1100" alt="image.png"><br>线程1 本来是想查询数据库载入缓存, 但这时候同时又线程2, 3, 4 同时访问缓存, 都没有查到数据, 那么就会造成多个线程同时访问数据的情况 , 从而给数据带来巨大的压力.<br><strong>解决办法</strong></p><ul><li><strong>互斥锁</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165112699-f82c55bc-80d4-4901-93de-d12a6cc22f19.png#averageHue=%23f0efee&clientId=u8a7806e8-b16d-4&from=paste&height=885&id=u2a142e12&originHeight=1106&originWidth=858&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237978&status=done&style=none&taskId=ua33f7dbc-07cd-42f0-ba18-f5706ab877c&title=&width=686.4" alt="image.png"></p><ul><li>缓存过期</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165423813-dc9dfe19-82d4-4c5f-be78-48ffd666753d.png#averageHue=%23eae4e3&clientId=u4e51b1c4-2b80-4&from=paste&height=850&id=u953941fc&originHeight=1062&originWidth=1273&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=295603&status=done&style=none&taskId=ucbf9f236-40c4-4475-ac4c-726224769e3&title=&width=1018.4" alt="image.png"><br>返回的是过期的数据<br><strong>对比</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699165463393-d285571e-7568-4c7e-9424-8f549a8680ba.png#averageHue=%23e5cecd&clientId=u4e51b1c4-2b80-4&from=paste&height=741&id=uedc66771&originHeight=926&originWidth=2075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=217678&status=done&style=none&taskId=u83a615ea-ced1-49ae-8338-90263514659&title=&width=1660" alt="image.png"></p><h2 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699171874898-e4083975-1612-4c7b-b4e8-9ffb2336aa1f.png#averageHue=%23faf7f7&clientId=uad14f619-a4eb-4&from=paste&height=655&id=ud00ad32f&originHeight=819&originWidth=1703&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266694&status=done&style=none&taskId=uc956f7fb-48f5-4dfc-8727-1924bce78e9&title=&width=1362.4" alt="image.png">在多个线程并行执行的时候需要达到一个效果, 一个成功, 其他失败的效果<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699172055792-65c7c469-65fa-41f5-92dc-60fef825831e.png#averageHue=%230b2138&clientId=uad14f619-a4eb-4&from=paste&height=526&id=u02efe0ef&originHeight=657&originWidth=998&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=379673&status=done&style=none&taskId=ue71c7007-c3ba-448e-8a7a-5540e3405fc&title=&width=798.4" alt="image.png"></p><pre><code class="java"> public boolean  tryLock(String key)&#123;        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10L, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    &#125;    private   void delLock(String key)&#123;        stringRedisTemplate.delete(key);    &#125;</code></pre><pre><code class="java"> public Shop queryWithMutex(Long id)&#123;        String key  = CACHE_SHOP_KEY +id;        // 从redis查询商铺缓存         String shopJson = stringRedisTemplate.opsForValue().get(key);        // 判断是否存在        //如果存在, 返回商铺信息        if(StrUtil.isNotBlank(shopJson))&#123;            Shop shop = JSONUtil.toBean(shopJson,Shop.class);            return shop;        &#125;        // 判断命中的是否是空值        if (shopJson == &quot;&quot;)&#123;            Result.fail(&quot;店铺不存在&quot;);        &#125;        //1.如果不存在, 尝试获取互斥锁        String lock_key = &quot;lock:shop&quot;+key;        boolean flag = tryLock(lock_key);        // 1.1 判断是否获取锁        //1.2 没有获得互斥锁=&gt;  休眠        Shop shop = null;        try &#123;            if (!flag)&#123;                Thread.sleep(50);                return queryWithMutex(id);            &#125;            //1.3 获得互斥锁=&gt; 根据id查询数据库            shop = getById(id);            // 判断数据库信息是否存在            //不存在则返回错误信息            if (shop == null)&#123;                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);                return null;            &#125;            //1.4 将商铺数据写入redis            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //1.5 释放互斥锁            delLock(key);        &#125;        return shop;    &#125;</code></pre><h2 id="利用逻辑过期方式解决缓存击穿问题"><a href="#利用逻辑过期方式解决缓存击穿问题" class="headerlink" title="利用逻辑过期方式解决缓存击穿问题"></a>利用逻辑过期方式解决缓存击穿问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699193223625-18f4022d-72dd-473e-86e0-ab6d318323eb.png#averageHue=%23f8f4f4&clientId=uad14f619-a4eb-4&from=paste&height=707&id=u720bf9b2&originHeight=884&originWidth=1892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=451704&status=done&style=none&taskId=uc3f96aaf-10d2-4b74-a921-dae73e262f4&title=&width=1513.6" alt="image.png"><br><a href="https://blog.csdn.net/u012448904/article/details/84292821">https://blog.csdn.net/u012448904/article/details/84292821</a></p><pre><code class="java"> private void saveShop2RedisData(Long id, Long expireTime)&#123;        // 查询店铺数据        Shop shop = getById(id);        //封装逻辑过期时间        RedisData redisData = new RedisData();        redisData.setData(shop);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireTime));        // 将数据写入redis, 并设置过期时间       stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));    &#125;</code></pre><pre><code class="java">  private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);</code></pre><pre><code class="java">  public Shop queryWithLogicalExpire(Long id)&#123;        String key  = CACHE_SHOP_KEY +id;        // 从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 1.判断是否存在        //1.1 如果不存在        if (StrUtil.isBlank(shopJson))&#123;            return null;        &#125;        //1.2如果命中, 先把Json反序列化为对象        RedisData redisData =  JSONUtil.toBean(shopJson, RedisData.class);        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);        LocalDateTime expireTime = redisData.getExpireTime();        //2. 判断缓存是否过期        // 2.1 如果没有过期, 返回商品信息       if (expireTime.isAfter(LocalDateTime.now()))&#123;           return shop;       &#125;       // 3. 如果过期, 则需要缓存重建        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 3.1 如果获取到了互斥锁        try &#123;            if (isLock)&#123;                //开启独立线程, 实现缓存重建                CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;                    //重建缓存                    this.saveShop2RedisData(id,20L);                &#125;);            &#125;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            // 释放锁            delLock(lockKey);        &#125;        // 如果过期, 则直接返回商品信息        return shop;    &#125;</code></pre><h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699232522556-19d223a8-d12d-4403-85b3-b930bfb9f710.png#averageHue=%23ebebeb&clientId=ud845c73b-0205-4&from=paste&height=336&id=cd6f7&originHeight=672&originWidth=2300&originalType=binary&ratio=2&rotation=0&showTitle=false&size=362660&status=done&style=none&taskId=u169a78f1-9a1c-491f-9414-b91bb3abcdd&title=&width=1150" alt="image.png"><br>封装后的<code>CacheClient</code></p><pre><code class="java">package com.hmdp.utils;import cn.hutool.core.util.BooleanUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import com.hmdp.dto.Result;import com.hmdp.entity.Shop;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import org.yaml.snakeyaml.events.Event;import java.time.LocalDateTime;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.function.Function;import static com.hmdp.utils.RedisConstants.*;@Slf4j@Componentpublic class CacheClient &#123;     private StringRedisTemplate stringRedisTemplate;     private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);     public CacheClient(StringRedisTemplate stringRedisTemplate)&#123;          this.stringRedisTemplate = stringRedisTemplate;     &#125;     public void set(String key, Object value, Long time, TimeUnit timeUnit)&#123;          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);     &#125;     // 设置逻辑过期时间     public void  setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit)&#123;          RedisData redisData = new RedisData();          redisData.setData(value);          redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));          // 写入redis          stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value));     &#125;     public &lt;R,ID&gt; R queryWithThrough(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack     ,Long time, TimeUnit timeUnit)&#123;          String key  = prefix +id;          // 从redis查询商铺缓存          String json = stringRedisTemplate.opsForValue().get(key);          // 判断是否存在          //如果存在, 返回商铺信息          if(StrUtil.isNotBlank(json))&#123;          // 存在, 直接返回               return JSONUtil.toBean(json, type);          &#125;          // 判断命中的是否是空值          if (json == &quot;&quot;)&#123;               Result.fail(&quot;店铺不存在&quot;);          &#125;          //如果不存在, 查询数据库          R r = dbFailBack.apply(id);          // 判断数据库信息是否存在          //不存在则返回错误信息          if (r == null)&#123;               stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);               return null;          &#125;          // 存在, 则将商品信息写入redis         this.set(key,r, time, timeUnit);          return r;     &#125;     // 逻辑过期解决缓存击穿     public &lt;R,ID&gt;R queryWithLogicalExpire(String prefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt; dbFailBack             ,Long time, TimeUnit timeUnit)&#123;          String key  = prefix +id;          // 从redis查询商铺缓存          String json = stringRedisTemplate.opsForValue().get(key);          // 1.判断是否存在          //1.1 如果不存在          if (StrUtil.isBlank(json))&#123;               return null;          &#125;          //1.2如果命中, 先把Json反序列化为对象          RedisData redisData =  JSONUtil.toBean(json, RedisData.class);          R r = JSONUtil.toBean((JSONObject)redisData.getData(), type);          LocalDateTime expireTime = redisData.getExpireTime();          //2. 判断缓存是否过期          // 2.1 如果没有过期, 返回商品信息          if (expireTime.isAfter(LocalDateTime.now()))&#123;               return r;          &#125;          // 3. 如果过期, 则需要缓存重建          String lockKey = LOCK_SHOP_KEY + id;          boolean isLock = tryLock(lockKey);          // 3.1 如果获取到了互斥锁          try &#123;               if (isLock)&#123;                    R r1 = dbFailBack.apply(id);                    //开启独立线程, 实现缓存重建                    CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;                         //重建缓存                         this.setWithLogicalExpire(key,r1,time,timeUnit);                    &#125;);               &#125;          &#125; catch (Exception e) &#123;               throw new RuntimeException(e);          &#125; finally &#123;               // 释放锁               delLock(lockKey);          &#125;          // 如果过期, 则直接返回商品信息          return r;     &#125;     public boolean  tryLock(String key)&#123;          Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10L, TimeUnit.SECONDS);          return BooleanUtil.isTrue(flag);     &#125;     private  void delLock(String key)&#123;          stringRedisTemplate.delete(key);     &#125;&#125;</code></pre><dl><dt>里面分别封装了解决缓存穿透和逻辑过期解决缓存击穿的两个函数<br>在通过逻辑过期解决缓存击穿问题中遇到入<code>   R r = JSONUtil.toBean((JSONObject)redisData.getData(), type);</code>  <code>redisData</code>为空的情况</dt><dd>解决办法<br><a href="https://blog.csdn.net/uiguion/article/details/106047677">JSONObject.toBean()方法转成对象报错，或者bean属性全为null-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372507632-4139d56e-787c-4399-a44d-abc6640a24fb.png#averageHue=%239c7544&clientId=u03392ae4-edfa-4&from=paste&height=325&id=uaa40b9c8&originHeight=325&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53374&status=done&style=none&taskId=uc57e265d-757a-444a-8936-5e6c833c53c&title=&width=1401" alt="image.png"><br>不要小写</dd></dl><p>使用Redis工具类:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699372542710-3d357c3b-7365-49fd-9a33-4f850fb63e14.png#averageHue=%232d2c2c&clientId=u03392ae4-edfa-4&from=paste&height=374&id=u87a92367&originHeight=374&originWidth=1629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57706&status=done&style=none&taskId=u4d0ee664-0235-4b98-9707-755d8d45d63&title=&width=1629" alt="image.png"></p><blockquote><p>在逻辑过期中,封装了<code>RedisData</code>是为了将数据和其对应的过期时间封装到一起处理 </p></blockquote><h2 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h2><h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而 订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>当把表进行拆分, 也会破坏这种唯一性<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699426255848-40136d31-4503-444f-9155-5fafaf1a0bdc.png#averageHue=%23fbf2f2&clientId=u03392ae4-edfa-4&from=paste&height=166&id=u64d05cd3&originHeight=208&originWidth=1134&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19066&status=done&style=none&taskId=ucef96a17-421f-4ead-98a3-0f7b4f44969&title=&width=907.2" alt="image.png"><br>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p> 时间戳：31bit，以秒为单位，可以使用69年<br>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><pre><code class="java">@Componentpublic class RedisWorker &#123;    /**     * 开始时间戳     */    private static final long BEGIN_TIMESTAMP = 1640995200L;    /**     * 序列号的位数     */    private static final int COUNT_BITS = 32;    StringRedisTemplate stringRedisTemplate;    public RedisWorker(StringRedisTemplate stringRedisTemplate)&#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public  long nextId(String prefix)&#123;        //1.生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        //2. 生成序列号,精确到天,确保序列号不会被占满        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot;+prefix+&quot;:&quot;+date);        //拼接并返回        return timestamp&lt;&lt;COUNT_BITS|  ;    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699451963201-96d090a8-10c9-45e5-a77d-09a80bc9bb70.png#averageHue=%23f3f7f1&clientId=u03392ae4-edfa-4&from=paste&height=464&id=u92c542a6&originHeight=580&originWidth=2065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=372721&status=done&style=none&taskId=u9b6d7e2b-ddcc-439b-8c70-4f17bf917b9&title=&width=1652" alt="image.png"></p><pre><code class="java"> @Test    void testIdWorker() throws InterruptedException &#123;        CountDownLatch latch = new CountDownLatch(300);        Runnable task = () -&gt; &#123;            for (int i = 0; i &lt; 100; i++) &#123;                long id = redisWorker.nextId(&quot;order&quot;);                System.out.println(&quot;id = &quot; + id);            &#125;            latch.countDown();        &#125;;        long begin = System.currentTimeMillis();        for (int i = 0; i &lt; 300; i++) &#123;            es.submit(task);        &#125;        latch.await();        long end = System.currentTimeMillis();        System.out.println(&quot;time = &quot; + (end - begin));    &#125;</code></pre><h2 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h2><p>平价券<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453018061-98e0c0ec-7b51-47c7-804a-3ad046f592e0.png#averageHue=%23f6f8f6&clientId=u03392ae4-edfa-4&from=paste&height=394&id=u52d9c459&originHeight=493&originWidth=1525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=584380&status=done&style=none&taskId=u68370840-18ab-4403-9307-b8ec30147fc&title=&width=1220" alt="image.png"><br><strong>秒杀券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699453049584-e0e2bbd2-5e0f-4db2-a0b7-300f056d5300.png#averageHue=%23eef0ed&clientId=u03392ae4-edfa-4&from=paste&height=301&id=ude83893e&originHeight=376&originWidth=1463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=406404&status=done&style=none&taskId=u307cfd87-d489-4177-a9b4-6bdc1093625&title=&width=1170.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699452886736-1cc3a40d-139d-4581-a74a-c8c5686c823b.png#averageHue=%23f1ecea&clientId=u03392ae4-edfa-4&from=paste&height=837&id=udf628ffe&originHeight=1046&originWidth=1904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557282&status=done&style=none&taskId=uf05654fe-beef-48a5-9b31-98eb188f656&title=&width=1523.2" alt="image.png"></p><h2 id="实现优惠券秒杀的下单功能"><a href="#实现优惠券秒杀的下单功能" class="headerlink" title="实现优惠券秒杀的下单功能"></a>实现优惠券秒杀的下单功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699491830080-d020dec5-6734-4da9-b359-0d0d60d22824.png#averageHue=%23faf8f8&clientId=u62c8c1ac-49eb-4&from=paste&height=718&id=ue1b324d1&originHeight=898&originWidth=1497&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=239141&status=done&style=none&taskId=uaacbd06a-3e0a-4874-bab7-52087d33fd3&title=&width=1197.6" alt="image.png"></p><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512912475-448ad530-a79a-493a-9a1b-6ff8dd9c0d1b.png#averageHue=%23ddded5&clientId=ua529897f-17be-4&from=paste&height=143&id=ua95713de&originHeight=286&originWidth=1642&originalType=binary&ratio=2&rotation=0&showTitle=false&size=211099&status=done&style=none&taskId=u58c38c8c-22d1-47c6-893c-b66827e1164&title=&width=821" alt="image.png"><br>在高并发的场景下， 库存变成了负数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699512954758-1083414b-371d-4821-8cee-70cde0636ffa.png#averageHue=%23637aa8&clientId=ua529897f-17be-4&from=paste&height=396&id=u4af4cf38&originHeight=792&originWidth=1996&originalType=binary&ratio=2&rotation=0&showTitle=false&size=471026&status=done&style=none&taskId=u99d7ebdc-d14a-4f3a-ad94-da9355b9a8f&title=&width=998" alt="image.png"><br>说明这一块的逻辑是有问题的<br>先查询-&gt;判断-&gt;减库存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513390567-d0602fd3-5f64-43a2-8adc-94ad44a21d21.png#averageHue=%23f5f5f5&clientId=ua529897f-17be-4&from=paste&height=612&id=ue45a8fd8&originHeight=1224&originWidth=2534&originalType=binary&ratio=2&rotation=0&showTitle=false&size=309881&status=done&style=none&taskId=u5b1e322d-15c6-4a68-a1b6-66f01a9da12&title=&width=1267" alt="image.png"><br><strong>解决方案：</strong><br>** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513646487-c306a577-0758-45bb-aae4-9e238dee5241.png#averageHue=%23f4f3f3&clientId=uaa6d1fb2-8a9a-4&from=paste&height=505&id=u4f34f58b&originHeight=1010&originWidth=2378&originalType=binary&ratio=2&rotation=0&showTitle=false&size=584418&status=done&style=none&taskId=uf944ddba-4b79-47a7-80de-6a14b5bab2b&title=&width=1189" alt="image.png"><br>乐观锁不用去加锁，而是在执行时才做判断，因此性能高</p><p><strong>乐观锁：</strong></p><ul><li>**版本号法： **</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699513930001-21760dc2-af8c-4d02-a702-e3c765847dd6.png#averageHue=%23fafafa&clientId=uaa6d1fb2-8a9a-4&from=paste&height=511&id=u581002a7&originHeight=1022&originWidth=2538&originalType=binary&ratio=2&rotation=0&showTitle=false&size=406163&status=done&style=none&taskId=u03c7ed5e-fb7d-47f6-854d-24371d40d2c&title=&width=1269" alt="image.png"><br>通过版本号来查是否需要-1，来避免超卖问题  </p><ul><li><strong>CAS</strong>优化版本号</li></ul><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699514621548-7c59ea00-55dc-4562-a416-74a211905a37.png#averageHue=%23fbfbfb&clientId=uaa6d1fb2-8a9a-4&from=paste&height=540&id=ubb7b39b4&originHeight=1080&originWidth=2496&originalType=binary&ratio=2&rotation=0&showTitle=false&size=373639&status=done&style=none&taskId=u0ffb655f-ec53-4e13-899d-3537570f4bd&title=&width=1248" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517224445-eea01797-f3b5-4895-a5f9-3e793409fd3d.png#averageHue=%23f2f7ef&clientId=u757ca0cc-a2af-4&from=paste&height=444&id=u6a5ec8e4&originHeight=888&originWidth=2546&originalType=binary&ratio=2&rotation=0&showTitle=false&size=739428&status=done&style=none&taskId=u690bc5ae-1e68-435d-9b63-fd67f80d615&title=&width=1273" alt="image.png"><br> <strong>但是这样就会有一个问题：当stock不为1的时候， 看stock来确定扣不扣减，就会造成更多人抢不到优惠券</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517619198-ba7b27ab-fea1-41bc-a470-87d9fcf71017.png#averageHue=%23f8f8f8&clientId=u757ca0cc-a2af-4&from=paste&height=204&id=u30b15279&originHeight=408&originWidth=1876&originalType=binary&ratio=2&rotation=0&showTitle=false&size=44498&status=done&style=none&taskId=ua120d0fb-d33f-4f68-b8c5-5ffd2253dc6&title=&width=938" alt="image.png">** **<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517538369-c1b3a1cc-e780-4aec-a3ac-9d7096938cf4.png#averageHue=%23f0f5eb&clientId=u757ca0cc-a2af-4&from=paste&height=140&id=ua90beb84&originHeight=280&originWidth=1962&originalType=binary&ratio=2&rotation=0&showTitle=false&size=277162&status=done&style=none&taskId=ue5bae5be-56b8-45d4-9984-881f5a5c952&title=&width=981" alt="image.png"><br>如果<code>stock&gt;0</code>,就可以购买优惠券</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699517838400-7ed70785-bf23-4533-a7c6-fae87940f329.png#averageHue=%23efefef&clientId=u757ca0cc-a2af-4&from=paste&height=333&id=u09d910b9&originHeight=666&originWidth=1222&originalType=binary&ratio=2&rotation=0&showTitle=false&size=232094&status=done&style=none&taskId=u3f41d4e9-e1f4-4df0-a6a8-270e463319b&title=&width=611" alt="image.png"></p><blockquote><p>对于更高并发的场景下， 光这样使用乐观锁是远远不够的， 需要进行进一步优化，</p></blockquote><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699518088817-4d0d4240-ae7d-479a-bec9-a4e3bf28bd6f.png#averageHue=%23fbf9f9&clientId=u757ca0cc-a2af-4&from=paste&height=562&id=ufa5d2047&originHeight=1124&originWidth=2036&originalType=binary&ratio=2&rotation=0&showTitle=false&size=361555&status=done&style=none&taskId=ueffa5321-5918-4f42-966e-a1d7dbe937d&title=&width=1018" alt="image.png"><br>事务失效的情况:<br>加锁<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699693153645-12717c5e-49c8-4d75-92f6-ce805fa03602.png#averageHue=%23f0f5ef&clientId=u2b828817-5288-4&from=paste&height=842&id=u873f76a6&originHeight=842&originWidth=1957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=512561&status=done&style=none&taskId=u89ad8637-7e27-4b78-b23e-60e3f15831a&title=&width=1957" alt="image.png"></p><pre><code class="java"> @Override    @Transactional    public Result seckillVoucher(Long voucherId) &#123;        Long userId = UserHolder.getUser().getId();        synchronized (userId.toString().intern())&#123;            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125;    &#125;        public Result createVoucherOrder(Long voucherId)&#123;            // 1. 提交优惠券id            //2. 查询优惠券信息            SeckillVoucher voucher = seckillVoucherService.getById(voucherId);            //3. 判断秒杀是否开始            //3.1 如果没有开始, 返回异常结果            if (voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;                Result.fail(&quot;秒杀尚未开始&quot;);            &#125;            // 3.2 判断秒杀是否已经结束            if (LocalDateTime.now().isAfter(voucher.getEndTime()))&#123;                Result.fail(&quot;秒杀已经结束&quot;);            &#125;            // 4. 秒杀开始, 判断库存是否充足            if (voucher.getStock() &lt; 1)&#123;                //4.1 不足, 返回异常结果                Result.fail(&quot;库存不足&quot;);            &#125;            // 实现一人一单            Long userId = UserHolder.getUser().getId();            int count = query().eq(&quot;user_id&quot;,userId).eq(&quot;voucher_id&quot;,voucherId).count();            if (count &gt; 0)&#123;                Result.fail(&quot;用户已经购买过一次&quot;);            &#125;            //4.2 充足, 扣减库存            boolean isSuccess = seckillVoucherService.update().setSql(&quot;stock=stock-1&quot;)                    .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;,0) // 如果大于0就能购买优惠券                    .update();            if (!isSuccess)&#123;                return  Result.fail(&quot;库存不足&quot;);            &#125;            //4.3 创建订单            VoucherOrder voucherOrder = new VoucherOrder();            long orderId = redisWorker.nextId(&quot;order&quot;);            voucherOrder.setId(orderId);            voucherOrder.setUserId(userId);            voucherOrder.setVoucherId(voucherId);            save(voucherOrder);            //4.4 返回订单id            return Result.ok(orderId);        &#125;</code></pre><p><a href="https://blog.csdn.net/hanjiaqian/article/details/120501741">【精选】spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常_hanjq_code的博客-CSDN博客</a></p><h2 id="一人一单并发安全问题"><a href="#一人一单并发安全问题" class="headerlink" title="一人一单并发安全问题"></a>一人一单并发安全问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699705699282-d6e5cfc6-d0b1-4692-9045-b3bd7c1752b0.png#averageHue=%23f0eded&clientId=u2b828817-5288-4&from=paste&height=990&id=u2b5403a6&originHeight=990&originWidth=2087&originalType=binary&ratio=1&rotation=0&showTitle=false&size=506190&status=done&style=none&taskId=u76807860-0e90-4ec5-ace9-4f40d89a0bc&title=&width=2087" alt="image.png"><br>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763384484-e83248bd-53cc-43e6-b5b2-1aa92f9982c2.png#averageHue=%23f4f2f2&clientId=u2b828817-5288-4&from=paste&height=864&id=ufa6eb578&originHeight=1080&originWidth=2262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=482845&status=done&style=none&taskId=uf703bade-d8ba-409f-ba8e-9c0101b0700&title=&width=1809.6" alt="image.png"><br>让多个JVM都能看到同一个锁监视器<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699763801336-f81b5646-caff-4432-bfb4-7ddf5afaa5a9.png#averageHue=%23e4d5d5&clientId=u2b828817-5288-4&from=paste&height=1001&id=uc6a8dd14&originHeight=1001&originWidth=2209&originalType=binary&ratio=1&rotation=0&showTitle=false&size=366621&status=done&style=none&taskId=u9cb2dfa0-cdd0-4344-9431-950df9bda81&title=&width=2209" alt="image.png"></p><h2 id="Redis分布式锁实现思路"><a href="#Redis分布式锁实现思路" class="headerlink" title="Redis分布式锁实现思路"></a>Redis分布式锁实现思路</h2><p><a href="https://blog.csdn.net/huo065000/article/details/119970629">【精选】redis分布式锁(一）set NX实现_心心念念的小鼠标的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764476731-6ac1814f-7f3f-4442-b0af-43405c724fd9.png#averageHue=%23102a3d&clientId=u2b828817-5288-4&from=paste&height=298&id=uadcf17e7&originHeight=298&originWidth=1888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235838&status=done&style=none&taskId=uea343540-7380-459c-bb72-201b12a7257&title=&width=1888" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699764614586-e1387af2-56e8-4cc4-a022-c87c0a93bb55.png#averageHue=%23f9f8f8&clientId=u2b828817-5288-4&from=paste&height=1031&id=u34b6c92a&originHeight=1031&originWidth=2069&originalType=binary&ratio=1&rotation=0&showTitle=false&size=460353&status=done&style=none&taskId=u61d17e47-f8a8-43d1-84b2-2d401efb444&title=&width=2069" alt="image.png"></p><h2 id="实现分布式锁初级版本"><a href="#实现分布式锁初级版本" class="headerlink" title="实现分布式锁初级版本"></a>实现分布式锁初级版本</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771133816-3aa47901-f070-4aa4-924f-e0f8dc690bb4.png#averageHue=%23faf9f8&clientId=u2b828817-5288-4&from=paste&height=781&id=uace818c4&originHeight=859&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188710&status=done&style=none&taskId=u70b504e5-e6d1-4ed9-a8c6-5c9baa37a74&title=&width=699.0908939385221" alt="image.png"></p><ul><li><strong>锁的基本接口</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699770874269-dc390610-18b3-4234-8c58-280d2c2e64b4.png#averageHue=%23f0f3ee&clientId=u2b828817-5288-4&from=paste&height=415&id=u965c0e3d&originHeight=415&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117726&status=done&style=none&taskId=ubc19fde2-7ab1-4e2d-8c5c-37256633aa9&title=&width=1037" alt="image.png"></p><ul><li><strong>SimpleRedisLock</strong></li></ul><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><pre><code class="java">package com.hmdp.utils;import org.springframework.data.redis.core.StringRedisTemplate;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;public class SimpleRedis implements ILock &#123;    private String name;    StringRedisTemplate stringRedisTemplate;    public SimpleRedis(String name, StringRedisTemplate stringRedisTemplate) &#123;        this.name = name;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    private static final String KEY_PREFIX=&quot;lock :&quot;;    @Override    public boolean tryLock(long longTimeSec) &#123;        //获取线程标识        long id = Thread.currentThread().getId();        //获取锁        Boolean aBoolean = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, id + &quot;&quot;, longTimeSec, TimeUnit.SECONDS);        // 避免自动拆箱        return Boolean.TRUE.equals(aBoolean) ;    &#125;    @Override    public void unLock() &#123;        stringRedisTemplate.delete(KEY_PREFIX + name);        return;    &#125;&#125;</code></pre><ul><li>修改业务代码</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771107955-f9d0ac98-aad1-4920-a963-a22da1ace571.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1185&id=u17f30d65&originHeight=1304&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174600&status=done&style=none&taskId=uc3445396-9b6e-48fa-b184-5190fc14a44&title=&width=1099.9999761581425" alt="image.png"></p><h2 id="Redis分布式锁的误删问题"><a href="#Redis分布式锁的误删问题" class="headerlink" title="Redis分布式锁的误删问题"></a>Redis分布式锁的误删问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771472494-df7802e3-1e3e-48db-a2be-11d3466f206b.png#averageHue=%23fbfafa&clientId=u2b828817-5288-4&from=paste&height=781&id=u7f928350&originHeight=859&originWidth=2200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=326266&status=done&style=none&taskId=u96caefbb-0f03-4002-8df2-fafa9619487&title=&width=1999.9999566511683" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771503937-7b6b9c51-b148-4087-85f5-5e40d94de5a5.png#averageHue=%23edebeb&clientId=u2b828817-5288-4&from=paste&height=785&id=u69cf30e6&originHeight=864&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157135&status=done&style=none&taskId=u1afa3fa6-c0ca-4a34-a934-49729056b1e&title=&width=750.9090746335751" alt="image.png"><br>在释放锁之前增加一层判断逻辑</p><h2 id="解决锁的误删问题"><a href="#解决锁的误删问题" class="headerlink" title="解决锁的误删问题"></a>解决锁的误删问题</h2><p><a href="https://www.cnblogs.com/jasonboren/p/12939852.html">java UUID的作用和使用 - jason小蜗牛 - 博客园</a><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699771765473-775cddd0-965a-4408-9acc-934cbec110d0.png#averageHue=%23f3f2f2&clientId=u2b828817-5288-4&from=paste&height=498&id=u09492cfa&originHeight=548&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&size=240179&status=done&style=none&taskId=u64ef6819-7ec7-4225-bb5c-40c34a513c1&title=&width=1151.8181568531957" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699772446928-2bb328ee-e2f8-4e78-b3b8-1fe4f5b17083.png#averageHue=%232c2c2b&clientId=u2b828817-5288-4&from=paste&height=1118&id=u58788f34&originHeight=1230&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206341&status=done&style=none&taskId=u97a17e7e-6ba0-4459-9bfe-bc617761e6c&title=&width=1450.909059461484" alt="image.png"></p><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699796424412-f2c361aa-52b8-4395-81ef-b1628281fd56.png#averageHue=%23f5f3f3&clientId=u24e974b6-b49d-4&from=paste&height=866&id=uf39233f4&originHeight=866&originWidth=2162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=504589&status=done&style=none&taskId=ud0a673e8-d152-4459-983c-188bfa3615a&title=&width=2162" alt="image.png"></p><h2 id="Lua解决多条命令原子性问题"><a href="#Lua解决多条命令原子性问题" class="headerlink" title="Lua解决多条命令原子性问题"></a>Lua解决多条命令原子性问题</h2><p><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a><br>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。<br>可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699880933064-77dee115-28f2-45cc-9773-6f6a5e124376.png#averageHue=%23d3d4d2&clientId=u92f804e2-0ef3-4&from=paste&height=638&id=u99462bf3&originHeight=798&originWidth=1620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=374301&status=done&style=none&taskId=u506ee292-5250-4856-9db0-a03c13e6c4d&title=&width=1296" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881087375-df2ee1b5-d8de-4f04-95b3-f1f9f415392f.png#averageHue=%23d4d7ce&clientId=u92f804e2-0ef3-4&from=paste&height=631&id=u56132fa4&originHeight=789&originWidth=1980&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=450447&status=done&style=none&taskId=u711f0716-833b-4d54-abf2-1c92700e50a&title=&width=1584" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881108549-4fc8f91d-920a-4b92-abba-c1067984756c.png#averageHue=%230e283c&clientId=u92f804e2-0ef3-4&from=paste&height=438&id=ufa0cda3a&originHeight=548&originWidth=1831&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=424857&status=done&style=none&taskId=ucfaaba09-ac69-4b7f-9153-cd3d2cfb9c4&title=&width=1464.8" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881232331-845d5b44-b145-4e58-9fed-20a28245927a.png#averageHue=%238ac2a2&clientId=u92f804e2-0ef3-4&from=paste&height=275&id=u8841d17e&originHeight=344&originWidth=2182&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=316067&status=done&style=none&taskId=u4b4b0479-e121-4cc0-b8b7-79ba8438af2&title=&width=1745.6" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881493990-b8608b49-856e-48fd-8c89-fd9adab0eef6.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=556&id=u217bfdf2&originHeight=695&originWidth=1642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=460710&status=done&style=none&taskId=ucc2afb76-fb02-468e-8334-95ed95e25b7&title=&width=1313.6" alt="image.png"><br>优化后:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881563797-921e1dbf-f656-419e-b0f3-8f047a74ec57.png#averageHue=%23d3dcd0&clientId=u92f804e2-0ef3-4&from=paste&height=353&id=u409c8838&originHeight=441&originWidth=1908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=409800&status=done&style=none&taskId=ud7f2cc77-b11a-428e-961d-17caf406a5a&title=&width=1526.4" alt="image.png"></p><h2 id="再次改进Redis的分布式锁"><a href="#再次改进Redis的分布式锁" class="headerlink" title="再次改进Redis的分布式锁"></a>再次改进Redis的分布式锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699881705712-7b360bee-7d40-4dbb-a339-9c6eaebe02a9.png#averageHue=%23ecefe7&clientId=u92f804e2-0ef3-4&from=paste&height=751&id=u9ae334e3&originHeight=939&originWidth=1913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=592210&status=done&style=none&taskId=u1225738a-2bcb-4bea-bb86-1caaf4d9339&title=&width=1530.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882174692-9e036f2c-ef32-4bea-a179-9bfea183a8e4.png#averageHue=%23f0f5ef&clientId=u92f804e2-0ef3-4&from=paste&height=871&id=u40b269f1&originHeight=1089&originWidth=1722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=518841&status=done&style=none&taskId=u4c0e6e69-a223-45fc-973e-3393b5e0bb7&title=&width=1377.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699882344511-6207e555-2c39-4f2e-9bdf-ea38db59b776.png#averageHue=%23efefef&clientId=u92f804e2-0ef3-4&from=paste&height=427&id=ufd8c3a1b&originHeight=534&originWidth=1071&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223373&status=done&style=none&taskId=uad9dd949-1b2c-4817-8c6e-7dcdd58f793&title=&width=856.8" alt="image.png"></p><h2 id="Redisson功能介绍"><a href="#Redisson功能介绍" class="headerlink" title="Redisson功能介绍"></a>Redisson功能介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1699979826880-5d8dda27-fa55-4c01-96aa-4b8a7b45ac1f.png#averageHue=%23fcfcfc&clientId=ub5bfeee0-49d7-4&from=paste&height=517&id=u83b9b5cf&originHeight=1034&originWidth=2120&originalType=binary&ratio=2&rotation=0&showTitle=false&size=600636&status=done&style=none&taskId=udc199d20-1fa7-4ced-9073-3f467d8844e&title=&width=1060" alt="image.png"></p><h2 id="Redisson可重入锁原理原理"><a href="#Redisson可重入锁原理原理" class="headerlink" title="Redisson可重入锁原理原理"></a>Redisson可重入锁原理原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018645762-279974a1-1dd6-45ca-9137-7d97dcf1722b.png#averageHue=%23f2f4ef&clientId=u581ad08b-35c6-4&from=paste&height=631&id=u985b8ce9&originHeight=1262&originWidth=2514&originalType=binary&ratio=2&rotation=0&showTitle=false&size=949703&status=done&style=none&taskId=u48284284-8e00-42df-b8e4-fd63c27ab94&title=&width=1257" alt="image.png"><br>通过执行任务完成减1来实现。<br>但这么复杂的逻辑。 需要通过Lua脚本来实现，确保原子性。<br>获取锁过程。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700018849312-e6676ce5-f980-445b-995c-1946733368bf.png#averageHue=%23eff1eb&clientId=u581ad08b-35c6-4&from=paste&height=614&id=u9a7b9e93&originHeight=1228&originWidth=2530&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1223900&status=done&style=none&taskId=u4de41c11-5b16-4b1b-8219-d5138838503&title=&width=1265" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019201833-de25b267-f566-4248-b001-6b3219bc861d.png#averageHue=%23eef1eb&clientId=u581ad08b-35c6-4&from=paste&height=595&id=ua4c740d1&originHeight=1190&originWidth=2492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1177806&status=done&style=none&taskId=ue12f011f-611b-497c-9475-5d181fbae4d&title=&width=1246" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019729671-7907b6e9-3ce3-46f2-9c2f-15af55b0f90a.png#averageHue=%23e7eee5&clientId=u581ad08b-35c6-4&from=paste&height=538&id=ufe7345c9&originHeight=1076&originWidth=2676&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1379062&status=done&style=none&taskId=uecac0475-8044-4070-baae-172b3f09512&title=&width=1338" alt="image.png"><br>tryLock底层就是用了Lua脚本<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700019806532-f028d6ff-e7b6-4d6a-8d84-bd814933273d.png#averageHue=%23eff5ec&clientId=u581ad08b-35c6-4&from=paste&height=509&id=u15053e07&originHeight=1018&originWidth=2654&originalType=binary&ratio=2&rotation=0&showTitle=false&size=917520&status=done&style=none&taskId=u0fb71384-75f0-4ea9-a6ff-8eb71718abb&title=&width=1327" alt="image.png"><br>核心就是通过Hash结构来记录锁的调用次数。<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700055978583-286839e3-3017-4406-90df-b6e930f55ab0.png#averageHue=%23f4f2f2&clientId=u50dd14e7-a648-4&from=paste&height=760&id=uca34f263&originHeight=760&originWidth=1843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=316805&status=done&style=none&taskId=u973abdad-f003-4415-a81a-05f0d2801d3&title=&width=1843" alt="image.png"></p><h2 id="基于redis分布式锁优化"><a href="#基于redis分布式锁优化" class="headerlink" title="基于redis分布式锁优化"></a>基于redis分布式锁优化</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056217601-0c6e7d65-7fab-45c1-9989-38132616d579.png#averageHue=%23f9f0ef&clientId=u50dd14e7-a648-4&from=paste&height=761&id=ub1c7888f&originHeight=951&originWidth=1840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=342512&status=done&style=none&taskId=uf5e10912-f68c-4b07-a9c1-5b60e80ea2a&title=&width=1472" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056481920-222e2d99-5e68-4a84-86d3-14bae28ffa37.png#averageHue=%23f5e6e5&clientId=u50dd14e7-a648-4&from=paste&height=782&id=u834d1a86&originHeight=977&originWidth=2234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=496050&status=done&style=none&taskId=u16887b86-dff6-4f7c-a321-a688a0d78a0&title=&width=1787.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700056738489-ecee9d44-ea43-4c3e-abd0-cb305af85adc.png#averageHue=%23f2f7f1&clientId=u50dd14e7-a648-4&from=paste&height=403&id=u87f6f193&originHeight=504&originWidth=1681&originalType=binary&ratio=1&rotation=0&showTitle=false&size=295692&status=done&style=none&taskId=ufa3ae324-8dce-4a6c-8ff7-33f9d1d079b&title=&width=1344.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700057236183-e8f70303-b73e-4043-ae37-5c1415ded4b6.png#averageHue=%23eeeeee&clientId=u50dd14e7-a648-4&from=paste&height=733&id=ua4c7a83f&originHeight=916&originWidth=1222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391430&status=done&style=none&taskId=ua38b47d1-6d94-4778-9c98-ba092437f32&title=&width=977.6" alt="image.png"></p><h1 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108211115-77067f67-a25b-48e4-8bc2-a573d82fb72d.png#averageHue=%23fbf8f7&clientId=u3efe4494-fe3d-4&from=paste&height=1055&id=u7b2571e0&originHeight=1055&originWidth=2165&originalType=binary&ratio=1&rotation=0&showTitle=false&size=393738&status=done&style=none&taskId=u57881431-e1b4-4e7f-a0f1-14fdc052a34&title=&width=2165" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108448724-60d6a6e1-e83c-4eda-bff2-8ce93f1286c1.png#averageHue=%23faf7f6&clientId=u3efe4494-fe3d-4&from=paste&height=1002&id=u58a39a79&originHeight=1002&originWidth=2181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=432047&status=done&style=none&taskId=u52738e3a-12a1-4fc3-8241-c320d24c34f&title=&width=2181" alt="image.png"><br>使用Lua脚本保证原子性<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700108815144-7c7f9c4e-1e85-4a10-878f-e519097dbc39.png#averageHue=%23f4f0f0&clientId=u3efe4494-fe3d-4&from=paste&height=1037&id=u44050025&originHeight=1037&originWidth=2257&originalType=binary&ratio=1&rotation=0&showTitle=false&size=446673&status=done&style=none&taskId=ufd15cf1f-404c-4a32-b5b0-1350b67aec7&title=&width=2257" alt="image.png"><br>为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。<br>可以将耗时较短的两步操作放到 Redis 中，在 Redis 中处理对应的秒杀资格的判断。Redis 的性能是比 MySQL 要好的。此外，还需要引入异步队列记录相关的信息。<br>redis部分处理逻辑， Lua脚本封装操作保证原子性， redis这里选择的存储类型为set，因为key不能重复，而set恰好是无序不重复的<br><strong>基于Redis实现秒杀资格判断</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143137919-cce8210f-eb55-4cb3-bb70-da4607a4e40c.png#averageHue=%23f1efef&clientId=u3efe4494-fe3d-4&from=paste&height=524&id=u1b444d16&originHeight=524&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=275261&status=done&style=none&taskId=u9d3d2a8e-d869-43ab-b8c7-412b7836f55&title=&width=1353" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700142114007-8be488d5-8675-44a7-8b42-e48a81b29293.png#averageHue=%230f263c&clientId=u3efe4494-fe3d-4&from=paste&height=494&id=ubcf455b5&originHeight=494&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293776&status=done&style=none&taskId=u2a5cd725-d0d0-47cb-a1a6-437db6b30cd&title=&width=1488" alt="image.png"></p><ul><li>新增优惠券同时,将优惠券信息保存到Redis中</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700143188577-2b7e916f-5102-4a7a-93e3-eb4ec45367b6.png#averageHue=%232c2c2b&clientId=u3efe4494-fe3d-4&from=paste&height=555&id=u4976e03b&originHeight=555&originWidth=1658&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74949&status=done&style=none&taskId=uf10ee419-96a5-4062-a0f5-89a0a83cfcd&title=&width=1658" alt="image.png"></p><ul><li>基于Lua脚本, 判断秒杀库存,一人一单,决定用户是否抢购成功</li></ul><pre><code class="lua">-- 1.1 订单idlocal voucherId = ARGV[1]-- 1.2 用户idlocal useId = ARGV[2]-- 数据key-- 2.1 库存keylocal stockKey = &#39;seckill:stock:&#39; .. voucherId-- 2.2 订单keylocal orderKey = &#39;seckill:order:&#39; .. voucherId-- 3.脚本业务-- 3.1 判断库存是否充足 get stockKeyif (tonumber(redis.call(&#39;get&#39;,stockKey)) &lt;= 0) then    -- 不足返回1    return 1end-- 3.2 库存充足,sismember看userId是否存在于orderIdif (redis.call(&#39;sismember&#39;, orderKey, userId) == 1) then    -- 3.3 如果存在,说明下单了,返回2    return 2end-- 3.4 扣减库存 incrby stockKey -1redis.call(&#39;incriby&#39;, stockKey, -1)-- 3.5下单(保存用户)redis.call(&#39;sadd&#39;, orderKey, userId)</code></pre><ul><li>java代码中执行lua脚本，并判断，抢购成功的生成订单并存入阻塞队列<br>首先注入脚本</li></ul><pre><code class="java">    private IVoucherOrderService proxy;//定义代理对象，提前定义后面会用到    //注入脚本    private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;    static &#123;        SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;();        SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;));        SECKILL_SCRIPT.setResultType(Long.class);    &#125;</code></pre><p>运行脚本，且判断不满足的请求直接返回提示信息</p><pre><code class="java">    @Override    public Result seckillVoucher(Long voucherId) &#123; //使用lua脚本        //获取用户        Long userId = UserHolder.getUser().getId();        //1.执行lua脚本        Long result = stringRedisTemplate.execute(                SECKILL_SCRIPT,                Collections.emptyList(), //这里是key数组，没有key，就传的一个空集合                voucherId.toString(), userId.toString()        );        //2.判断结果是0        int r = result.intValue();//Long型转为int型，便于下面比较        if (r != 0)&#123;            //2.1 不为0，代表没有购买资格            return  Result.fail(r == 1?&quot;优惠券已售罄&quot;:&quot;不能重复购买&quot;);        &#125;</code></pre><p>最后是将满足条件的给存放进阻塞队列中<br>创建一个BlockingQueue阻塞队列</p><blockquote><p><strong>BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素</strong></p></blockquote><pre><code class="java">//创建阻塞队列  这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒获取    private BlockingQueue&lt;VoucherOrder&gt; orderTasks = new ArrayBlockingQueue&lt;&gt;(1024 * 1024);//初始化阻塞队列的大小</code></pre><p>接下来就是将满足条件的请求，给生成订单，并把订单对象add到阻塞队列中，接上面的代码，完成整个第三步</p><pre><code class="java">        //2.2 为0，有购买资格，把下单信息保存到阻塞队列中        //7.创建订单   向订单表新增一条数据，除默认字段，其他字段的值需要set        VoucherOrder voucherOrder = new VoucherOrder();        //7.1订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        //7.2用户id        voucherOrder.setUserId(userId);        //7.3代金券id        voucherOrder.setVoucherId(voucherId);        //放入阻塞对列中        orderTasks.add(voucherOrder);        //获取代理对象        proxy = (IVoucherOrderService) AopContext.currentProxy();        //3.返回订单id        return Result.ok(orderId);    &#125;</code></pre><p>4.开启线程任务，实现异步下单功能<br>首先创建一个线程池<br>再定义一个线程任务，但是注意，线程任务需要在用户秒杀订单之前开始，用户一但开始秒杀，队列就会有新的订单，线程任务就应该立即取出订单信息，<strong>这里利用spring提供的注解，在类初始化完毕后立即执行线程任务。</strong></p><pre><code class="java">    //创建线程池    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();    //利用spring提供的注解，在类初始化完毕后立即执行线程任务    @PostConstruct    private void init()&#123;        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());    &#125;</code></pre><p>线程任务代码如下</p><pre><code class="java">    //创建线程任务，内部类方式    private class VoucherOrderHandler implements Runnable&#123;        @Override        public void run() &#123;            //1.获取队列中的订单信息            try &#123;                VoucherOrder voucherOrder = orderTasks.take();                //2.创建订单，这是调之前那个创建订单的方法，需要稍作改动                handleVoucherOrder(voucherOrder);            &#125; catch (Exception e) &#123;                log.info(&quot;异常信息:&quot;,e);            &#125;        &#125;    &#125;</code></pre><p>创建调用的handleVoucherOrder方法，这里的获取锁操作只是做最后的兜底，以防万一，因为前面lua脚本都已经判断过了</p><pre><code class="java">    private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;        Long userId = voucherOrder.getUserId();        //创建锁对象        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        //获取锁        boolean isLock = lock.tryLock(1200);        //判断是否获取锁成功        if (!isLock)&#123;            log.error(&quot;您已购买过该商品，不能重复购买&quot;);        &#125;        try &#123;            proxy.createVoucherOrder(voucherOrder);//使用代理对象，最后用于提交事务        &#125; catch (IllegalStateException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            lock.unlock();//释放锁        &#125;    &#125;</code></pre><p>createVoucherOrder创建订单方法，这里一人一单的其实也不必判读了，lua脚本都写好了，这里只是兜底</p><pre><code class="java"> @Transactional    public void createVoucherOrder(VoucherOrder voucherOrder)&#123;        Long voucherId = voucherOrder.getVoucherId();        //5.一人一单        Long userId = voucherOrder.getId();        //5.1查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        //5.2判断是否存在        if (count &gt; 0)&#123;            log.error(&quot;您已经购买过了&quot;);        &#125;        //6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;)//set stock = stock -1                .eq(&quot;voucher_id&quot;,voucherId).gt(&quot;stock&quot;,0) //where id = ? and stock &gt; 0                .update();        if (!success)&#123;            log.error(&quot;库存不足！&quot;);        &#125;        this.save(voucherOrder);    &#125;</code></pre><p>最后来分析以下整个优化思路</p><p>①编写lua脚本，对于超卖问题和一人一单进行解决处理，超卖用CAS方法判断库存是否大于0，一人一单用redis的set集合的sismenber判读该优惠券（key）下的用户id（value）是否唯一<br>②Java代码中注入脚本，并执行脚本判断脚本返回结果，若不为脚本结果0，直接返回错误提示<br>③若脚本结果为0，代表有购买优惠券资格，将new VoucherOrder创建订单对象，并set orderId，userId，voucherId。再把订单对象放入阻塞队列中，返回订单id给用户<br>④创建线程池，并定义线程任务，但注意，线程任务必须在方法执行前执行，使用到spring提供的注解在类初始化完成后执行线程任务<br>⑤线程任务中获取阻塞队列的订单对象，然后调用handleVoucherOrder方法传入voucherOrder<br>⑥handleVoucherOrder方法其实是再次获取锁，这个就是个纯兜底，作用不大。并在获取锁成功后调用createVoucherOrder方法扣减库存创建订单，由于都是对数据库的操作，因此要提交事务</p><h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192287868-9a1187af-243a-48bc-aa09-c915e6be9d49.png#averageHue=%232d2c2b&clientId=uf4fd22ef-b30f-4&from=paste&height=467&id=uf2e5d9c1&originHeight=584&originWidth=1635&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71962&status=done&style=none&taskId=ud5a1a946-f9b8-4357-b93a-c60d894d2ca&title=&width=1308" alt="image.png"><br>   <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192303259-735adad5-6b92-424d-bad0-ad0848be8aaf.png#averageHue=%23fbf9f8&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=ua57afb52&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55014&status=done&style=none&taskId=u5a954408-ad69-4f84-b89b-0f3dca79db5&title=&width=363.2" alt="fd58151acf51b465fc8430594373e22.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700192308132-1578fabd-b085-4d49-bc95-4ddf6dbff04e.png#averageHue=%23e2d3cb&clientId=uf4fd22ef-b30f-4&from=paste&height=649&id=u121eda6c&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241575&status=done&style=none&taskId=ufda28241-dcd6-4295-a2a3-daae5345516&title=&width=363.2" alt="4542b554a076d20a0a6da9b3a770e93.png"></p><h2 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h2><pre><code class="java"> @GetMapping(&quot;/&#123;id&#125;&quot;)    public Result queryBlogById(@PathVariable(&quot;id&quot;) Long id)&#123;        return blogService.queryBlogById(id);    &#125;</code></pre><pre><code class="java">  @Resource    UserServiceImpl userService;    @Override    public Result queryBlogById(Long id) &#123;        // 查询blog        Blog blog = getById(id);        if (blog == null)Result.fail(&quot;笔记不存在&quot;);        //查询跟笔记有关的用户        Long userId = blog.getUserId();        User user = userService.getById(userId);        blog.setName(user.getNickName());        blog.setIcon(user.getIcon());        return Result.ok(blog);    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700193985582-21a43285-d97d-41fb-bb96-008d81a39809.png#averageHue=%23dfd9d4&clientId=u7b8926cd-a983-4&from=paste&height=649&id=ua3a177b0&originHeight=811&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223031&status=done&style=none&taskId=ucea36795-d007-4ff6-9d5f-ff0ca06b5a7&title=&width=363.2" alt="image.png"></p><h2 id="完善点赞功能"><a href="#完善点赞功能" class="headerlink" title="完善点赞功能"></a>完善点赞功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700194315711-c845fe89-d025-42f0-a3fe-8d28061c0ded.png#averageHue=%23f5f5f5&clientId=u7b8926cd-a983-4&from=paste&height=761&id=ue7aaec9e&originHeight=951&originWidth=1802&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=443516&status=done&style=none&taskId=u76cbef0d-d4c1-44e3-8596-7e873bba294&title=&width=1441.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700198316712-283624f0-1627-4410-a753-5bf72beb9611.png#averageHue=%23f6f5f5&clientId=u7b8926cd-a983-4&from=paste&height=691&id=ufe8821b3&originHeight=864&originWidth=2126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=469370&status=done&style=none&taskId=u01a71424-ac53-4a05-9b87-257031d9649&title=&width=1700.8" alt="image.png"><br>为什么采用set集合：<br>因为我们的数据是不能重复的.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700222974076-5d45ce71-9321-483f-a627-6dd08c6181cd.png#averageHue=%232b2b2b&clientId=u7b8926cd-a983-4&from=paste&height=516&id=u3e6ea984&originHeight=516&originWidth=1552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37622&status=done&style=none&taskId=u9c1bc59f-ab5a-4eaa-87d4-e42e289448a&title=&width=1552" alt="image.png"><br>不是数据库字段,使我们自己加的.</p><h2 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232547308-8fe2e403-8645-44db-94e9-45b0899fe658.png#averageHue=%23e9e0e0&clientId=u7b8926cd-a983-4&from=paste&height=1022&id=u357df1e0&originHeight=1022&originWidth=1860&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=321342&status=done&style=none&taskId=uff5dce92-5d94-43c9-ad68-921e086026a&title=&width=1860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700232637405-256dc518-8c4b-4e8c-b74b-6e6cea1bb3fe.png#averageHue=%23072136&clientId=u7b8926cd-a983-4&from=paste&height=631&id=u4fd4e0b9&originHeight=631&originWidth=1910&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=447275&status=done&style=none&taskId=u64a8ae48-4c76-452d-8bd0-12d7bf2e608&title=&width=1910" alt="image.png"><br>修改代码<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700234060791-0ebd8375-a41f-4e12-bd90-fc92631d084a.png#averageHue=%232c2c2b&clientId=u7b8926cd-a983-4&from=paste&height=1281&id=u4782a1b4&originHeight=1281&originWidth=1511&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=213137&status=done&style=none&taskId=uddafbb8c-4fa0-4209-9c32-52b206e5e6f&title=&width=1511" alt="image.png"></p><pre><code class="java"> private void isBlogLike(Blog blog) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = RedisConstants.BLOG_LIKED_KEY + blog.getId();        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        blog.setIsLike(BooleanUtil.isTrue(score!=null));    &#125;    @Override    public Result likeBlog(Long id) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = RedisConstants.BLOG_LIKED_KEY + id;        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        if ( score == null) &#123;            //3.如果未点赞，可以点赞            //3.1 数据库点赞数+1            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();            //3.2 保存用户到Redis的set集合            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());            &#125;        &#125; else &#123;            //4.如果已点赞，取消点赞            //4.1 数据库点赞数-1            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();            //4.2 把用户从Redis的set集合移除            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().remove(key, userId.toString());            &#125;        &#125;        return Result.ok();    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236822763-c63a3595-c66d-4c79-8e45-9cc24c3c9a3b.png#averageHue=%23fafafa&clientId=u7b8926cd-a983-4&from=paste&height=619&id=u7e9d0869&originHeight=619&originWidth=1329&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187179&status=done&style=none&taskId=u2994ebf1-e3c6-4b24-a443-7171bad45eb&title=&width=1329" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700236872571-05c9d8c0-3b3c-45b7-ad7a-b8de86d81275.png#averageHue=%23f9f9f9&clientId=u7b8926cd-a983-4&from=paste&height=663&id=u15fb46a1&originHeight=663&originWidth=1475&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=191782&status=done&style=none&taskId=u5769bd53-1963-4081-b4ce-f7373863462&title=&width=1475" alt="image.png"></p><h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="实现关注和取关功能"><a href="#实现关注和取关功能" class="headerlink" title="实现关注和取关功能"></a>实现关注和取关功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278801806-7cd17c25-2eeb-48d5-bc32-e9c9d92e8740.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=694&id=ub93a3038&originHeight=694&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=364764&status=done&style=none&taskId=u03326a0e-5c7c-4ada-baa1-62aa4cf9bb4&title=&width=1438" alt="image.png"></p><pre><code class="java">  @Override    public Result follow(Long followUserId, Boolean isFollow) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 1.判断到底是关注还是取关        if (isFollow) &#123;            // 2.关注，新增数据            Follow follow = new Follow();            follow.setUserId(userId);            follow.setFollowUserId(followUserId);            boolean isSuccess = save(follow);            if (isSuccess) &#123;                // 把关注用户的id，放入redis的set集合 sadd userId followerUserId                stringRedisTemplate.opsForSet().add(key, followUserId.toString());            &#125;        &#125; else &#123;            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?            boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()                    .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));            if (isSuccess) &#123;                // 把关注用户的id从Redis集合中移除                stringRedisTemplate.opsForSet().remove(key, followUserId.toString());            &#125;        &#125;        return Result.ok();    &#125;    @Override    public Result isFollow(Long followUserId) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?        Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count();        // 3.判断        return Result.ok(count &gt; 0);    &#125;    @Override    public Result followCommons(Long id) &#123;        // 1.获取当前用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 2.求交集        String key2 = &quot;follows:&quot; + id;        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);        if (intersect == null || intersect.isEmpty()) &#123;            // 无交集            return Result.ok(Collections.emptyList());        &#125;        // 3.解析id集合        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());        // 4.查询用户        List&lt;UserDTO&gt; users = userService.listByIds(ids)                .stream()                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))                .collect(Collectors.toList());        return Result.ok(users);    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700278760191-0a31a5e5-4de5-4df2-b30b-d31be97f6836.png#averageHue=%23776141&clientId=u239d3de8-271e-4&from=paste&height=667&id=ub85ab2ae&originHeight=667&originWidth=375&originalType=binary&ratio=1&rotation=0&showTitle=false&size=381847&status=done&style=none&taskId=ub8184d02-201d-4d21-94c8-32944030eec&title=&width=375" alt="image.png"></p><h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280435793-fb72ba40-d4e0-487c-b6dd-0e1da5cf9353.png#averageHue=%23e7e3df&clientId=u239d3de8-271e-4&from=paste&height=814&id=u4629bab6&originHeight=814&originWidth=1639&originalType=binary&ratio=1&rotation=0&showTitle=false&size=689686&status=done&style=none&taskId=ub478a468-8946-482c-980f-60b696f1351&title=&width=1639" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700280752986-320ed5f4-5fcd-4d5f-90b4-edae3dd270a3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=602&id=u625ec156&originHeight=602&originWidth=1312&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173418&status=done&style=none&taskId=ud6ac5584-1554-4d53-9570-60c92c538cc&title=&width=1312" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281004775-9773e98c-2e37-47a5-8ee2-60226f75274e.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=257&id=u584f6121&originHeight=257&originWidth=1316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115430&status=done&style=none&taskId=u03405a14-a5d9-4f52-8b77-c63fc0c227f&title=&width=1316" alt="image.png"><br>应该改造以前的关注接口,每次关注一个人, 就存到set集合中, 从而来找共同好友.</p><pre><code class="java">    @Override    public Result followCommons(Long id) &#123;        // 1.获取当前用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 2.求交集        String key2 = &quot;follows:&quot; + id;        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);        if (intersect == null || intersect.isEmpty()) &#123;            // 无交集            return Result.ok(Collections.emptyList());        &#125;        // 3.解析id集合        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());        // 4.查询用户        List&lt;UserDTO&gt; users = userService.listByIds(ids)                .stream()                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))                .collect(Collectors.toList());        return Result.ok(users);    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700281686178-2beec8e2-4921-4e60-9d1b-3dbead131073.png#averageHue=%23fdfaf9&clientId=u239d3de8-271e-4&from=paste&height=811&id=ufccf59b2&originHeight=811&originWidth=454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47333&status=done&style=none&taskId=u71095f78-67ca-40cd-b547-2198ac7725c&title=&width=454" alt="image.png"></p><h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284790050-a87ac7ad-37c8-45a6-a97a-217c7ff84a55.png#averageHue=%23ece1e1&clientId=u239d3de8-271e-4&from=paste&height=747&id=ua6122419&originHeight=747&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204743&status=done&style=none&taskId=u931ebda5-1422-465c-8776-dbe2a8d7d36&title=&width=1562" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284912975-b1b44dcf-fa79-4486-880d-c7e728ec945c.png#averageHue=%23e9e5e3&clientId=u239d3de8-271e-4&from=paste&height=783&id=u630c0be9&originHeight=783&originWidth=1689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=659610&status=done&style=none&taskId=u59cff10f-6c53-4e1f-b2d3-de7c8248ea1&title=&width=1689" alt="image.png"><br>我们的业务<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700284953779-20675930-1bba-4136-9abf-0e9e6f7813f7.png#averageHue=%23f6f5f5&clientId=u239d3de8-271e-4&from=paste&height=790&id=u615ca396&originHeight=790&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320765&status=done&style=none&taskId=u17e3405f-ece1-4575-a7af-1d81065951a&title=&width=1496" alt="image.png"><br><strong>拉模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285079923-6e24b596-9068-4f4d-b758-bb4fdc8a9ac3.png#averageHue=%23fcfcfb&clientId=u239d3de8-271e-4&from=paste&height=774&id=u0e7376e8&originHeight=774&originWidth=1607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=255182&status=done&style=none&taskId=u58815847-18cf-4897-9ae6-49320c7314b&title=&width=1607" alt="image.png"><br><strong>推模式</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285123680-ec4a5326-8214-4684-9f7f-d07dfd246f9c.png#averageHue=%23fcfcfc&clientId=u239d3de8-271e-4&from=paste&height=767&id=u79b63f5c&originHeight=767&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210966&status=done&style=none&taskId=u4eb2e920-1149-474e-b179-d9e325fd0dc&title=&width=1409" alt="image.png"><br>缺点是发给每一个粉丝, 内存占用很高.<br><strong>推拉结合</strong><br>粉丝少-&gt; 推模式<br>粉丝多-&gt;拉模式<br>  <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285260959-e254c589-1fe5-400f-afd6-32a228e3e27a.png#averageHue=%23fbfafa&clientId=u239d3de8-271e-4&from=paste&height=782&id=u451f38b3&originHeight=782&originWidth=1589&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281607&status=done&style=none&taskId=ud1193503-c2e3-4550-810d-c43aadf42f6&title=&width=1589" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700285315021-96ff8b73-54e3-42f3-9887-0d61244668aa.png#averageHue=%23e7dad9&clientId=u239d3de8-271e-4&from=paste&height=730&id=u73c06178&originHeight=730&originWidth=1660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157594&status=done&style=none&taskId=u07bfb312-1ad0-45a1-b5e4-412fb7ed5c0&title=&width=1660" alt="image.png"></p><h2 id="基于推模式实现关注推送功能"><a href="#基于推模式实现关注推送功能" class="headerlink" title="基于推模式实现关注推送功能."></a>基于推模式实现关注推送功能.</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289493961-b55cfb33-3b8a-405d-be38-74923204e2d3.png#averageHue=%23faf9f8&clientId=u239d3de8-271e-4&from=paste&height=1090&id=ud8164f58&originHeight=1090&originWidth=2163&originalType=binary&ratio=1&rotation=0&showTitle=false&size=333264&status=done&style=none&taskId=u2a2398b4-0278-4287-a678-2513b79acc7&title=&width=2163" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700289532336-17506c65-7a74-48cb-b271-08c0739c424d.png#averageHue=%23f9f8f7&clientId=u239d3de8-271e-4&from=paste&height=1087&id=u4a4bd886&originHeight=1087&originWidth=2072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327415&status=done&style=none&taskId=ude5e1872-71c9-4418-b3c4-d5c8cfd29c6&title=&width=2072" alt="image.png">不依赖角标<br>使用sorted来实现<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292674877-9e3a48dc-dc13-4505-97cb-8cfcf6751a35.png#averageHue=%23092437&clientId=u239d3de8-271e-4&from=paste&height=320&id=u451267d9&originHeight=320&originWidth=1975&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291864&status=done&style=none&taskId=u1c4f9e33-201b-4bd7-867f-da34c378449&title=&width=1975" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700292757855-54286e90-8db5-41f3-89c9-15c76cd933dd.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=737&id=q78vy&originHeight=737&originWidth=1517&originalType=binary&ratio=1&rotation=0&showTitle=false&size=294942&status=done&style=none&taskId=u5e677409-2aa1-450e-9671-40371b52f00&title=&width=1517" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293092245-43e5c4b8-a8fe-46d7-afaf-0b17404bbf6c.png#averageHue=%23062135&clientId=u239d3de8-271e-4&from=paste&height=922&id=u174d75a2&originHeight=922&originWidth=1894&originalType=binary&ratio=1&rotation=0&showTitle=false&size=557957&status=done&style=none&taskId=uddb0a0f8-3bb2-438f-9848-7d551401ab4&title=&width=1894" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293221589-5eb005f4-0ebf-4ec2-b7c8-2a1d3360f855.png#averageHue=%23072236&clientId=u239d3de8-271e-4&from=paste&height=782&id=u52f79ff7&originHeight=782&originWidth=1791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=371832&status=done&style=none&taskId=u6e5fdb5a-2bd8-48b4-ab10-5f202986a7c&title=&width=1791" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293348844-fb32c3bb-2876-4750-9c42-707dc06e54ba.png#averageHue=%23052035&clientId=u239d3de8-271e-4&from=paste&height=1040&id=u12dd3b88&originHeight=1040&originWidth=2053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=490628&status=done&style=none&taskId=ubea8abf6-2439-449d-a4d0-b0f686b3281&title=&width=2053" alt="image.png"><br><strong>总结:</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293443441-20ddb32f-62d1-491d-bd6c-99d851ca0791.png#averageHue=%23deddd4&clientId=u239d3de8-271e-4&from=paste&height=647&id=uc2ef59e7&originHeight=647&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=355611&status=done&style=none&taskId=u586e5a50-8e82-4add-91b6-5e05d8f2a31&title=&width=1526" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700293509310-beb1b064-aa7f-41ba-90cf-ba42c80b120f.png#averageHue=%23e4dddb&clientId=u239d3de8-271e-4&from=paste&height=1041&id=ubbdd503e&originHeight=1041&originWidth=1632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=725755&status=done&style=none&taskId=u3b34c4e8-a8c0-4436-ac54-688f03597d9&title=&width=1632" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700325372958-8f591a79-b9e9-47e8-a2e4-f609a0375182.png#averageHue=%23f1f6f0&clientId=u239d3de8-271e-4&from=paste&height=1165&id=u12e9f56d&originHeight=1165&originWidth=2085&originalType=binary&ratio=1&rotation=0&showTitle=false&size=702953&status=done&style=none&taskId=ue74b11e5-7449-4ddd-99e2-f08a5278a64&title=&width=2085" alt="image.png"></p><h1 id="附件商铺"><a href="#附件商铺" class="headerlink" title="附件商铺"></a>附件商铺</h1><h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363000628-b5dedeca-c042-4f08-90ad-60df5f7522fd.png#averageHue=%23f1f0e6&clientId=u239d3de8-271e-4&from=paste&height=866&id=u3dc15f61&originHeight=866&originWidth=2131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=753135&status=done&style=none&taskId=u0c009a19-cd8a-4a61-92a9-3fa7fbaf3eb&title=&width=2131" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363043045-b3ac121e-24a7-4fd9-b399-9e2f6e3d428e.png#averageHue=%230a2339&clientId=u239d3de8-271e-4&from=paste&height=694&id=u23e1efbc&originHeight=694&originWidth=2258&originalType=binary&ratio=1&rotation=0&showTitle=false&size=495603&status=done&style=none&taskId=ufb3cfff0-c609-4166-b553-fb9ddb9ee3c&title=&width=2258" alt="image.png">·<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363175122-099789de-43e6-4ff0-bb47-877588a426fd.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=490&id=ubc3cbe65&originHeight=490&originWidth=1244&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232721&status=done&style=none&taskId=u23c9cfd6-39d7-43aa-a1c2-dc2dfe8ebb5&title=&width=1244" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363356088-ccb6e01e-68f1-47a9-8a49-05123ba218ca.png#averageHue=%23092039&clientId=u239d3de8-271e-4&from=paste&height=431&id=ud8d9a339&originHeight=431&originWidth=1949&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259143&status=done&style=none&taskId=u6b0822bd-889a-4a4d-9985-905390c20d5&title=&width=1949" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700363406537-6ed70eb9-89eb-4c9d-ae10-fb97cf024acb.png#averageHue=%230d233b&clientId=u239d3de8-271e-4&from=paste&height=394&id=u54ff8dd6&originHeight=394&originWidth=1333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=283704&status=done&style=none&taskId=ud95865d6-3368-4985-915b-68f16f143d4&title=&width=1333" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364076459-65d2dc7c-c5b4-4111-b461-e328bce52977.png#averageHue=%23b9c3b1&clientId=u239d3de8-271e-4&from=paste&height=1075&id=u8c317c0a&originHeight=1075&originWidth=2192&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1077835&status=done&style=none&taskId=u0bf4ad10-69a6-425d-8d77-0cf322fc1e7&title=&width=2192" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700364201359-0875e76e-f0f3-458f-8672-83907bafbb8d.png#averageHue=%23e0e6e7&clientId=u239d3de8-271e-4&from=paste&height=765&id=u3093abbb&originHeight=765&originWidth=1790&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1124022&status=done&style=none&taskId=u0a775965-a9cf-415e-907f-cd528f57d9d&title=&width=1790" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700369316288-66b9818b-eed9-44bc-9335-0b965e51cc11.png#averageHue=%23777777&clientId=u239d3de8-271e-4&from=paste&height=612&id=ud6756531&originHeight=612&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112120&status=done&style=none&taskId=u27a9d1e8-8e9a-4ec4-876a-f129ec4cbfa&title=&width=1613" alt="image.png"></p><h2 id="查找附近商铺功能"><a href="#查找附近商铺功能" class="headerlink" title="查找附近商铺功能"></a>查找附近商铺功能</h2><p>实现数据的导入</p><pre><code class="java">    @Test    void loadShopData() &#123;        // 1.查询店铺信息        List&lt;Shop&gt; list = shopService.list();        // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合        Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));        // 3.分批完成写入Redis        for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;            // 3.1.获取类型id            Long typeId = entry.getKey();            String key = SHOP_GEO_KEY + typeId;            // 3.2.获取同类型的店铺的集合            List&lt;Shop&gt; value = entry.getValue();            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());            // 3.3.写入redis GEOADD key 经度 纬度 member            for (Shop shop : value) &#123;                // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());                locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(                        shop.getId().toString(),                        new Point(shop.getX(), shop.getY())                ));            &#125;            stringRedisTemplate.opsForGeo().add(key, locations);        &#125;    &#125;</code></pre><p>SpringDataRedis 的 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令<br>因此我们需要提示其版本，修改自己的 pom.xml</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h1><h2 id="bitmap用法"><a href="#bitmap用法" class="headerlink" title="bitmap用法"></a>bitmap用法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700379557735-4efe8b5e-0d59-414a-9423-17d6142b3451.png#averageHue=%23f3f1ea&clientId=ud7e70bf7-514d-4&from=paste&height=556&id=u7e3a41c0&originHeight=1112&originWidth=2472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1044266&status=done&style=none&taskId=u11207de4-f623-425e-bdaa-0c7eda7a48c&title=&width=1236" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380108867-8b8dbe78-bd4c-465f-a3f8-6d9c3af3316e.png#averageHue=%23f8f8f8&clientId=ud7e70bf7-514d-4&from=paste&height=548&id=ude7763cd&originHeight=1096&originWidth=2306&originalType=binary&ratio=2&rotation=0&showTitle=false&size=345948&status=done&style=none&taskId=u15b9380d-2591-44d6-ba35-ed98945e2a7&title=&width=1153" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380440914-1de72eab-f672-4c2d-ad95-33b18e248dca.png#averageHue=%23f3f3f3&clientId=ud7e70bf7-514d-4&from=paste&height=462&id=ua8835d34&originHeight=924&originWidth=2134&originalType=binary&ratio=2&rotation=0&showTitle=false&size=567878&status=done&style=none&taskId=u5f675c73-c2aa-4859-98ee-3ed58201b79&title=&width=1067" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380779465-409513e1-6552-4131-8344-55b6b794f10e.png#averageHue=%230a2435&clientId=ud7e70bf7-514d-4&from=paste&height=221&id=ud1a26804&originHeight=442&originWidth=1588&originalType=binary&ratio=2&rotation=0&showTitle=false&size=291832&status=done&style=none&taskId=u69122527-cce5-4409-97ff-314e595fe8d&title=&width=794" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380819411-62c986bb-66ef-4214-8797-eb0e85645e88.png#averageHue=%2310293a&clientId=ud7e70bf7-514d-4&from=paste&height=170&id=u30917650&originHeight=340&originWidth=1920&originalType=binary&ratio=2&rotation=0&showTitle=false&size=238370&status=done&style=none&taskId=u9ab23b8e-4b42-4454-82e6-464bd5d58f6&title=&width=960" alt="image.png"></p><h2 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h2><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700380949589-c9919d6c-a5f2-41a9-b188-d0302c6694e1.png#averageHue=%23f2f2f2&clientId=ud7e70bf7-514d-4&from=paste&height=578&id=u0bf95cbb&originHeight=1156&originWidth=1908&originalType=binary&ratio=2&rotation=0&showTitle=false&size=447500&status=done&style=none&taskId=u9b5261d8-5e1b-4637-9fb9-71a7af9dfb6&title=&width=954" alt="image.png"></p><pre><code class="java"> @Override    public Result sign() &#123;        // 1.获取当前登录用户        Long userId = UserHolder.getUser().getId();        // 2.获取日期        LocalDateTime now = LocalDateTime.now();        // 3.拼接key        String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));        String key = USER_SIGN_KEY + userId + keySuffix;        // 4.获取今天是本月的第几天        int dayOfMonth = now.getDayOfMonth();        // 5.写入Redis SETBIT key offset 1        stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);        return Result.ok();    &#125;</code></pre><h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700399217681-4d4061bc-adb9-4708-add8-bd9d29cf86cc.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=295&id=u25f36d64&originHeight=295&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102345&status=done&style=none&taskId=u76fe03cb-82dc-4e64-8fe0-1a1a538f72e&title=&width=967" alt="image.png"></p><pre><code class="java">    @Override    public Result signCount() &#123;        // 1.获取当前登录用户        Long userId = UserHolder.getUser().getId();        // 2.获取日期        LocalDateTime now = LocalDateTime.now();        // 3.拼接key        String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));        String key = USER_SIGN_KEY + userId + keySuffix;        // 4.获取今天是本月的第几天        int dayOfMonth = now.getDayOfMonth();        // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0        List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(                key,                BitFieldSubCommands.create()                        .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)        );        if (result == null || result.isEmpty()) &#123;            // 没有任何签到结果            return Result.ok(0);        &#125;        Long num = result.get(0);        if (num == null || num == 0) &#123;            return Result.ok(0);        &#125;        // 6.循环遍历        int count = 0;        while (true) &#123;            // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0            if ((num &amp; 1) == 0) &#123;                // 如果为0，说明未签到，结束                break;            &#125;else &#123;                // 如果不为0，说明已签到，计数器+1                count++;            &#125;            // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位            num &gt;&gt;&gt;= 1;        &#125;        return Result.ok(count);    &#125;</code></pre><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400801636-d5f48bdc-ddcb-4bd7-b197-5e9845d50821.png#averageHue=%23f3f3f3&clientId=u239d3de8-271e-4&from=paste&height=447&id=u5833066c&originHeight=447&originWidth=1609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178150&status=done&style=none&taskId=ueef19a98-2e62-4286-a3ac-40a5ba7a3df&title=&width=1609" alt="image.png"><br>举自己的个人博客网站的例子:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700400834771-bf1af00f-3d3f-40ec-ba7b-ee82d8446f49.png#averageHue=%23f7f7f7&clientId=u239d3de8-271e-4&from=paste&height=82&id=u05146455&originHeight=82&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4969&status=done&style=none&taskId=u84d83b80-b749-4862-b015-344bcfa6604&title=&width=360" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700401716213-68550223-ad11-4850-8639-54483a560d74.png#averageHue=%23a9ac9e&clientId=u239d3de8-271e-4&from=paste&height=743&id=ua6f5d2d9&originHeight=743&originWidth=1651&originalType=binary&ratio=1&rotation=0&showTitle=false&size=517952&status=done&style=none&taskId=ua2ba5f5d-23dc-4194-9a48-ec3fd79b420&title=&width=1651" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402111007-fec55a72-871e-4ccd-90e8-3a29ca73f275.png#averageHue=%230e283b&clientId=u239d3de8-271e-4&from=paste&height=514&id=u39fc541a&originHeight=514&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254600&status=done&style=none&taskId=u69394d77-a7d2-4d5e-a8b6-a85c87c5a85&title=&width=1001" alt="image.png"></p><h2 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h2><p>每一次充满容量为1000的数组发给redis. 不能一次发送100万条数据呀</p><pre><code class="java">    @Test    void testHyperLogLog() &#123;        String[] values = new String[1000];        int j = 0;        for (int i = 0; i &lt; 1000000; i++) &#123;            j = i % 1000;            values[j] = &quot;user_&quot; + i;            if(j == 999)&#123;                // 发送到Redis                stringRedisTemplate.opsForHyperLogLog().add(&quot;hl2&quot;, values);            &#125;        &#125;        // 统计数量        Long count = stringRedisTemplate.opsForHyperLogLog().size(&quot;hl2&quot;);        System.out.println(&quot;count = &quot; + count);    &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1700402938508-b14c9aa3-ca7e-4601-a734-0e8d9ed51826.png#averageHue=%232c2c2b&clientId=u239d3de8-271e-4&from=paste&height=135&id=ub131f0bb&originHeight=135&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5181&status=done&style=none&taskId=u34cce56e-e5ae-4949-91b7-55d0ed80cf9&title=&width=516" alt="image.png"><br>会有一些误差. 问题不大</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点评项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构常见问题</title>
      <link href="/posts/e7c3359a.html"/>
      <url>/posts/e7c3359a.html</url>
      
        <content type="html"><![CDATA[<h1 id="day1-链表"><a href="#day1-链表" class="headerlink" title="day1-链表"></a>day1-链表</h1><ul><li><strong>描述一下链表的数据结构？</strong></li></ul><p>链表是由节点类组成 ,其中包括值, 以及其他节点的引用组成, 通过引用指向 , 串成一个链表.</p><p>链表包含三种类型:  单向链表(每个节点只有指向下一个节点的引用), 双向链表:(有上一个节点和下一个节点的引用),  循环链表(最后一个节点的next引用指向头结点,形成循环结构)</p><ul><li><strong>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</strong></li></ul><p>LinkedList 使用的是双向链表,</p><ul><li><strong>链表中数据的插入、删除、获取元素，时间复杂度是多少？</strong></li></ul><p>插入和删除的时间复杂度是O(1) , 获取元素的时间复杂度是O(n)</p><ul><li><strong>什么场景下使用链表更合适？</strong></li></ul><p> 在需要频繁的增加或删除节点的场景下使用链表更合适</p><p>不需要预先分配内存大小.</p><p>不需要快速随机访问</p><p>节省内存,   不需要分配连续的内存块.这在内存优先的嵌入式系统或移动设备很有用</p><h1 id="day2-数组"><a href="#day2-数组" class="headerlink" title="day2-数组"></a>day2-数组</h1><ol><li><strong>数据结构中有哪些是线性表数据结构？</strong></li></ol><p>数组: 每个元素都有唯一的索引, 在内存中地址连续</p><p>链表: 动态数据结构, 由节点构成, 每个节点存储着数据和指向下一个节点的引用</p><p>栈: 只有栈顶元素可以被访问, 插入和删除操作都发生在栈顶</p><p>队列: 插入在队尾, 删除在队首</p><ol><li>数<strong>组的元素删除和获取，时间复杂度是多少？</strong></li></ol><p>获取时间复杂度是O(1) </p><p>删除操作时间复杂度也是O(1), 但是删除的元素后面都需要向前移动, 所以平均情况下也是O(n)</p><p>删除是O(n), 获取是O(1)</p><ol><li>A<strong>rrayList 中默认的初始化长度是多少？</strong></li></ol><p>10</p><ol><li><strong>ArrayList 中扩容的范围是多大一次？</strong></li></ol><p><strong>先判断是否需要扩容,</strong> 如果扩容,咋会扩容1.5倍一次</p><ol><li>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什</li></ol><p> <code>System.arraycopy</code> 是 Java 标准库提供的数组拷贝方法:</p><ul><li><code>src</code>：原数组，即要复制的数据源。</li><li><code>srcPos</code>：从原数组的哪个位置开始复制。</li><li><code>dest</code>：目标数组，即复制到的位置。</li><li><code>destPos</code>：从目标数组的哪个位置开始粘贴。</li><li><code>length</code>：要复制的元素数量。</li></ul><p>在 <code>ArrayList</code> 的情境中，<code>src</code> 是原数组，<code>srcPos</code> 是0（从第一个元素开始复制），<code>dest</code> 是新数组，<code>destPos</code> 是0（从第一个位置开始粘贴），<code>length</code> 是原数组中的元素数量。这就完成了原数组元素到新数组的复制操作。</p><p>最后，<code>ArrayList</code> 更新内部的引用，将原数组引用指向新数组，使新数组成为 <code>ArrayList</code> 的内部数组缓冲区。原数组将被垃圾回收。 </p><h1 id="day3-队列"><a href="#day3-队列" class="headerlink" title="day3-队列"></a>day3-队列</h1><p><strong>单端队列和双端队列，分别对应的实现类是哪个？</strong></p><p><strong>单端队列可以有链表(LinkedList)实现或者是</strong><code>**ArrayDeque**</code><strong>类实现, 使用add和remove方法操作</strong></p><p><strong>简述延迟队列&#x2F;优先队列的实现方式以及应用场景?</strong></p><p><strong>延迟队列:</strong> </p><p><strong>实现方式</strong>：延迟队列通常是基于优先队列实现的。在Java中，常用的实现类是<strong>DelayQueue</strong>。它内部使用了一个优先队列（通常是二叉堆）来存储元素，但每个元素都有一个延迟时间，通过延迟时间作为条件排序, 只有当元素的延迟时间到达后，它才能被取出。这是通过元素的<strong>getDelay</strong>方法来实现的。</p><p>优先队列: </p><p><strong>优先队列（Priority Queue）</strong>：</p><ul><li><strong>实现方式</strong>：优先队列可以使用多种数据结构来实现，其中最常见的是二叉堆。在Java中，<strong>PriorityQueue</strong>就是一个二叉堆实现的优先队列。它使用小顶堆（最小元素在队头）或大顶堆（最大元素在队头）来维护元素的优先级顺序。元素的优先级通常由它们的自然顺序（实现<strong>Comparable</strong>接口）或自定义比较器（实现<strong>Comparator</strong>接口）来决定。</li></ul><p><strong>延迟队列和优先队列应用场景?</strong></p><p>延迟队列常用于实现定时任务调度，任务的执行时间可以被设置为延迟时间，从而实现任务的延迟执行。</p><p>优先队列常用于需要按照优先级顺序处理元素的场景，如任务调度、Dijkstra算法等。在任务调度中，任务的优先级可以表示任务的紧急程度或重要性，高优先级任务会先被执行。</p><h1 id="day4-堆栈"><a href="#day4-堆栈" class="headerlink" title="day4-堆栈"></a>day4-堆栈</h1><p><strong>堆栈使用场景?</strong></p><p>需要使用先入后出的数据结构和场景, 比如:递归算法(每次递归,调用相关信息压入堆栈), 浏览器历史, 函数调用等</p><p><strong>为什么不是用 Stack 类？</strong></p><p>Stack十分粗糙并且过时, 效率低下</p><p><strong>ArrayDeque是基于什么实现的?</strong></p><p>基于数组实现的堆栈数据结构</p><p><strong>ArrayDeque 数据结构使用过程叙述。</strong></p><p>ArrayDeque是双端队列, 提供两端插入和弹出的方法, 支持在队头和队尾执行各种操作</p><p><strong>ArrayDeque为什么要初始化2的n次幂个长度</strong></p><p>为了便于无符号取模(2^n - 1) 得到索引, 比一般的取模运算快得多, 减少扩容次数, </p><h1 id="day5-哈希表（散列）"><a href="#day5-哈希表（散列）" class="headerlink" title="day5-哈希表（散列）"></a>day5-哈希表（散列）</h1><ul><li><strong>介绍一下散列表</strong></li></ul><p>散列表是一种数据结构, 基于散列函数, 将键映射到存储值数组的特定位置,  以便在常数时间内进行快速查找, 插入, 删除操作. 通常适用于需要快速查找和插入的情况, 特别是当数据集较大且充足时.</p><ul><li><strong>为什么使用散列表</strong></li></ul><p>能够快速查找和输入, 提供了平均情况O(1)的时间复杂度</p><p>灵活的键-值映射,</p><ul><li><strong>拉链寻址和开放寻址的区别</strong></li></ul><p>拉链寻址中, 每个散列槽(或哈希桶)都存储一个链表, 数组或其他数据结构. 消耗内存</p><p>开放寻址, 所有元素都存储在散列槽中, 如果发生冲突, 查找下一个可用的槽, 直到找到空槽, 或遍历整个散列表. 可能会导致散列表出现堆积, 使得性能下降</p><ul><li><strong>还有其他什么方式可以解决散列哈希索引冲突</strong></li></ul><p>通过合并散列, 杜鹃散列, 跳房子散列,  罗宾汉哈希算法也是可以解决散列哈希索引冲突</p><ul><li>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</li></ul><p>通过拉链法, 在冲突位置(索引位置)上, 有一个链表, 将具有相同索引的元素串起来</p><h1 id="day6-堆-Heap"><a href="#day6-堆-Heap" class="headerlink" title="day6-堆 Heap"></a>day6-堆 Heap</h1><ul><li><strong>堆的数据结构是什么样？</strong></li></ul><p>堆是一种特殊的树形结构, 通常是一种完全二叉树. 在堆中, 每个节点都有一个值, 通常从父节点-&gt;子节点 或子节点-&gt;父节点都有一种特定的顺序 </p><ul><li><strong>堆的数据结构使用场景？</strong></li></ul><p>可以实现一种高效的排序算法-&gt;堆排序</p><p>可以用作优先队列, 允许高优先级的快速出队</p><p>可以实现高效的数据结构,比如斐波那契堆</p><ul><li><strong>堆的数据结构实现方式有哪些？</strong></li></ul><p>二叉堆(最小堆和最大堆) , 二顶堆, 后面不了解: 斐波那契堆,左偏树.</p><ul><li><strong>最小堆和最大堆的区别是什么？</strong></li></ul><p><strong>在最小堆中, 根节点的值最小, 每一个父节点的值小于等于子节点</strong></p><p><strong>最大堆则相反</strong></p><ul><li><strong>有了解斐波那契堆吗？</strong></li></ul><p>斐波那契堆是一种多叉堆，通常用于一些高级的图算法和优化问题。与二叉堆不同，斐波那契堆允许节点具有任意数量的子节点，使得合并操作更加高效。斐波那契堆的插入和删除操作通常具有分摊常数时间复杂度。这种堆的一个应用是最小生成树算法Prim和Dijkstra的高效实现。它还在某些离线最小生成树算法中得到了广泛应用。</p><h1 id="day7-字典树Trie"><a href="#day7-字典树Trie" class="headerlink" title="day7-字典树Trie"></a>day7-字典树Trie</h1><ul><li><strong>简述字典树的数据结构</strong></li></ul><p>字典树是一中树型的数据结构, 每个节点包含一个字符, 从根节点开始的路径代表一个字符串. 树的分支代表字符的不同选择.</p><ul><li><strong>叙述你怎么来实现一个字典树</strong></li></ul><p>先创建一个根节点 -&gt; 插入字符串, 从根节点开始, 按照字符串每个字符依次创建节点 . 直到构建整个字符串. 最后的结点标记为字符串的结束</p><ul><li><strong>字典树的实际业务场景举例</strong></li></ul><p>排序、全文搜索、网络搜索引擎、生物信息</p><ul><li><strong>字典树的存入和检索的时间复杂度</strong></li></ul><p>插入O(L)  检索O(L)  L是字符串的长度, 都需要遍历字符串的每个字符</p><ul><li>还有哪些字典树的实现方式</li></ul><p>【<a href="https://en.wikipedia.org/wiki/Suffix_tree">后缀树(opens new window)</a>、<a href="https://en.wikipedia.org/wiki/Hash_trie">哈希树(opens new window)</a>、<a href="https://en.wikipedia.org/wiki/HAT-trie">帽子树(opens new window)</a>】</p><h1 id="day8-二叉树"><a href="#day8-二叉树" class="headerlink" title="day8-二叉树"></a>day8-二叉树</h1><ul><li><strong>二叉搜索树结构简述&amp;变T的可能也让手写</strong></li></ul><p>二叉搜索树是一种特殊的属性结构, 每个节点都包含一个值, 左子节点的值小于父节点, 右子节点的值大于父节点. 每一个左子树和右子树同样也是一个二叉搜索树</p><ul><li><strong>二叉搜索树的插入、删除、索引的时间复杂度</strong></li></ul><p>平均情况下, 均为Log(n) 最坏情况下均为O(n)</p><ul><li><strong>二叉搜索树删除含有双子节点的元素过程叙述</strong></li></ul><ol><li>找到要删除的节点，通常找其右子树中最小的节点或左子树中最大的节点，也可以选择前驱节点或后继节点。</li><li>复制该节点的值到要删除的节点。</li><li>删除找到的前驱节点或后继节点，此时它可能只有一个子节点或没有子节点，这是一个递归操作。</li></ol><ul><li><p>二<strong>叉搜索树的节点都包括了哪些信息</strong></p><pre><code>节点值, 左子树, 右子树</code></pre></li><li><p><strong>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</strong></p></li></ul><p>出于性能和平衡的考虑, 红黑树的时间复杂度能够维持在O(logn)范围内</p><p>同时避免了树退化成链表的情况</p><h1 id="day9-AVL"><a href="#day9-AVL" class="headerlink" title="day9-AVL"></a>day9-AVL</h1><ul><li><strong>AVL 树平衡因子怎么计算？</strong></li></ul><p>左子树的高度减去右子树；</p><ul><li><strong>AVL 树左旋操作的目的是什么？</strong></li></ul><p>将一个节点的右子树变为新的根节点，以保持 AVL 树的平衡性。左旋操作用于解决右子树高度过高的情况</p><ul><li><strong>AVL 树左旋操作的流程是什么？</strong></li></ul><ol><li>假设要左旋的节点为 N，它的右子节点为 R。</li><li>将 R 的左子节点变为 N 的右子节点，同时更新 N 的右子节点为 R 的左子节点。</li><li>将 N 的父节点（如果存在）指向 R，以及将 R 的父节点指向 N 的原父节点。</li><li>最后，更新 N 和 R 的高度信息。</li></ol><ul><li><strong>AVL 树什么情况下要左旋+右旋？</strong></li></ul><ol><li>当一个节点的平衡因子为 2，且其左子树的平衡因子为 -1（或者是左子树的平衡因子为 0）时，需要先对左子树进行左旋，再对当前节点进行右旋，以达到平衡。</li><li>当一个节点的平衡因子为 -2，且其右子树的平衡因子为 1（或者是右子树的平衡因子为 0）时，需要先对右子树进行右旋，再对当前节点进行左旋，以达到平衡。</li></ol><ul><li><strong>AVL 树的插入和读取的时间复杂度？</strong></li></ul><p>AVL 树的插入和读取的时间复杂度为 O(log n)，其中 n 表示树中节点的数量。这是因为 AVL 树通过旋转操作来保持平衡，使得树的高度保持在 O(log n) 的水平。因此，插入和读取操作的时间复杂度都是 O(log n)。</p><h1 id="day10-2-3-树"><a href="#day10-2-3-树" class="headerlink" title="day10-2-3-树"></a>day10-2-3-树</h1><ul><li><p><strong>2-3树的数据结构描述</strong></p><ul><li><p>每个节点可以包含 1 个或 2 个元素。</p></li><li><p>如果一个节点包含 1 个元素，它有 2 个子节点。</p></li><li><p>如果一个节点包含 2 个元素，它有 3 个子节点。</p></li></ul></li><li><p>2-3树一个节点最多可以存放几个元素</p></li></ul><p>2个</p><ul><li><strong>2-3树插入节点时间复杂度</strong></li></ul><p>时间复杂度是 O(log n)，其中 n 表示树中节点的数量。</p><ul><li><strong>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></strong></li></ul><p>当一个节点已经包含 3 个元素时，需要进行分裂操作。分裂操作会将这个节点分为两个节点，每个节点包含 1 个元素。分裂操作的过程不需要旋转，而是将中间元素上移，形成一个新的父节点。</p><ul><li><strong>2-3树，你能手写一下吗</strong>？</li></ul><p>以下是一个简单的示例，假设我们要插入元素 7 到一个已经包含元素 4、9 的节点中：</p><pre><code class="plain">Before Insertion:     4 9After Insertion:    4 7 9</code></pre><p>在这个示例中，插入元素 7 后，原节点中的元素 4 和 9 会变成两个独立的节点，中间元素 7 上移，成为它们的新父节点。这就是 2-3树的分裂操作。</p><h1 id="day11-红黑树"><a href="#day11-红黑树" class="headerlink" title="day11-红黑树"></a>day11-红黑树</h1><ul><li><strong>红黑树都有哪些使用场景？</strong></li></ul><ol><li>数据库系统中，用于索引的实现，例如 InnoDB 存储引擎使用 B+树，而 B+树本质上是一种特殊的红黑树。</li><li>在编程语言的编译器和解释器中，用于实现符号表（Symbol Table）。</li><li>在 Java 的集合框架中，TreeMap 和 TreeSet 使用红黑树来实现有序的数据结构。</li></ol><ul><li><strong>相比于BST树，红黑树有什么用途？</strong></li></ul><ol><li>自平衡性：红黑树能够自动维护平衡，确保树的高度保持在较低的水平，因此查找、插入和删除等操作的时间复杂度是 O(log n)。</li><li>有序性：红黑树是有序的数据结构，可以方便地进行范围查询和有序遍历。</li><li>稳定性：插入和删除操作不会导致树的大规模重构，保持了数据的稳定性</li></ol><ul><li><strong>B-树是什么意思，都包括哪些？</strong></li></ul><p>是一种平衡的多路搜索树，通常用于外部存储，例如数据库和文件系统中的索引结构。B-树是一棵多叉树，每个节点可以包含多个子节点。B-树的特点包括：</p><ol><li>所有叶子节点都在同一层，使得每次查询时磁盘 I&#x2F;O 次数保持较低。</li><li>每个节点可以包含多个键值对，不仅仅包含 2 个（如红黑树的节点）。</li></ol><ul><li><strong>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</strong></li></ul><ol><li>当新插入节点是根节点时，需要将该节点染成黑色，以满足红黑树性质。</li><li>当新插入节点的父节点是黑色时，不需要进行任何操作，红黑树性质不受影响。</li><li>当新插入节点的父节点是红色时，需要进行染色和旋转操作，以恢复红黑树性质。</li></ol><p>具体的左旋和左旋+右旋操作会在不满足红黑树性质的情况下进行，以重新平衡树的结构。</p><ul><li><strong>红黑树的特点是什么？</strong></li></ul><p>红黑树的特点包括：</p><ol><li>每个节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点）是黑色。</li><li>如果一个节点是红色，那么它的子节点必须是黑色。</li><li>从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li><li>没有两个相邻的红色节点，即红黑树中不存在连续的红色节点。</li></ol><h1 id="day12-并查集"><a href="#day12-并查集" class="headerlink" title="day12-并查集"></a>day12-并查集</h1><ul><li><strong>并查集叙述？</strong></li></ul><p>并查集（Disjoint-Set Union，DSU）是一种数据结构，用于管理一系列不相交的集合（或称为集合分区）。它支持两种主要操作：查找（Find）和合并（Union）。并查集的主要目标是确定两个元素是否属于同一个集合，以及将两个集合合并为一个集合。</p><ul><li><strong>并查集的使用场景？</strong></li></ul><ol><li>连通性问题：并查集常用于解决网络连通性问题，如判断网络中的设备是否互通。</li><li>图的连通分量：在图论中，它可用于查找图的连通分量。</li><li>集合的合并：在算法和数据结构中，用于合并不相交的集合，例如 Kruskal 算法中用于最小生成树的构建</li></ol><ul><li><strong>并查集怎么合并元素？</strong></li></ul><p>合并元素： 合并两个元素的集合通常是通过将其中一个元素的根节点连接到另一个元素的根节点来实现。</p><ul><li>并查集合并元素的优化策略？</li></ul><ol><li>“Union by Rank”（按秩合并）：将较短的树合并到较高的树上。每个树的节点维护一个秩（或者称为深度），合并时将秩较小的树连接到秩较大的树上，以确保树的高度不会过大。</li><li>“Path Compression”（路径压缩）：在查找根节点时，将遍历过的节点都直接连接到根节点，以减小后续查找操作的时间复杂度。这是通过递归或循环方式实现的。</li></ol><ul><li><strong>如何压缩路径？</strong></li></ul><p>路径压缩是指在查找根节点时，将沿途的节点直接连接到根节点，以减小树的高度，从而提高后续操作的效率。路径压缩可以通过递归或迭代方式实现。</p><p>在路径压缩中，当查找根节点时，会将当前节点的父节点直接更新为根节点。这样，在后续查找操作中，沿途的节点都会指向根节点，从而加速查找操作。</p><h1 id="day13-图"><a href="#day13-图" class="headerlink" title="day13-图"></a>day13-图</h1><ul><li><strong>图的使用场景是什么？</strong></li></ul><ol><li>社交网络：图可用于表示社交网络中的用户和他们之间的关系，如朋友关系、关注关系等。</li><li>地图和导航系统：地图应用可以使用图来表示道路、城市和导航路径，以帮助用户找到最短路径。</li><li>网络拓扑：在计算机网络中，图可用于表示网络拓扑结构，包括路由器、交换机和连接。</li><li>任务调度：图可以表示任务和它们之间的依赖关系，用于任务调度和优化。</li><li>推荐系统：用于生成用户和项目之间的关系图，以提供个性化推荐。</li><li>数据分析：在数据分析中，图可以用于表示数据之间的关系，以进行关联性分析和可视化。</li><li>语义网络：图可用于构建语义网络，用于自然语言处理和知识表示。</li><li>游戏开发：图可用于表示游戏中的地图、任务和角色之间的关系。</li></ol><ul><li><strong>图有的分类？</strong></li></ul><ol><li>有向图（Directed Graph）：图中的边具有方向，表示从一个顶点到另一个顶点的有向关系。</li><li>无向图（Undirected Graph）：图中的边没有方向，表示两个顶点之间的无向关系。</li><li>带权图（Weighted Graph）：图中的边带有权重或成本，表示不同路径的成本。</li><li>有向无环图（DAG，Directed Acyclic Graph）：有向图中不存在形成环的路径。</li><li>连通图（Connected Graph）：无向图中的任意两个顶点之间都存在路径。</li><li>无环图（Acyclic Graph）：图中不存在形成环的路径。</li></ol><ul><li><strong>图怎么存放权重值？</strong></li></ul><p>权重通常存放在图的边上，每条边都可以具有一个权重值，用于表示连接两个顶点之间的成本或距离。在编程中，可以使用邻接矩阵或邻接表等数据结构来存储带权图的权重信息。</p><ul><li><strong>图的广度遍历</strong></li></ul><p>图的广度遍历（Breadth-First Search，BFS）： BFS 是一种用于遍历图的算法，它从起始顶点开始，首先访问起始顶点的所有相邻顶点，然后逐层扩展，依次访问更远的顶点。BFS 可用于查找最短路径、连通性检查和拓扑排序等任务。</p><ul><li><strong>图的深度遍历</strong></li></ul><p>DFS 是一种递归或栈的方式来遍历图的算法，它从起始顶点开始，首先访问一个相邻顶点，然后递归地访问这个相邻顶点的未访问邻居，直到到达最远的顶点，然后回溯并继续遍历其他分支。DFS 可用于查找路径、拓扑排序和连通性检查等任务。</p><h1 id="day14-布隆过滤器"><a href="#day14-布隆过滤器" class="headerlink" title="day14-布隆过滤器"></a>day14-布隆过滤器</h1><ul><li><strong>布隆过滤器的使用场景？</strong></li></ul><ol><li>数据缓存：用于快速检查某个数据是否在缓存中，从而避免查询数据库或磁盘操作。</li><li>防止缓存穿透：用于检查请求的数据是否有效，避免频繁请求不存在的数据。</li><li>网页爬虫去重：用于检查已经爬取的网页 URL，避免重复爬取。</li><li>邮件服务器：用于检查电子邮件地址是否有效，防止垃圾邮件地址。</li><li>数据库查询优化：用于加速数据库查询操作，判断数据是否存在于数据库表中。</li><li>拦截器过滤：用于拦截恶意请求，检查是否在黑名单中。</li></ol><ul><li><strong>布隆过滤器的实现原理和方式？</strong></li></ul><p>布隆过滤器的基本思想是使用多个哈希函数（通常称为哈希算法），将元素映射到位数组（Bit Array）中的多个位上。当检查某个元素是否存在时，计算它的哈希值，然后查看位数组上对应位置的位是否都为1。如果所有哈希值对应的位都为1，说明元素可能存在；如果有一个或多个位为0，说明元素肯定不存在。</p><ul><li><strong>如何提高布隆过滤器的准确性</strong>？</li></ul><p>关于提高布隆过滤器的准确性：</p><ul><li><p>增加哈希函数的数量：使用更多的哈希函数可以减小碰撞的概率，提高准确性。但需要权衡时间和空间开销。</p></li><li><p>动态调整布隆过滤器的大小：根据实际使用情况，动态调整布隆过滤器的大小，以降低误判率。</p></li><li><p><strong>有哪些中哈希计算方式？</strong></p></li></ul><ol><li>哈希函数：应用单一哈希函数，计算元素的哈希值。</li><li>多哈希函数：应用多个哈希函数，计算多个哈希值。</li></ol><ul><li><strong>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></strong></li></ul><ol><li>基本布隆过滤器：实现基本的布隆过滤器功能，例如判断元素是否存在。</li><li>可动态扩展的布隆过滤器：支持动态添加元素和自动扩展位数组大小，以适应不断变化的数据。</li><li>可序列化的布隆过滤器：支持将布隆过滤器序列化到文件或内存，以便后续加载和使用。</li><li>支持删除操作的布隆过滤器：支持从布隆过滤器中删除元素，通常需要额外的位数组标记删除。</li><li>高级性能布隆过滤器：优化过的布隆过滤器，提供更高的性能和低误判率。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/posts/43a71ae4.html"/>
      <url>/posts/43a71ae4.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)</p><p>没有索引查询是这样的: 全表扫描</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697437417364-8d8105ad-4ba4-4eb2-b0a0-03fc4e6df378.png#averageHue=%23f9f6f6&clientId=ub0c7b248-a611-4&from=paste&height=638&id=ub90d0c3e&originHeight=798&originWidth=1706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=251862&status=done&style=none&taskId=u2d4d25b1-7027-437c-aafe-b5df1e37e57&title=&width=1364.8" alt="image.png"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697443711444-131662e6-8679-4186-81d6-704ff0f51eb0.png#averageHue=%23f6f5f5&clientId=u6b1bb508-8493-4&from=paste&height=607&id=YodY8&originHeight=759&originWidth=1586&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=315620&status=done&style=none&taskId=uc461ed19-3335-4486-8589-13a86d5c098&title=&width=1268.8" alt="image.png"></p><ul><li>绿色数据只起到索引数据的作用 , 不存储数据</li><li>叶子节点串成链表 , 是数据存储部分.</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697443984864-4a477896-bd36-455e-a407-60c101a7f555.png#averageHue=%23dce7d6&clientId=u6b1bb508-8493-4&from=paste&height=339&id=ufbcb7e46&originHeight=424&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126447&status=done&style=none&taskId=u35e5ae07-56f3-4338-9f05-a190c9755f6&title=&width=756" alt="image.png"></li><li>与B-Tree区别 :  所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p> MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444276488-09120785-2657-42a9-9925-53d0619f68dc.png#averageHue=%23f2ede8&clientId=u6b1bb508-8493-4&from=paste&height=416&id=uf5f45247&originHeight=520&originWidth=1539&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=294290&status=done&style=none&taskId=u70b1d1d8-f04c-4974-a9cb-6651592ba68&title=&width=1231.2" alt="image.png"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>通过hash算法, 将键值映射为新的值 &#x3D; &gt;映射到对应的槽位上&#x3D;&gt; 然后存储在Hash表中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444572450-4aea757f-86e2-4c8d-b744-e862765069e8.png#averageHue=%23f5efe5&clientId=u6b1bb508-8493-4&from=paste&height=434&id=u666020a6&originHeight=542&originWidth=1534&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=302505&status=done&style=none&taskId=uc9ab2e99-548b-4af5-8445-3cfde6fc46a&title=&width=1227.2" alt="image.png"><br> 特点<br>A. Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）<br>B. 无法利用索引完成排序操作<br>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引 </p><p>3). 存储引擎支持 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。  </p><blockquote><p>为什么InnoDB选择B+Tree<br>A. 相对于二叉树，层级更少，搜索效率高；<br>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；<br>C. 相对Hash索引，B+tree支持范围匹配及排序操作；  </p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697444999652-117b0c26-7038-4de0-a5e2-dfd093facf5d.png#averageHue=%23e7cfcc&clientId=u6b1bb508-8493-4&from=paste&height=446&id=u93f416de&originHeight=558&originWidth=1523&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=183134&status=done&style=none&taskId=ub6850173-1ad3-48a6-9ccc-de53b929adb&title=&width=1218.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445141094-0a4c3eea-9f99-4b1c-ba8e-8a77fce822b1.png#averageHue=%23eddddb&clientId=u6b1bb508-8493-4&from=paste&height=553&id=u299359e6&originHeight=691&originWidth=1576&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=275391&status=done&style=none&taskId=u2b520549-168f-40a4-8949-7f94b9c0377&title=&width=1260.8" alt="image.png"></p><h3 id="聚集索引-只记录行数据"><a href="#聚集索引-只记录行数据" class="headerlink" title="聚集索引,  只记录行数据"></a>聚集索引,  只记录行数据<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445628081-f59bedaf-446b-46dc-8af8-18daa0581c47.png#averageHue=%23f0eeee&clientId=u5e2abf71-e359-4&from=paste&height=618&id=ua1c3d749&originHeight=773&originWidth=1693&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=281978&status=done&style=none&taskId=ub8ca1228-49d6-48af-b5bd-6b3e5d18ec6&title=&width=1354.4" alt="image.png"></h3><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697445734692-3c072d16-a075-43e4-aeb4-fb5c5fb793bc.png#averageHue=%23e8dec1&clientId=u5e2abf71-e359-4&from=paste&height=338&id=ub114f59e&originHeight=423&originWidth=1555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=238492&status=done&style=none&taskId=u9163f980-7b39-449b-9c9d-3c4cde08702&title=&width=1244" alt="image.png"><br>挂的是对应的ID<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697448926127-7b8a1baa-0c36-4505-a446-a1a2d4183fe5.png#averageHue=%23f4f2f0&clientId=ubdf98a65-1189-4&from=paste&height=672&id=ucfb9eb53&originHeight=840&originWidth=1715&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=352181&status=done&style=none&taskId=u7610ec8c-e0a3-4fd7-9c06-37dd88bd595&title=&width=1372" alt="image.png">二级索引先比较首字母字典序, 然后类似于二叉搜索树的方式, 找到Arm, 然后找到Arm对应的ID, 然后通过聚集索引 , 找到对应的行数据 </p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697449229318-a68abfbe-30c7-49d2-83ca-935eb47afa30.png#averageHue=%23fbf8eb&clientId=ubdf98a65-1189-4&from=paste&height=322&id=u50a3c153&originHeight=403&originWidth=985&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108846&status=done&style=none&taskId=ufd1af7a9-40ce-44b7-aa91-f4cdff3b9d7&title=&width=788" alt="image.png"><br>根据id查询效率高, 因为根据name查询还需要再回表查询一次<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697449696009-901f1fe7-ed3e-4f1e-84da-1395db31827b.png#averageHue=%23f8f5f3&clientId=u620327ff-a504-4&from=paste&height=686&id=u21c71159&originHeight=858&originWidth=1075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=332973&status=done&style=none&taskId=u47212048-dffd-4257-9714-bdc195dd13c&title=&width=860" alt="image.png"></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697513868605-78d440ee-778b-4e80-8107-59531f751bcf.png#averageHue=%23fcfbf4&clientId=uc6163d93-4653-4&from=paste&height=448&id=u63cf337a&originHeight=560&originWidth=1651&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=127224&status=done&style=none&taskId=ud8bcd8da-569d-49d4-9e87-9759427d1f7&title=&width=1320.8" alt="image.png"><br><code>table_name</code>索引关联的表名</p><h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="主要优化查询语句"><a href="#主要优化查询语句" class="headerlink" title="主要优化查询语句"></a>主要优化查询语句</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514779029-a166174a-9d80-483d-bfbf-a14d53141ca0.png#averageHue=%23c8cec2&clientId=uc6163d93-4653-4&from=paste&height=618&id=u69ab3ef6&originHeight=773&originWidth=1623&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=410883&status=done&style=none&taskId=u3191e591-9069-4bdc-9bcf-584fdb9176c&title=&width=1298.4" alt="image.png"><br>根据具体情况来优化<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514735225-5f6ba41b-d78c-48fe-8e63-3ac304599545.png#averageHue=%23f8f7ef&clientId=uc6163d93-4653-4&from=paste&height=546&id=u9edf7543&originHeight=683&originWidth=1560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=268391&status=done&style=none&taskId=ubad0e591-fff0-4612-a033-1129260e42b&title=&width=1248" alt="image.png"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志:"></a>慢查询日志:</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697514995074-cd4ae302-2472-445d-9768-317a0be604ba.png#averageHue=%23223c52&clientId=uc6163d93-4653-4&from=paste&height=162&id=uf6378d7f&originHeight=202&originWidth=832&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137570&status=done&style=none&taskId=ucfe5611c-a82b-4137-a319-3a8c5646f92&title=&width=665.6" alt="image.png"></p><ul><li>profile详情</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525427978-61a7ad86-a089-4cda-aa0a-ddba0fa3179b.png#averageHue=%23f8f7f4&clientId=uc6163d93-4653-4&from=paste&height=303&id=uf5129e08&originHeight=379&originWidth=1585&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111939&status=done&style=none&taskId=u4650e16b-d288-4a96-9c2a-881950ca6b8&title=&width=1268" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525688275-e50b74c6-0b07-469f-9243-99c1338efc5c.png#averageHue=%2328465e&clientId=uc6163d93-4653-4&from=paste&height=465&id=ucba8e3c8&originHeight=581&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=486349&status=done&style=none&taskId=uc8ef2d5d-f666-4158-adf5-df76f24b3a8&title=&width=700.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525715668-cf6877f2-72d2-450b-8d82-c4b3f72d3119.png#averageHue=%23fbfae9&clientId=uc6163d93-4653-4&from=paste&height=471&id=uc89509c3&originHeight=589&originWidth=1389&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=168075&status=done&style=none&taskId=uca4f44fe-f87a-44bd-8db3-45ce8673918&title=&width=1111.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525753543-26688226-f0bd-4746-956b-dba5f4baa23d.png#averageHue=%23254258&clientId=uc6163d93-4653-4&from=paste&height=544&id=u70540ae7&originHeight=680&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=380080&status=done&style=none&taskId=uc0028d62-081a-4459-abe3-0356904aea6&title=&width=460" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697525764568-3d3c8fb1-4737-4e6d-b42f-e8dee43c9455.png#averageHue=%2327455c&clientId=uc6163d93-4653-4&from=paste&height=557&id=u28a38675&originHeight=696&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=666156&status=done&style=none&taskId=u8bf66c3c-c74b-4126-85f3-1c0284a425b&title=&width=700.8" alt="image.png"></p><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p><code>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</code><br>执行计划各字段的含义:<br><strong>id: 表示操作表的顺序, 如果id相同, 从上往下执行, 不同, 越大越先执行</strong><br>多对多, 需要一张关联表<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697853987915-09ad0eb6-7f58-4dde-bb64-e421ffb41f9a.png#averageHue=%23fbfbfa&clientId=u25ea9246-9b61-4&from=paste&height=552&id=ub81b8e17&originHeight=552&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148675&status=done&style=none&taskId=u94c689df-5d8f-4a8c-8c02-4ec4f165535&title=&width=1288" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854069854-b84728f3-faa5-4367-b963-ad2c0b28c498.png#averageHue=%23254157&clientId=u25ea9246-9b61-4&from=paste&height=539&id=ude6c43a3&originHeight=539&originWidth=2547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=757435&status=done&style=none&taskId=u774ba924-6b8a-4ecd-8947-acca5dfeb66&title=&width=2547" alt="image.png"><br>执行顺序 - &gt; s &gt; sc &gt; c :  原因: s 和 c表直接没有关系, 是通过中间表来联系起来的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854395110-40a3aa0d-6551-4798-bc3e-29fcef50a0ee.png#averageHue=%2329465d&clientId=u25ea9246-9b61-4&from=paste&height=1283&id=u682b7bf4&originHeight=1283&originWidth=2439&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1037047&status=done&style=none&taskId=u1c0f3f94-f5e3-4b4c-8869-453cbe771ba&title=&width=2439" alt="image.png"><br><strong>id值越大越先被执行</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697854530990-d90f1c28-8a03-48f5-b5c5-a722c6e5d64d.png#averageHue=%23243e54&clientId=u25ea9246-9b61-4&from=paste&height=445&id=u26b59710&originHeight=445&originWidth=2488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=750365&status=done&style=none&taskId=u1b789646-7da8-4eba-a336-d2d837505b7&title=&width=2488" alt="image.png"><br>**type:  表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。  **<br>使用主键或者唯一索引,则为const  ,  非唯一性索引,ref<br>优化的时候尽量往前优化<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697855001399-cf48d894-c0b4-4c50-b888-c3d42cd25701.png#averageHue=%232d4d65&clientId=u25ea9246-9b61-4&from=paste&height=301&id=u590f66a9&originHeight=301&originWidth=1964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=419333&status=done&style=none&taskId=u1e57cc80-5941-4b74-aaa4-1277eda09e0&title=&width=1964" alt="image.png"> possible_key 显示可能应用在这张表上的索引，一个或多个。<br> key 实际使用的索引，如果为NULL，则没有使用索引。<br> key_len 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。<br> filtered 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。  </p><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="验证索引对查询效率提升"><a href="#验证索引对查询效率提升" class="headerlink" title="验证索引对查询效率提升"></a>验证索引对查询效率提升</h3><p>主键默认有主键索引,所以通过id查, 一般性能都很高<br>创建索引的过程会构建b+树的结构, 通过创建索引, 来提升其他字段的性能(提升的效率很大)<img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697856551655-d3850b96-3080-46bc-87bb-0bef50105c55.png#averageHue=%232c4c63&clientId=ub7edcc15-1ad4-4&from=paste&height=175&id=u92a725f1&originHeight=175&originWidth=875&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118021&status=done&style=none&taskId=uf068183e-18bc-4194-8e35-760ce890edc&title=&width=875" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697856610898-70a3d29d-589f-4fcd-883f-5104aa4b9ff0.png#averageHue=%23faf9f4&clientId=ub7edcc15-1ad4-4&from=paste&height=946&id=u5849e0b6&originHeight=946&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=272654&status=done&style=none&taskId=u5c08f6f7-389a-475a-9c7a-7163defd7fb&title=&width=1188" alt="image.png"></p><h3 id="索引的使用规则"><a href="#索引的使用规则" class="headerlink" title="索引的使用规则"></a>索引的使用规则</h3><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul><li>最左前缀法则</li></ul><p>查询从索引的左列开始, 如果跳过了某一列, 索引将部分失效(后面的字段索引失效)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697879994898-42362556-c8bf-4c70-8ebb-570e6ad68a1c.png#averageHue=%2326435a&clientId=u685b6605-3101-4&from=paste&height=566&id=uc5265242&originHeight=566&originWidth=2250&originalType=binary&ratio=1&rotation=0&showTitle=false&size=574262&status=done&style=none&taskId=u942da6ce-8769-4699-83c1-a04e627aeb8&title=&width=2250" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880275790-bdbdef21-33bf-443e-9dd3-ba205d998ca8.png#averageHue=%2327445b&clientId=u685b6605-3101-4&from=paste&height=1110&id=u9d924d78&originHeight=1110&originWidth=2198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1381450&status=done&style=none&taskId=u7eb565c5-5364-4d7d-a0fa-4fbd11dd2c8&title=&width=2198" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880380063-e1ce9437-142c-4faf-85ce-257b6e94c995.png#averageHue=%2321384d&clientId=u685b6605-3101-4&from=paste&height=333&id=ueaee8639&originHeight=333&originWidth=2323&originalType=binary&ratio=1&rotation=0&showTitle=false&size=475688&status=done&style=none&taskId=u487a36a8-d919-4265-a713-db42f749e84&title=&width=2323" alt="image.png"></p><ul><li>范围查询</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880643880-701eae3c-50ac-4687-ac54-21c397f737a7.png#averageHue=%232b4b62&clientId=u685b6605-3101-4&from=paste&height=501&id=u2116031c&originHeight=501&originWidth=2330&originalType=binary&ratio=1&rotation=0&showTitle=false&size=580087&status=done&style=none&taskId=ufe65903b-5b4c-4b3d-80dd-34e07b5eb9d&title=&width=2330" alt="image.png"></p><ul><li>列运算</li></ul><p>在索引列上进行列运算失效<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697880915008-cee11519-63c4-4ee8-8ec2-1dd34f2acca4.png#averageHue=%2327445b&clientId=u17655d80-6043-4&from=paste&height=1017&id=u05e57083&originHeight=1017&originWidth=2233&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1277150&status=done&style=none&taskId=uc7f1a9ff-2d92-4abf-a3f2-46153d73812&title=&width=2233" alt="image.png"></p><ul><li>字符串不加引号, 索引也将会失效</li><li>模糊查询失效</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697881172670-01c93ada-42b2-4f9a-87e3-e0cb25bcd2be.png#averageHue=%23faf9ec&clientId=u17655d80-6043-4&from=paste&height=477&id=u95498bd0&originHeight=477&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236774&status=done&style=none&taskId=ua7267f2c-b7d8-4764-9e0d-14496901b88&title=&width=1469" alt="image.png"></p><ul><li>or连接</li></ul><p>如果or连接一侧有索引 一侧 没有索引, 那么两个字段的索引将都会失效</p><ul><li>数据分布影响</li></ul><p>当需要查询的数据满足绝大部分, 就可能不走索引,直接全表扫描<br>如果很稀少, 夸张一点, 10086个人中查询一个人 ,  就需要用索引来提高查询效率</p><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697882026874-381e6707-8395-49f9-86ff-5a7040dea5d0.png#averageHue=%23fbfaf3&clientId=u17655d80-6043-4&from=paste&height=854&id=ud711b89c&originHeight=854&originWidth=2051&originalType=binary&ratio=1&rotation=0&showTitle=false&size=362308&status=done&style=none&taskId=uc455ca61-757f-4be1-8ced-fb754a98287&title=&width=2051" alt="image.png"><br>use index是一个建议, 建议数据库用哪个索引<br><code>force</code>是强制数据库用哪个索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697957985982-211eeb29-dfa6-49bb-9bbc-49427ea642dc.png#averageHue=%23f6eee8&clientId=uea2f1f1a-6e6d-4&from=paste&height=1109&id=u5149ec54&originHeight=1109&originWidth=2282&originalType=binary&ratio=1&rotation=0&showTitle=false&size=520759&status=done&style=none&taskId=ud658fdf5-5930-4cb5-92c1-bce81a44a5f&title=&width=2282" alt="image.png"><br><strong>思考:</strong><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697958171025-b1f59855-435b-403a-857b-6a913d30a3e0.png#averageHue=%23f8f8f6&clientId=uea2f1f1a-6e6d-4&from=paste&height=536&id=uacb71684&originHeight=536&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175796&status=done&style=none&taskId=u60ee8599-b196-4987-9cf9-e2658d6b4a0&title=&width=1372" alt="image.png"><br>如果通过查找<code>username</code>, 但没有password字段, 需要进行回表查询效率降低, 效率提升的办法就是将<code>username</code>和 <code>password</code>建立一个联合索引.<br>注意最左匹配原则<br><a href="https://zhuanlan.zhihu.com/p/115778804">面试官:谈谈你对mysql联合索引的认识?</a></p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p><strong>为什么使用前缀索引?</strong><br>当字段过于庞大, 创建字段索引, 会出现浪费大量磁盘IO的情况<br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959021633-4d6e5da6-fe0c-431b-843c-e717f7caa976.png#averageHue=%232c4f67&clientId=uea2f1f1a-6e6d-4&from=paste&height=682&id=u36ba95e4&originHeight=682&originWidth=1633&originalType=binary&ratio=1&rotation=0&showTitle=false&size=518215&status=done&style=none&taskId=udd25767d-8cd7-4226-aa43-1decf1d5288&title=&width=1633" alt="image.png"><br><strong>解决</strong><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959302180-b04133e2-091a-4aa0-b27d-fa93ba40c6e2.png#averageHue=%23f8f8f2&clientId=uea2f1f1a-6e6d-4&from=paste&height=918&id=u4788766e&originHeight=918&originWidth=2169&originalType=binary&ratio=1&rotation=0&showTitle=false&size=399957&status=done&style=none&taskId=u301a5bb3-7e6b-476b-9405-1d68d6bd9de&title=&width=2169" alt="image.png"><br><strong>前缀索引理解</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697959532132-45b9741c-0fb3-4a90-8c45-8ee0c58c7e22.png#averageHue=%23faf4f1&clientId=uea2f1f1a-6e6d-4&from=paste&height=1035&id=uf12f9ee0&originHeight=1035&originWidth=2147&originalType=binary&ratio=1&rotation=0&showTitle=false&size=666032&status=done&style=none&taskId=u4a6aedd1-3293-4108-92cc-b45bfdb7d62&title=&width=2147" alt="image.png"></p><h4 id="单列索引-联合索引"><a href="#单列索引-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p><strong>单列索引:</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961112156-fdba0645-2e31-4a81-8317-86ce6e883a4e.png#averageHue=%232c4f67&clientId=uea2f1f1a-6e6d-4&from=paste&height=361&id=u75b42efc&originHeight=361&originWidth=1467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246535&status=done&style=none&taskId=uab69ea71-c91c-4540-83b7-984dbff661f&title=&width=1467" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961275207-91793406-bb71-49c0-8458-34fcef0d64c9.png#averageHue=%23f7b2a8&clientId=uea2f1f1a-6e6d-4&from=paste&height=65&id=u3b7ac2ad&originHeight=65&originWidth=1504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107495&status=done&style=none&taskId=uc7d01b3a-fd34-44ac-9882-a0fbcedb6f9&title=&width=1504" alt="image.png"><br><strong>联合索引</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961242787-5872fb46-3ff3-42f7-b383-6b295f095349.png#averageHue=%2327445b&clientId=uea2f1f1a-6e6d-4&from=paste&height=1103&id=uaac3630b&originHeight=1103&originWidth=2497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1615661&status=done&style=none&taskId=u593cca6d-2e38-4451-b521-0cd8ceb0427&title=&width=2497" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961369813-9cdad172-da8a-421b-8660-d3cea4f6cecd.png#averageHue=%23faf4ef&clientId=uea2f1f1a-6e6d-4&from=paste&height=869&id=u09631a09&originHeight=869&originWidth=2099&originalType=binary&ratio=1&rotation=0&showTitle=false&size=506370&status=done&style=none&taskId=u0f79300d-8f37-43c9-9f27-06c651a419c&title=&width=2099" alt="image.png"><br>对于phone和name的顺序也是要考虑的</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961597390-c4c56736-64c5-466f-94f4-8310b9c67a3a.png#averageHue=%23f7f6f6&clientId=uea2f1f1a-6e6d-4&from=paste&height=939&id=ub06dcec8&originHeight=939&originWidth=2138&originalType=binary&ratio=1&rotation=0&showTitle=false&size=505716&status=done&style=none&taskId=ub7440d06-ea8c-47ce-a420-3817cd3ca9b&title=&width=2138" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38717174/1697961756225-f626ce84-e6bf-4183-a086-9a996e2f61f8.png#averageHue=%23fcfbf1&clientId=uea2f1f1a-6e6d-4&from=paste&height=1058&id=uc47b7fe4&originHeight=1058&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&size=279613&status=done&style=none&taskId=u00913f09-d35d-4cb5-b541-e33bf5a853f&title=&width=1223" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC从入门到熟悉</title>
      <link href="/posts/ae0f95e0.html"/>
      <url>/posts/ae0f95e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%B8%80SpringMVC%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%93%E9%AA%8C">一、SpringMVC简介和体验</a><ul><li><a href="#11-%E4%BB%8B%E7%BB%8D">1.1 介绍</a></li><li><a href="#12-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8">1.2 主要作用</a></li><li><a href="#13-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3">1.3 核心组件和调用流程理解</a></li><li><a href="#14-%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C">1.4 快速体验</a></li></ul></li><li><a href="#%E4%BA%8CSpringMVC%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE">二、SpringMVC接收数据</a><ul><li><a href="#21-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">2.1 访问路径设置</a></li><li><a href="#22-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E9%87%8D%E7%82%B9">2.2 接收参数（重点）</a><ul><li><a href="#221-param-%E5%92%8C-json%E5%8F%82%E6%95%B0%E6%AF%94%E8%BE%83">2.2.1 param 和 json参数比较</a></li><li><a href="#222-param%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.2 param参数接收</a></li><li><a href="#223-%E8%B7%AF%E5%BE%84-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.3 路径 参数接收</a></li><li><a href="#224-json%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2.4 json参数接收</a></li></ul></li><li><a href="#23-%E6%8E%A5%E6%94%B6Cookie%E6%95%B0%E6%8D%AE">2.3 接收Cookie数据</a></li><li><a href="#24-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE">2.4 接收请求头数据</a></li><li><a href="#25-%E5%8E%9F%E7%94%9FApi%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">2.5 原生Api对象操作</a></li><li><a href="#26-%E5%85%B1%E4%BA%AB%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">2.6 共享域对象操作</a><ul><li><a href="#261-%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9B%9E%E9%A1%BE">2.6.1 属性（共享）域作用回顾</a></li><li><a href="#262-Request%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.2 Request级别属性（共享）域</a></li><li><a href="#263-Session%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.3 Session级别属性（共享）域</a></li><li><a href="#264-Application%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">2.6.4 Application级别属性（共享）域</a></li></ul></li></ul></li><li><a href="#%E4%B8%89SpringMVC%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE">三、SpringMVC响应数据</a><ul><li><a href="#31-handler%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">3.1 handler方法分析</a></li><li><a href="#32-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6">3.2 页面跳转控制</a><ul><li><a href="#321-%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E6%A8%A1%E6%9D%BF%E8%A7%86%E5%9B%BE">3.2.1 快速返回模板视图</a></li><li><a href="#322-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">3.2.2 转发和重定向</a></li></ul></li><li><a href="#33-%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE%E9%87%8D%E7%82%B9">3.3 返回JSON数据（重点）</a><ul><li><a href="#331-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87">3.3.1 前置准备</a></li><li><a href="#332-ResponseBody">3.3.2 @ResponseBody</a></li><li><a href="#333-RestController">3.3.3 @RestController</a></li></ul></li><li><a href="#34-%E8%BF%94%E5%9B%9E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86">3.4 返回静态资源处理</a></li></ul></li><li><a href="#%E5%9B%9BRESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E6%88%98">四、RESTFul风格设计和实战</a><ul><li><a href="#41-RESTFul%E9%A3%8E%E6%A0%BC%E6%A6%82%E8%BF%B0">4.1 RESTFul风格概述</a><ul><li><a href="#411-RESTFul%E9%A3%8E%E6%A0%BC%E7%AE%80%E4%BB%8B">4.1.1 RESTFul风格简介</a></li><li><a href="#412-RESTFul%E9%A3%8E%E6%A0%BC%E7%89%B9%E7%82%B9">4.1.2 RESTFul风格特点</a></li><li><a href="#413-RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">4.1.3 RESTFul风格设计规范</a></li><li><a href="#414-RESTFul%E9%A3%8E%E6%A0%BC%E5%A5%BD%E5%A4%84">4.1.4 RESTFul风格好处</a></li></ul></li><li><a href="#42-RESTFul%E9%A3%8E%E6%A0%BC%E5%AE%9E%E6%88%98">4.2 RESTFul风格实战</a><ul><li><a href="#421-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">4.2.1 需求分析</a></li><li><a href="#422-RESTFul%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1">4.2.2 RESTFul风格接口设计</a></li><li><a href="#423-%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">4.2.3 后台接口实现</a></li></ul></li></ul></li><li><a href="#%E4%BA%94SpringMVC%E5%85%B6%E4%BB%96%E6%89%A9%E5%B1%95">五、SpringMVC其他扩展</a><ul><li><a href="#51-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">5.1 全局异常处理机制</a><ul><li><a href="#511-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">5.1.1 异常处理两种方式</a></li><li><a href="#512-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">5.1.2 基于注解异常声明异常处理</a></li></ul></li><li><a href="#52-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">5.2 拦截器使用</a><ul><li><a href="#521-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A6%82%E5%BF%B5">5.2.1 拦截器概念</a></li><li><a href="#522-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">5.2.2 拦截器使用</a></li></ul></li><li><a href="#53-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">5.3 参数校验</a></li></ul></li><li><a href="#%E5%85%ADSpringMVC%E6%80%BB%E7%BB%93">六、SpringMVC总结</a></li></ul><h2 id="一、SpringMVC简介和体验"><a href="#一、SpringMVC简介和体验" class="headerlink" title="一、SpringMVC简介和体验"></a>一、SpringMVC简介和体验</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p><p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p><p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p><ul><li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><p>原生Servlet API开发代码片段</p><pre><code class="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)                                                         throws ServletException, IOException &#123;      String userName = request.getParameter(&quot;userName&quot;);        System.out.println(&quot;userName=&quot;+userName);&#125;</code></pre><p>基于SpringMVC开发代码片段</p><pre><code class="java">@RequestMapping(&quot;/user/login&quot;)public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123;        log.debug(&quot;userName=&quot;+userName);    //调用业务即可        return &quot;result&quot;;&#125;</code></pre><h3 id="1-2-主要作用"><a href="#1-2-主要作用" class="headerlink" title="1.2 主要作用"></a>1.2 主要作用</h3><p><img src="/../../../ProTool/img/img1/202310150052058.png"></p><p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换</li><li>等等等</li></ul><p><strong>最终总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h3 id="1-3-核心组件和调用流程理解"><a href="#1-3-核心组件和调用流程理解" class="headerlink" title="1.3 核心组件和调用流程理解"></a>1.3 核心组件和调用流程理解</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="/../../../ProTool/img/img1/image_tmdw8dA_0q.png"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ]</li><li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]</li><li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li><li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]</li><li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</li></ol><h3 id="1-4-快速体验"><a href="#1-4-快速体验" class="headerlink" title="1.4 快速体验"></a>1.4 快速体验</h3><ol><li><p>体验场景需求</p><p><img src="/../../../ProTool/img/img1/image_JrHCHOxu_n.png"></p></li><li><p>配置分析</p><ol><li>DispatcherServlet，设置处理所有请求！</li><li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li><li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li></ol></li><li><p>准备项目</p><ol><li><p>创建项目</p><p>springmvc-base-quick</p><p>注意：需要转成maven&#x2F;web程序！！</p></li><li><p>导入依赖</p><pre><code class="xml">&lt;properties&gt;    &lt;spring.version&gt;6.0.6&lt;/spring.version&gt;    &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt;    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- springioc相关依赖  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- web相关依赖  --&gt;    &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;    &lt;!--        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的         Servlet API，没有更新到 Jakarta EE 规范。    --&gt;    &lt;dependency&gt;        &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;        &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;        &lt;version&gt;$&#123;servlet.api&#125;&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- springwebmvc相关依赖  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li></ol></li><li><p>Controller声明</p><pre><code class="java">@Controllerpublic class HelloController &#123;    //handlers    /**     * handler就是controller内部的具体方法     * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!     * @ResponseBody 代表向浏览器直接返回数据!     */    @RequestMapping(&quot;/springmvc/hello&quot;)    @ResponseBody    public String hello()&#123;        System.out.println(&quot;HelloController.hello&quot;);        return &quot;hello springmvc!!&quot;;    &#125;&#125;</code></pre></li><li><p>Spring MVC核心组件配置类</p><blockquote><p>声明springmvc涉及组件信息的配置类</p></blockquote><pre><code class="java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc     @Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;    @Bean    public HandlerMapping handlerMapping()&#123;        return new RequestMappingHandlerMapping();    &#125;    @Bean    public HandlerAdapter handlerAdapter()&#123;        return new RequestMappingHandlerAdapter();    &#125;    &#125;</code></pre></li><li><p>SpringMVC环境搭建</p><blockquote><p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p></blockquote><pre><code class="java">//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;  /**   * 指定service / mapper层的配置类   */  @Override  protected Class&lt;?&gt;[] getRootConfigClasses() &#123;    return null;  &#125;  /**   * 指定springmvc的配置类   * @return   */  @Override  protected Class&lt;?&gt;[] getServletConfigClasses() &#123;    return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;  &#125;  /**   * 设置dispatcherServlet的处理路径!   * 一般情况下为 / 代表处理所有请求!   */  @Override  protected String[] getServletMappings() &#123;    return new String[] &#123; &quot;/&quot; &#125;;  &#125;&#125;</code></pre></li><li><p>启动测试</p><p>注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p><p><img src="/../../../ProTool/img/img1/image_196iViHp_T.png"></p></li></ol><h2 id="二、SpringMVC接收数据"><a href="#二、SpringMVC接收数据" class="headerlink" title="二、SpringMVC接收数据"></a>二、SpringMVC接收数据</h2><h3 id="2-1-访问路径设置"><a href="#2-1-访问路径设置" class="headerlink" title="2.1 访问路径设置"></a>2.1 访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><p><strong>精准路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><pre><code class="java">@Controllerpublic class UserController &#123;    /**     * 精准设置访问地址 /user/login     */    @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)    @ResponseBody    public String login()&#123;        System.out.println(&quot;UserController.login&quot;);        return &quot;login success!!&quot;;    &#125;    /**     * 精准设置访问地址 /user/register     */    @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)    @ResponseBody    public String register()&#123;        System.out.println(&quot;UserController.register&quot;);        return &quot;register success!!&quot;;    &#125;    &#125;</code></pre></li><li><p><strong>模糊路径匹配</strong></p><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><pre><code class="java">@Controllerpublic class ProductController &#123;    /**     *  路径设置为 /product/*       *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler       *    /product/a/a 不可以     *  路径设置为 /product/**      *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler       *   /product/a/a 也可以访问     */    @RequestMapping(&quot;/product/*&quot;)    @ResponseBody    public String show()&#123;        System.out.println(&quot;ProductController.show&quot;);        return &quot;product show!&quot;;    &#125;&#125;</code></pre><pre><code class="text">单层匹配和多层匹配：  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。  /**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</code></pre></li><li><p><strong>类和方法级别区别</strong></p><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><pre><code class="java">//1.标记到handler方法@RequestMapping(&quot;/user/login&quot;)@RequestMapping(&quot;/user/register&quot;)@RequestMapping(&quot;/user/logout&quot;)//2.优化标记类+handler方法//类上@RequestMapping(&quot;/user&quot;)//handler方法上@RequestMapping(&quot;/login&quot;)@RequestMapping(&quot;/register&quot;)@RequestMapping(&quot;/logout&quot;)</code></pre></li><li><p><strong>附带请求方式限制</strong></p><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><pre><code class="java">public enum RequestMethod &#123;  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125;</code></pre><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！</p><p>如果需要特定指定：</p><pre><code class="java">@Controllerpublic class UserController &#123;    /**     * 精准设置访问地址 /user/login     * method = RequestMethod.POST 可以指定单个或者多个请求方式!     * 注意:违背请求方式会出现405异常!     */    @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)    @ResponseBody    public String login()&#123;        System.out.println(&quot;UserController.login&quot;);        return &quot;login success!!&quot;;    &#125;    /**     * 精准设置访问地址 /user/register     */    @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)    @ResponseBody    public String register()&#123;        System.out.println(&quot;UserController.register&quot;);        return &quot;register success!!&quot;;    &#125;&#125;</code></pre><p>注意：违背请求方式，会出现405异常！！！</p></li><li><p><strong>进阶注解</strong></p><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><pre><code class="java">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)||@GetMapping(value=&quot;/login&quot;)</code></pre><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p></li><li><p><strong>常见配置问题</strong></p><p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p><blockquote><p>There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p></blockquote></li></ol><h3 id="2-2-接收参数（重点）"><a href="#2-2-接收参数（重点）" class="headerlink" title="2.2 接收参数（重点）"></a>2.2 接收参数（重点）</h3><h4 id="2-2-1-param-和-json参数比较"><a href="#2-2-1-param-和-json参数比较" class="headerlink" title="2.2.1 param 和 json参数比较"></a>2.2.1 param 和 json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li><p>参数编码： &#x20;</p><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p></li><li><p>参数顺序： &#x20;</p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p></li><li><p>数据类型： &#x20;</p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p></li><li><p>嵌套性： &#x20;</p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p></li><li><p>可读性： &#x20;</p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p></li></ol><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><p><img src="/../../../ProTool/img/img1/202310150100732.png" alt="image-20231007134256617"></p><h4 id="2-2-2-param参数接收"><a href="#2-2-2-param参数接收" class="headerlink" title="2.2.2 param参数接收"></a>2.2.2 param参数接收</h4><ol><li><p><strong>直接接值</strong></p><p>客户端请求</p><p><img src="/../../../ProTool/img/img1/image_3SOeT8tvvW.png"></p><p><strong>handler接收参数</strong></p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><pre><code class="java">@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123;     /**     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18     *     * 可以利用形参列表,直接接收前端传递的param参数!     *    要求: 参数名 = 形参名     *          类型相同     * 出现乱码正常，json接收具体解决！！     * @return 返回前端数据     */    @GetMapping(value=&quot;/value&quot;)    @ResponseBody    public String setupForm(String name,int age)&#123;        System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);        return name + age;    &#125;&#125;</code></pre></li><li><p><strong>@RequestParam注解</strong></p><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值<br>基本用法：</li></ul><pre><code class="java"> /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 *  *  使用@RequestParam注解标记handler方法的形参 *  指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name,                         @RequestParam(&quot;stuAge&quot;) int age)&#123;    System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);    return name+age;&#125;</code></pre><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>如果没有没有设置非必须，也没有传递参数会出现：</p><p><img src="/../../../ProTool/img/img1/image_vIkYCRMSZL.png"></p><p>将参数设置非必须，并且设置默认值：</p><pre><code class="java">@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name,                         @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123;    System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);    return name+age;&#125;</code></pre></li><li><p><strong>特殊场景接值</strong></p><ol><li><p>一名多值</p><p>多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><pre><code class="java">  /**   * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝   *   *  一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定   */  @GetMapping(value=&quot;/mul&quot;)  @ResponseBody  public Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123;      System.out.println(&quot;hbs = &quot; + hbs);      return hbs;  &#125;</code></pre></li><li><p>实体接收</p><p>Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：</p><p>定义一个用于接收参数的实体类：</p><p>作用<br>    作用：将方法的返回值，以特定的格式写入到response的body区域，进而将数据返回给客户端。<br><br>    当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象。<br><br>    如果返回值是字符串，那么直接将字符串写到客户端；如果是一个对象，会将对象转化为json串，然后写到客户端。</p><hr><p>版权声明：本文为CSDN博主「春风化作秋雨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jiahao1186/article/details/91980316">https://blog.csdn.net/jiahao1186/article/details/91980316</a></p><pre><code class="java">public class User &#123;  private String name;  private int age = 18;  // getter 和 setter 略&#125;</code></pre><p>在控制器中，使用实体对象接收，示例代码如下：</p><pre><code class="java">@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123;    @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)    @ResponseBody    public String addUser(User user) &#123;        // 在这里可以使用 user 对象的属性来接收请求参数        System.out.println(&quot;user = &quot; + user);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><p>使用postman传递参数测试：</p><p><img src="/../../../ProTool/img/img1/image_5BkbhZjtyX.png"></p></li></ol></li></ol><h4 id="2-2-3-路径-参数接收"><a href="#2-2-3-路径-参数接收" class="headerlink" title="2.2.3 路径 参数接收"></a>2.2.3 路径 参数接收</h4><p><img src="/../../../ProTool/img/img1/image-20231013232602723.png" alt="image-20231013232602723"></p><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <strong><code>@PathVariable</code> 注解来处理路径传递参数。</strong></p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><pre><code class="java"> /** * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识! * 形参列表取值: @PathVariable Long id  如果形参名 = &#123;动态标识&#125; 自动赋值! *              @PathVariable(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值! * * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root */@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic String getUser(@PathVariable Long id,                       @PathVariable(&quot;name&quot;) String uname) &#123;    System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname);    return &quot;user_detail&quot;;&#125;</code></pre><h4 id="2-2-4-json参数接收"><a href="#2-2-4-json参数接收" class="headerlink" title="2.2.4 json参数接收"></a>2.2.4 json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li><p>前端发送 JSON 数据的示例：（使用postman测试）</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;张三&quot;,  &quot;age&quot;: 18,  &quot;gender&quot;: &quot;男&quot;&#125;</code></pre></li><li><p>定义一个用于接收 JSON 数据的 Java 类，例如：</p><pre><code class="java">public class Person &#123;  private String name;  private int age;  private String gender;  // getter 和 setter 略&#125;</code></pre></li><li><p>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</p><pre><code class="java">@PostMapping(&quot;/person&quot;)@ResponseBodypublic String addPerson(@RequestBody Person person) &#123;  // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性  return &quot;success&quot;;&#125;</code></pre><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。</p><p><img src="/../../../ProTool/img/img1/image-20231013233612291.png" alt="image-20231013233612291"></p></li><li><p>完善配置</p><p>测试：</p><p><img src="/../../../ProTool/img/img1/image_-vKMBKKMSZ.png"></p><p>问题：</p><p>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p><p><img src="/../../../ProTool/img/img1/202310150101981.png"></p><p>原因：</p><ul><li>不支持json数据类型处理</li><li>没有json类型处理的工具（jackson）<br>解决：<br>springmvc handlerAdpater配置json转化器,配置类需要明确：</li></ul><pre><code class="java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;</code></pre><p> }</p><pre><code>pom.xml 加入jackson依赖```xml&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p><strong>@EnableWebMvc注解说明</strong></p><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素！我们来解析<code>&lt;mvc:annotation-driven&gt;</code>对应的解析工作！</p><p>让我们来查看下<code>&lt;mvc:annotation-driven&gt;</code>具体的动作！</p><ul><li><p>先查看<code>&lt;mvc:annotation-driven&gt;</code>标签最终对应解析的Java类</p><p><img src="/../../../ProTool/img/img1/image_WJXPabVDSl.png"></p></li><li><p>查看解析类中具体的动作即可</p><p>打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p><p><img src="/../../../ProTool/img/img1/image_37KWhccu6c.png"></p><p>打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p><pre><code class="java">class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123;  public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();  public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();  static &#123;    ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader();    javaxValidationPresent = ClassUtils.isPresent(&quot;jakarta.validation.Validator&quot;, classLoader);    romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader);    jaxb2Present = ClassUtils.isPresent(&quot;jakarta.xml.bind.Binder&quot;, classLoader);    jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp;            ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader);    jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);    jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader);    jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader);    gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader);  &#125;</code></pre><pre><code> @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123;   //handlerMapping加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);   //添加jackson转化器   addRequestBodyAdvice(handlerAdapterDef);   addResponseBodyAdvice(handlerAdapterDef);   //handlerAdapter加入到ioc容器   readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);   return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;,         new RootBeanDefinition(JsonViewRequestBodyAdvice.class));   &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123;   if (jackson2Present) &#123;     beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;,         new RootBeanDefinition(JsonViewResponseBodyAdvice.class));   &#125; &#125;</code></pre><pre><code></code></pre></li></ul></li></ol><h3 id="2-3-接收Cookie数据"><a href="#2-3-接收Cookie数据" class="headerlink" title="2.3 接收Cookie数据"></a>2.3 接收Cookie数据</h3><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p><p>考虑使用以下 cookie 的请求：</p><pre><code class="java">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</code></pre><p>下面的示例演示如何获取 cookie 值：</p><pre><code class="java">@GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123;   //...&#125;</code></pre><h3 id="2-4-接收请求头数据"><a href="#2-4-接收请求头数据" class="headerlink" title="2.4 接收请求头数据"></a>2.4 接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><pre><code class="java">Host                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300</code></pre><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><pre><code class="java">@GetMapping(&quot;/demo&quot;)public void handle(    @RequestHeader(&quot;Accept-Encoding&quot;) String encoding,     @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123;   //...&#125;</code></pre><h3 id="2-5-原生Api对象操作"><a href="#2-5-原生Api对象操作" class="headerlink" title="2.5 原生Api对象操作"></a>2.5 原生Api对象操作</h3><p><img src="/../../../ProTool/img/img1/image-20231014000823019.png" alt="image-20231014000823019"></p><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><pre><code class="java">/** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(&quot;api&quot;)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request,                  HttpServletResponse response)&#123;    String method = request.getMethod();    System.out.println(&quot;method = &quot; + method);    return &quot;api&quot;;&#125;</code></pre><h3 id="2-6-共享域对象操作"><a href="#2-6-共享域对象操作" class="headerlink" title="2.6 共享域对象操作"></a>2.6 共享域对象操作</h3><h4 id="2-6-1-属性（共享）域作用回顾"><a href="#2-6-1-属性（共享）域作用回顾" class="headerlink" title="2.6.1 属性（共享）域作用回顾"></a>2.6.1 属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><p><img src="/../../../ProTool/img/img1/img010_VQ5ta0PT96.png"></p><h4 id="2-6-2-Request级别属性（共享）域"><a href="#2-6-2-Request级别属性（共享）域" class="headerlink" title="2.6.2 Request级别属性（共享）域"></a>2.6.2 Request级别属性（共享）域</h4><ol><li><p>使用 Model 类型的形参</p><pre><code class="java">@RequestMapping(&quot;/attr/request/model&quot;)@ResponseBodypublic String testAttrRequestModel(            // 在形参位置声明Model类型变量，用于存储模型数据        Model model) &#123;        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;);        return &quot;target&quot;;&#125;</code></pre></li><li><p>使用 ModelMap 类型的形参</p><pre><code class="java">@RequestMapping(&quot;/attr/request/model/map&quot;)@ResponseBodypublic String testAttrRequestModelMap(            // 在形参位置声明ModelMap类型变量，用于存储模型数据        ModelMap modelMap) &#123;        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;);        return &quot;target&quot;;&#125;</code></pre></li><li><p>使用 Map 类型的形参</p><pre><code class="java">@RequestMapping(&quot;/attr/request/map&quot;)@ResponseBodypublic String testAttrRequestMap(            // 在形参位置声明Map类型变量，用于存储模型数据        Map&lt;String, Object&gt; map) &#123;        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;);        return &quot;target&quot;;&#125;</code></pre></li><li><p>使用原生 request 对象</p><pre><code class="java">@RequestMapping(&quot;/attr/request/original&quot;)@ResponseBodypublic String testAttrOriginalRequest(            // 拿到原生对象，就可以调用原生方法执行各种操作        HttpServletRequest request) &#123;        request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;);        return &quot;target&quot;;&#125;</code></pre></li><li><p>使用 ModelAndView 对象</p><pre><code class="java">@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123;        // 1.创建ModelAndView对象    ModelAndView modelAndView = new ModelAndView();    // 2.存入模型数据    modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;);    // 3.设置视图名称    modelAndView.setViewName(&quot;target&quot;);        return modelAndView;&#125;</code></pre></li></ol><h4 id="2-6-3-Session级别属性（共享）域"><a href="#2-6-3-Session级别属性（共享）域" class="headerlink" title="2.6.3 Session级别属性（共享）域"></a>2.6.3 Session级别属性（共享）域</h4><pre><code class="java">@RequestMapping(&quot;/attr/session&quot;)@ResponseBodypublic String testAttrSession(HttpSession session) &#123;    //直接对session对象操作,即对会话范围操作!    return &quot;target&quot;;&#125;</code></pre><h4 id="2-6-4-Application级别属性（共享）域"><a href="#2-6-4-Application级别属性（共享）域" class="headerlink" title="2.6.4 Application级别属性（共享）域"></a>2.6.4 Application级别属性（共享）域</h4><p>解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p><pre><code class="java">@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)@ResponseBodypublic String attrApplication() &#123;        servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;);        return &quot;target&quot;;&#125;</code></pre><h2 id="三、SpringMVC响应数据"><a href="#三、SpringMVC响应数据" class="headerlink" title="三、SpringMVC响应数据"></a>三、SpringMVC响应数据</h2><h3 id="3-1-handler方法分析"><a href="#3-1-handler方法分析" class="headerlink" title="3.1 handler方法分析"></a>3.1 handler方法分析</h3><p>理解handler方法的作用和组成：</p><pre><code class="java">/** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: *       1.接收请求参数(param,json,pathVariable,共享域等)  *       2.调用业务逻辑  *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125; *       3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收)&#123;    调用业务方法    返回的结果 （页面跳转，返回数据（json））    return 简化响应前端数据;&#125;</code></pre><p>总结： 请求数据接收，我们都是通过handler的形参列表</p><p>&#x20;            前端数据响应，我们都是通过handler的return关键字快速处理！</p><p>&#x20;       springmvc简化了参数接收和响应！</p><h3 id="3-2-页面跳转控制"><a href="#3-2-页面跳转控制" class="headerlink" title="3.2 页面跳转控制"></a>3.2 页面跳转控制</h3><h4 id="3-2-1-快速返回模板视图"><a href="#3-2-1-快速返回模板视图" class="headerlink" title="3.2.1 快速返回模板视图"></a>3.2.1 快速返回模板视图</h4><ol><li><p>开发模式回顾</p><p>在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p><p><img src="/../../../ProTool/img/img1/202310150104483.png" alt="image-20231014082655185"></p><p><strong>前后端分离模式：[重点]</strong></p><p>指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格  式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p><p>混合开发模式：</p><p>指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p><p>对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p></li><li><p><strong>jsp技术了解</strong></p><p>JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p><p>JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p><p>JSP 的主要特点包括：</p><ol><li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li><li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li><li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。<br>总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</li></ol></li><li><p>准备jsp页面和依赖</p><p>pom.xml依赖</p><pre><code class="xml">&lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>jsp页面创建</p><p>建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p><p>位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp</p><pre><code class="java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;        $&#123;msg&#125;  &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>快速响应模版页面</p><ol><li><p>配置jsp视图解析器</p><pre><code class="java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        //快速配置jsp模板语言对应的        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);    &#125;&#125;</code></pre></li><li><p>handler返回视图</p><pre><code class="java">/** *  跳转到提交文件页面  /save/jump *   *  如果要返回jsp页面! *     1.方法返回值改成字符串类型 *     2.返回逻辑视图名即可     *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; *            + 逻辑视图名 + *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; */@GetMapping(&quot;jump&quot;)public String jumpJsp(Model model)&#123;    System.out.println(&quot;FileController.jumpJsp&quot;);    model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;);    return &quot;home&quot;;&#125;</code></pre></li></ol></li></ol><h4 id="3-2-2-转发和重定向"><a href="#3-2-2-转发和重定向" class="headerlink" title="3.2.2 转发和重定向"></a>3.2.2 转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><pre><code class="java">@RequestMapping(&quot;/redirect-demo&quot;)public String redirectDemo() &#123;    // 重定向到 /demo 路径     return &quot;redirect:/demo&quot;;&#125;@RequestMapping(&quot;/forward-demo&quot;)public String forwardDemo() &#123;    // 转发到 /demo 路径    return &quot;forward:/demo&quot;;&#125;//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</code></pre><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="3-3-返回JSON数据（重点）"><a href="#3-3-返回JSON数据（重点）" class="headerlink" title="3.3 返回JSON数据（重点）"></a>3.3 返回JSON数据（重点）</h3><h4 id="3-3-1-前置准备"><a href="#3-3-1-前置准备" class="headerlink" title="3.3.1 前置准备"></a>3.3.1 前置准备</h4><p>导入jackson依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>添加json数据转化器</p><p>@EnableWebMvc&#x20;</p><pre><code class="java">//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125;</code></pre><h4 id="3-3-2-ResponseBody"><a href="#3-3-2-ResponseBody" class="headerlink" title="3.3.2 @ResponseBody"></a>3.3.2 @ResponseBody</h4><ol><li><p>方法上使用@ResponseBody</p><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><pre><code class="java">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Object handle() &#123;  // ...  return obj;&#125;</code></pre><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p><img src="/../../../ProTool/img/img1/image-20231014084004267.png" alt="image-20231014084004267"></p><p>测试方法：</p><pre><code class="java">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)@ResponseBodypublic User getUser(@RequestBody User userParam) &#123;    System.out.println(&quot;userParam = &quot; + userParam);    User user = new User();    user.setAge(18);    user.setName(&quot;John&quot;);    //返回的对象,会使用jackson的序列化工具,转成json返回给前端!    return user;&#125;</code></pre><p>返回结果：</p><p><img src="/../../../ProTool/img/img1/image_GfNTc3Ei41.png"></p></li><li><p>类上使用@ResponseBody</p><p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p><pre><code class="java">@ResponseBody  //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123;</code></pre></li></ol><h4 id="3-3-3-RestController"><a href="#3-3-3-RestController" class="headerlink" title="3.3.3 @RestController"></a>3.3.3 @RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p><p>RestController源码:</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123;   /**   * The value may indicate a suggestion for a logical component name,   * to be turned into a Spring bean in case of an autodetected component.   * @return the suggested component name, if any (or empty String otherwise)   * @since 4.0.1   */  @AliasFor(annotation = Controller.class)  String value() default &quot;&quot;; &#125;</code></pre><h3 id="3-4-返回静态资源处理"><a href="#3-4-返回静态资源处理" class="headerlink" title="3.4 返回静态资源处理"></a>3.4 返回静态资源处理</h3><ol><li><p><strong>静态资源概念</strong></p><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p><ul><li>纯HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li><li>……</li></ul></li><li><p><strong>静态资源访问和问题解决</strong></p><ul><li><p>web应用加入静态资源</p><p><img src="/../../../ProTool/img/img1/image_4ZDfBKo7ze.png"></p></li><li><p>手动构建确保编译</p><p><img src="/../../../ProTool/img/img1/image_WNWOVOea6e.png"></p><p><img src="/../../../ProTool/img/img1/image_jkHB39M3Xa.png"></p><p><img src="/../../../ProTool/img/img1/image_iUBYDKRqy5.png"></p></li><li><p>访问静态资源</p><p><img src="/../../../ProTool/img/img1/image_k7bhHrwvx1.png"></p></li><li><p>问题分析</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li><li><p>问题解决</p><p>在 SpringMVC 配置配置类：</p><pre><code class="java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        //快速配置jsp模板语言对应的        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);    &#125;        //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        configurer.enable();    &#125;&#125;</code></pre><p>再次测试访问图片：</p><p><img src="/../../../ProTool/img/img1/image_mrBsYbjiMM.png"></p></li><li><p>新的问题：其他原本正常的handler请求访问不了了</p><p>handler无法访问</p><p>解决方案：</p><pre><code class="xml">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</code></pre></li></ul></li></ol><h2 id="四、RESTFul风格设计和实战"><a href="#四、RESTFul风格设计和实战" class="headerlink" title="四、RESTFul风格设计和实战"></a>四、RESTFul风格设计和实战</h2><h3 id="4-1-RESTFul风格概述"><a href="#4-1-RESTFul风格概述" class="headerlink" title="4.1 RESTFul风格概述"></a>4.1 RESTFul风格概述</h3><h4 id="4-1-1-RESTFul风格简介"><a href="#4-1-1-RESTFul风格简介" class="headerlink" title="4.1.1 RESTFul风格简介"></a>4.1.1 RESTFul风格简介</h4><p><img src="/../../../ProTool/img/img1/image_wEi6we5MJQ.png"></p><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p><p><img src="/../../../ProTool/img/img1/image_X8M-XfzI_A.png"></p><p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p><p><img src="/../../../ProTool/img/img1/202310141244518.png" alt="image-20231014124402358"></p><p><img src="/../../../ProTool/img/img1/202310150104795.png" alt="image-20231014124717765"></p><h4 id="4-1-2-RESTFul风格特点"><a href="#4-1-2-RESTFul风格特点" class="headerlink" title="4.1.2 RESTFul风格特点"></a>4.1.2 RESTFul风格特点</h4><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li><li><img src="/../../../ProTool/img/img1/202310150104952.png" alt="image-20231014125525831"></li></ol><h4 id="4-1-3-RESTFul风格设计规范"><a href="#4-1-3-RESTFul风格设计规范" class="headerlink" title="4.1.3 RESTFul风格设计规范"></a>4.1.3 <strong>RESTFul风格设计规范</strong></h4><ol><li><p><strong>HTTP协议请求方式要求</strong></p><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table></li><li><p><strong>URL路径风格要求</strong></p><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li></ol><ul><li><p>总结</p><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，<strong>改成名词</strong>，对应资源的唯一标识即可！</p></li></ul><h4 id="4-1-4-RESTFul风格好处"><a href="#4-1-4-RESTFul风格好处" class="headerlink" title="4.1.4 RESTFul风格好处"></a>4.1.4 RESTFul风格好处</h4><ol><li><p>含蓄，安全</p><p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p></li><li><p>风格统一</p><p>URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p></li><li><p>无状态</p><p>在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p></li><li><p>严谨，规范</p><p>严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p></li><li><p>简洁，优雅</p><p>过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET</td></tr></tbody></table></li><li><p>丰富的语义</p><p>通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p><blockquote><p><a href="http://localhost:8080/shop" title="http://localhost:8080/shop">http://localhost:8080/shop</a> <a href="http://localhost:8080/shop/product" title="http://localhost:8080/shop/product">http://localhost:8080/shop/product</a> <a href="http://localhost:8080/shop/product/cellPhone" title="http://localhost:8080/shop/product/cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a href="http://localhost:8080/shop/product/cellPhone/iPhone" title="http://localhost:8080/shop/product/cellPhone/iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p></blockquote></li></ol><h3 id="4-2-RESTFul风格实战"><a href="#4-2-RESTFul风格实战" class="headerlink" title="4.2 RESTFul风格实战"></a>4.2 RESTFul风格实战</h3><h4 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1 需求分析"></a>4.2.1 需求分析</h4><ul><li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li><li>功能分析<ul><li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li><li>保存用户功能</li><li>根据用户id查询用户详情功能</li><li>根据用户id更新用户数据功能</li><li>根据用户id删除用户数据功能</li><li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li></ul></li></ul><h4 id="4-2-2-RESTFul风格接口设计"><a href="#4-2-2-RESTFul风格接口设计" class="headerlink" title="4.2.2 RESTFul风格接口设计"></a>4.2.2 RESTFul风格接口设计</h4><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li><li><img src="/../../../ProTool/img/img1/image-20231014130339783.png" alt="image-20231014130339783"></li></ul></li></ol><h4 id="4-2-3-后台接口实现"><a href="#4-2-3-后台接口实现" class="headerlink" title="4.2.3 后台接口实现"></a>4.2.3 后台接口实现</h4><p>准备用户实体类：</p><pre><code class="java">package com.atguigu.pojo;/** * projectName: com.atguigu.pojo * 用户实体类 */public class User &#123;    private Integer id;    private String name;    private Integer age;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>准备用户Controller:</p><pre><code class="java">/** * projectName: com.atguigu.controller * * description: 用户模块的控制器 */@RequestMapping(&quot;user&quot;)@RestControllerpublic class UserController &#123;    /**     * 模拟分页查询业务接口     */    @GetMapping    public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page,                            @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size)&#123;        System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size);        System.out.println(&quot;分页查询业务!&quot;);        return &quot;&#123;&#39;status&#39;:&#39;ok&#39;&#125;&quot;;    &#125;    /**     * 模拟用户保存业务接口     */    @PostMapping    public Object saveUser(@RequestBody User user)&#123;        System.out.println(&quot;user = &quot; + user);        System.out.println(&quot;用户保存业务!&quot;);        return &quot;&#123;&#39;status&#39;:&#39;ok&#39;&#125;&quot;;    &#125;    /**     * 模拟用户详情业务接口     */    @PostMapping(&quot;/&#123;id&#125;&quot;)    public Object detailUser(@PathVariable Integer id)&#123;        System.out.println(&quot;id = &quot; + id);        System.out.println(&quot;用户详情业务!&quot;);        return &quot;&#123;&#39;status&#39;:&#39;ok&#39;&#125;&quot;;    &#125;    /**     * 模拟用户更新业务接口     */    @PutMapping    public Object updateUser(@RequestBody User user)&#123;        System.out.println(&quot;user = &quot; + user);        System.out.println(&quot;用户更新业务!&quot;);        return &quot;&#123;&#39;status&#39;:&#39;ok&#39;&#125;&quot;;    &#125;    /**     * 模拟条件分页查询业务接口     */    @GetMapping(&quot;search&quot;)    public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page,                            @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size,                            @RequestParam(name = &quot;keyword&quot;,required= false)String keyword)&#123;        System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size + &quot;, keyword = &quot; + keyword);        System.out.println(&quot;条件分页查询业务!&quot;);        return &quot;&#123;&#39;status&#39;:&#39;ok&#39;&#125;&quot;;    &#125;&#125;</code></pre><h2 id="五、SpringMVC其他扩展"><a href="#五、SpringMVC其他扩展" class="headerlink" title="五、SpringMVC其他扩展"></a>五、SpringMVC其他扩展</h2><h3 id="5-1-全局异常处理机制"><a href="#5-1-全局异常处理机制" class="headerlink" title="5.1 全局异常处理机制"></a>5.1 全局异常处理机制</h3><h4 id="5-1-1-异常处理两种方式"><a href="#5-1-1-异常处理两种方式" class="headerlink" title="5.1.1 异常处理两种方式"></a>5.1.1 异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li><strong>编程式异常处理</strong>：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 <strong>try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。</strong>在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li><strong>声明式异常处理：</strong>则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过<strong>配置等方式进行统一的管理和处理。</strong>在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="5-1-2-基于注解异常声明异常处理"><a href="#5-1-2-基于注解异常声明异常处理" class="headerlink" title="5.1.2 基于注解异常声明异常处理"></a>5.1.2 基于注解异常声明异常处理</h4><ol><li><p>声明异常处理控制器类</p><p>异常处理控制类，统一定义异常处理handler方法！</p><pre><code class="java">/** * projectName: com.atguigu.execptionhandler *  * description: 全局异常处理器,内部可以定义异常处理Handler! *//** * @RestControllerAdvice = @ControllerAdvice + @ResponseBody * @ControllerAdvice 代表当前类的异常处理controller!  */@RestControllerAdvicepublic class GlobalExceptionHandler &#123;  &#125;</code></pre></li><li><p>声明异常处理hander方法</p><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><pre><code class="java">/** * 异常处理handler  * @ExceptionHandler(HttpMessageNotReadableException.class)  * 该注解标记异常处理Handler,并且指定发生异常调用该方法! *  *  * @param e 获取异常对象! * @return 返回handler处理结果! */@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123;        return null;&#125;/** * 当发生空指针异常会触发此方法! * @param e * @return */@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e)&#123;    return null;&#125;/** * 所有异常都会触发此方法!但是如果有具体的异常处理Handler!  * 具体异常处理Handler优先级更高! * 例如: 发生NullPointerException异常! *       会触发handlerNullException方法,不会触发handlerException方法! * @param e * @return */@ExceptionHandler(Exception.class)public Object handlerException(Exception e)&#123;    return null;&#125;</code></pre></li><li><p>配置文件扫描控制器类配置</p><p>确保异常处理控制类被扫描</p><pre><code class="java"> &lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt; @ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;, &quot;com.atguigu.exceptionhandler&quot;&#125;)</code></pre></li></ol><h3 id="5-2-拦截器使用"><a href="#5-2-拦截器使用" class="headerlink" title="5.2 拦截器使用"></a>5.2 拦截器使用</h3><h4 id="5-2-1-拦截器概念"><a href="#5-2-1-拦截器概念" class="headerlink" title="5.2.1 拦截器概念"></a>5.2.1 拦截器概念</h4><p>拦截器和过滤器解决问题</p><ul><li><p>生活中</p><p>为了提高乘车效率，在乘客进入站台前统一检票</p><p><img src="/../../../ProTool/img/img1/img008_uQA2iP6_5n.png"></p></li><li><p>程序中</p><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="/../../../ProTool/img/img1/img009_aXz6GsRSMQ.png"></p></li></ul><p><img src="/../../../ProTool/img/img1/202310150105383.png" alt="image-20231014141252652"></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p><p><img src="/../../../ProTool/img/img1/image_7rIm3LKXgr.png"></p><h4 id="5-2-2-拦截器使用"><a href="#5-2-2-拦截器使用" class="headerlink" title="5.2.2 拦截器使用"></a>5.2.2 拦截器使用</h4><ol><li><p>创建拦截器类</p></li><li><p><img src="/../../../ProTool/img/img1/image-20231014141727677.png" alt="image-20231014141727677"></p><pre><code class="java">public class Process01Interceptor implements HandlerInterceptor &#123;    // if( ! preHandler())&#123;return;&#125;    // 在处理请求的目标 handler 方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler);        System.out.println(&quot;Process01Interceptor.preHandle&quot;);                 // 返回true：放行        // 返回false：不放行        return true;    &#125;     // 在目标 handler 方法之后，handler报错不执行!    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView);        System.out.println(&quot;Process01Interceptor.postHandle&quot;);    &#125;     // 渲染视图之后执行(最后),一定执行!    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex);        System.out.println(&quot;Process01Interceptor.afterCompletion&quot;);    &#125;&#125;</code></pre><p>拦截器方法拦截位置：</p><p><img src="/../../../ProTool/img/img1/image_FwhiGWjP_t.png"></p></li><li><p>修改配置类添加拦截器</p><pre><code class="java">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        //快速配置jsp模板语言对应的        registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);    &#125;    //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        configurer.enable();    &#125;    //添加拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;         //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求        registry.addInterceptor(new Process01Interceptor());    &#125;&#125;</code></pre><pre><code></code></pre></li><li><p>配置详解</p><ol><li><p>默认拦截全部</p><pre><code class="java">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());&#125;</code></pre></li><li><p>精准配置</p><pre><code class="java">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;        //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());        //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径    //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串    registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);&#125;</code></pre></li><li><p>排除配置</p><pre><code class="java">//添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;        //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());        //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径    registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);            //排除匹配,排除应该在匹配的范围内排除    //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径    //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内    registry.addInterceptor(new Process01Interceptor())            .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;)            .excludePathPatterns(&quot;/common/request/tow&quot;);&#125;</code></pre></li></ol></li><li><p>多个拦截器执行顺序</p><ol><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。<img src="/../../../ProTool/img/img1/202310150105406.png" alt="image-20231014143224525"></li></ol></li></ol><h3 id="5-3-参数校验"><a href="#5-3-参数校验" class="headerlink" title="5.3 参数校验"></a>5.3 参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p><p><img src="/../../../ProTool/img/img1/image-20231014143507329.png" alt="image-20231014143507329"></p></blockquote><ol><li><p><strong>校验概述</strong></p><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr><tr><td>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</td><td></td></tr><tr><td>注解</td><td>规则</td></tr><tr><td>————————————————————————————————————————————————————————————————————————————————————————————————————————————————-</td><td>——————–</td></tr><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr><tr><td>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</td><td></td></tr><tr><td>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</td><td></td></tr></tbody></table></li><li><p><strong>操作演示</strong></p><ul><li><p>导入依赖</p><pre><code class="xml">&lt;!-- 校验注解 --&gt;&lt;dependency&gt;    &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;    &lt;version&gt;9.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;        &lt;!-- 校验注解实现--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;    &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>应用校验注解</p><pre><code class="java">import jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import org.hibernate.validator.constraints.Length;/** * projectName: com.atguigu.pojo */public class User &#123;    //age   1 &lt;=  age &lt; = 150    @Min(10)    private int age;    //name 3 &lt;= name.length &lt;= 6    @Length(min = 3,max = 10)    private String name;    //email 邮箱格式    @Email    private String email;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;&#125;</code></pre></li><li><p>handler标记和绑定错误收集</p><pre><code class="java">@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123;    /**     * @Validated 代表应用校验注解! 必须添加!     */    @PostMapping(&quot;save&quot;)    public Object save(@Validated @RequestBody User user,                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!                       BindingResult result)&#123;       //判断是否有信息绑定错误! 有可以自行处理!        if (result.hasErrors())&#123;            System.out.println(&quot;错误&quot;);            String errorMsg = result.getFieldError().toString();            return errorMsg;        &#125;        //没有,正常处理业务即可        System.out.println(&quot;正常&quot;);        return user;    &#125;&#125;</code></pre></li><li><p>测试效果</p><p><img src="/../../../ProTool/img/img1/image_BKORDdDEb9.png"></p></li></ul></li><li><p><strong>易混总结</strong></p><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li><p>@NotNull  (包装类型不为null)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p></li><li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。<br>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p></li></ol></li></ol><h2 id="六、SpringMVC总结"><a href="#六、SpringMVC总结" class="headerlink" title="六、SpringMVC总结"></a>六、SpringMVC总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>springmvc框架</td><td>主要作用、核心组件、调用流程</td></tr><tr><td>简化参数接收</td><td>路径设计、参数接收、请求头接收、cookie接收</td></tr><tr><td>简化数据响应</td><td>模板页面、转发和重定向、JSON数据、静态资源</td></tr><tr><td>restful风格设计</td><td>主要作用、具体规范、请求方式和请求参数选择</td></tr><tr><td>功能扩展</td><td>全局异常处理、拦截器、参数校验注解</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/posts/d044eab7.html"/>
      <url>/posts/d044eab7.html</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><img src="/../../../ProTool/img/img1/202310142311876-16972964465172.png" alt="image-20231014231100506"></p><h2 id="1-类型推断"><a href="#1-类型推断" class="headerlink" title="1.类型推断"></a>1.类型推断</h2><pre><code class="typescript">let str = &#39;abc&#39;str = 10  //报错</code></pre><h2 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h2><pre><code class="typescript">let str: string    //预定义一个类型str = &#39;abc&#39;</code></pre><h2 id="3-类型断言"><a href="#3-类型断言" class="headerlink" title="3.类型断言"></a>3.类型断言</h2><pre><code class="typescript">let numArr = [1,2,3]const result = numArr.find(item =&gt; item &gt; 2) as number // as number断言一定有大于2的数result*5  // 如果不断言, 这行会报错,因为可能ressult是undefined</code></pre><h2 id="4-基础类型和联合类型"><a href="#4-基础类型和联合类型" class="headerlink" title="4.基础类型和联合类型"></a>4.基础类型和联合类型</h2><pre><code class="typescript">//基础类型, 当我们分配这些类型以后, 就不能进行其他类型的设置了let v1: string = &#39;abc&#39;let v2: number = 10let v3: boolean = true// 以下两种不常用let nu: null = nulllet un: undefined = undefined//联合类型,可以是一种类型也可以是另一种类型let v4: string | null = null  // null可以赋值给任意类型(前提不开启严格配置项)// 具体值的限制, 只能分配其中之一let v5: 1|2|3 =5//报错   =2正确</code></pre><h2 id="5-数组-元组-枚举"><a href="#5-数组-元组-枚举" class="headerlink" title="5.数组,元组,枚举"></a>5.数组,元组,枚举</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code class="typescript">let arr: number[] = [1,2,3];//[1,2,3,&#39;a&#39;]报错let arr1: Array&lt;string&gt; = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];//[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;1]报错</code></pre><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><pre><code class="typescript">let t1: [number,string,number] = [1,&#39;a&#39;,2] //定义一个元组// t1[0] = &#39;a&#39; 报错并不一定要三个值, 可选let t1: [number,string,number?] = [1,&#39;a&#39;,2] //2去掉也不报错,但&#39;a&#39;去掉报错</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="typescript">//定义枚举类型enum MyEnum&#123;    A,    B,    C&#125;//两种访问方式console.log(MyEnum.A)console.log(MyEnum[0])</code></pre><h3 id="Void类型"><a href="#Void类型" class="headerlink" title="Void类型"></a>Void类型</h3><p>只能被赋值为<code>undefined</code></p><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><pre><code class="typescript">function MyFn (a:number, b:string)   //参数接收: number&#123; //设置返回值类型    return 100&#125;function MyFn (a:number, b?:string, c?:boolean, ...rest:number[])   //b可选, 建议必选的放左侧, 可选的放右侧: number&#123; //设置返回值类型    return 100&#125;//使用const f = MyFn(20,&#39;abc&#39;,true,1,2,3)</code></pre><h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><pre><code class="typescript">// 定义自己创建类型的一个约束方式interface Obj&#123;    name:string,    age:number&#125;const obj:Obj=&#123;    name: &#39;a&#39;,    age:10  //避免一些错误, 比如写成ago = 10就会报错&#125;const obj2:Obj=&#123;    name: &#39;a&#39;,    age:10  //避免一些错误, 比如写成ago = 10就会报错&#125;</code></pre><h2 id="8-类型别名"><a href="#8-类型别名" class="headerlink" title="8.类型别名"></a>8.类型别名</h2><pre><code class="typescript">type MyUserName = string | numberlet a: MyUserName = &#39;a&#39;  // = 1也可以</code></pre><h2 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9.泛型"></a>9.泛型</h2><pre><code class="typescript">function myFn(a:number,b:number):number[]&#123;    return [a,b]&#125;// 改成通用的函数function myFn&lt;T&gt;(a:T,b:T):T[]&#123;    return [a,b]&#125;myfN&lt;number&gt;(1,2) //(1,&#39;a&#39;)报错</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-10-day35</title>
      <link href="/posts/9b8ac020.html"/>
      <url>/posts/9b8ac020.html</url>
      
        <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>只有一只股票！</li><li>当前只有买股票或者卖股票的操作</li></ul><p>想获得利润至少要两天为一个交易单元。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>分解本题</p><p>假如第 0 天买入，第 3 天卖出，那么利润为：<code>prices[3] - prices[0]。</code></p><p>相当于<code>(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</code></p><p><strong>此时将利润分解为每天为单位的维度 , 而不是从连续几天考虑</strong></p><p>prices每天的利润序列 <code>(prices[i] - prices[i - 1]).....(prices[1] - prices[0])</code></p><p><strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>只收集正利润 就是贪心所贪的地方</p><p>&#x3D;&#x3D;局部最优&#x3D;&#x3D; 收集每天的正利润, 全局最优: 求得最大利润</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        int res = 0;        for(int i = 1; i &lt; prices.length; i++)&#123;                        res += Math.max(prices[i] - prices[i - 1], 0);        &#125;        return res;    &#125;&#125;</code></pre><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>跳几步无所谓, 关键在于可跳的覆盖范围</p><p>&#x3D;&gt; <strong>问题转化为: 跳跃覆盖的范围能不能到达终点</strong></p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public boolean canJump(int[] nums) &#123;        int cover = 0;        if(nums.length == 1) return true;        for(int i = 0; i &lt;= cover; i++)&#123;            cover = Math.max(i + nums[i] , cover);            if(cover &gt;= nums.length - 1)&#123;                 return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><p>注意 <code>i &lt;= cover</code> 在覆盖范围内移动, 超出覆盖范围没有意义</p><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p><strong>局部最优</strong>：当前可移动距离尽可能多走，如果还没到终点，步数再加一。</p><p><strong>整体最优：</strong>一步尽可能多走，从而达到最少步数。</p><p><strong>从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！</strong></p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="c">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() == 1) return 0;        int curDistance = 0;    // 当前覆盖最远距离下标        int ans = 0;            // 记录走的最大步数        int nextDistance = 0;   // 下一步覆盖最远距离下标        for (int i = 0; i &lt; nums.size(); i++) &#123;            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标            if (i == curDistance) &#123;                         // 遇到当前覆盖最远距离下标                ans++;                                  // 需要走下一步                curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）                if (nextDistance &gt;= nums.size() - 1) break;  // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束            &#125;        &#125;        return ans;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-07-day32</title>
      <link href="/posts/ce36b93.html"/>
      <url>/posts/ce36b93.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法总结"><a href="#回溯算法总结" class="headerlink" title="回溯算法总结"></a>回溯算法总结</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。</p><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><pre><code>void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>题目链接: <a href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p><p>通过列举10086层<code>for循环的例子, 进而得出为什么要用回溯法</code></p><p>搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>，这个理念贯穿整个回溯法系列</p><p>可以通过思考在哪一步不需要继续往下遍历了. 然后进行剪枝优化</p><p><strong>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了</strong>。</p><p><strong>在for循环上做剪枝操作是回溯法剪枝的常见套路！</strong></p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>题目链接: <a href="https://leetcode.cn/problems/combination-sum-iii/description/">https://leetcode.cn/problems/combination-sum-iii/description/</a></p><p>整体思路还是一样的，本题的剪枝会好想一些，即：<strong>已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉</strong></p><p>所以剪枝的代码可以在for循环加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！</p><h2 id="组数总和"><a href="#组数总和" class="headerlink" title="组数总和(||)"></a>组数总和(||)</h2><p>需要使用startIndex的情况</p><ul><li>如果是一个集合来求组合的话，就需要startIndex</li><li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</li></ul><p><strong>只是说求组合的情况，如果是排列问题，又是另一套分析的套路</strong>。</p><h2 id="组合-三"><a href="#组合-三" class="headerlink" title="组合(三)"></a>组合(三)</h2><p>集合元素会有重复，但要求解集不能包含重复的组合。</p><p>两个维度，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。</p><p><strong>在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</strong></p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><h2 id="多个集合求组合"><a href="#多个集合求组合" class="headerlink" title="多个集合求组合"></a>多个集合求组合</h2><p>开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>都是是求同一个集合中的组合！</strong></p><h2 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h2><ul><li>切割问题其实类似组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><strong>用求解组合问题的思路来解决 切割问题本题就成功一大半了</strong>，接下来就可以对着模板照葫芦画瓢。</p><p><strong>但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p><strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p><strong>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果</strong>。</p><p><strong>本题其实可以不需要加终止条件</strong>，因为startIndex &gt;&#x3D; nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。</p><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p><strong>使用set针对同一父节点本层去重，但子集问题一定要排序，</strong></p><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p>排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-04-day25</title>
      <link href="/posts/ba74d5ec.html"/>
      <url>/posts/ba74d5ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p> 第一眼做这个以为跟前面的都一样,无脑三部曲.但后来才发现题给的解释说,集合中的数可以使用多次. 傻眼了. 那怎么去考虑终止条件呢. 还有如何去深度搜索和宽度搜索呢?</p></blockquote><p>​注意叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递<strong>归没有层数的限制，只要选取的元素总和超过target，就返回！</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>二维数组result存放结果集，数组path存放符合条件的结果。</p><p>参数: </p><p>集合</p><p><code>candiates</code> 题目给的数组</p><p><code>target</code> 目标和</p><p><code>sum</code> 总和</p><p><code>startIndex</code> </p><blockquote><p><strong>startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p><p>如果是一个集合来求组合的话，就需要startInde</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</p></blockquote><pre><code class="c">ector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex)</code></pre><ul><li>递归终止条件</li></ul><p>根据题目, 终止条件只有两种: sum大于target和sum等于target。</p><pre><code class="c">if (sum &gt; target) &#123;    return;&#125;if (sum == target) &#123;    result.push_back(path);    return;&#125;</code></pre><ul><li>单层搜索的逻辑</li></ul><p>单层for循环依然是从startIndex开始，搜索candidates集合。</p><p>如何重复选取?</p><pre><code class="c">for (int i = startIndex; i &lt; candidates.size(); i++) &#123;    sum += candidates[i];    path.push_back(candidates[i]);    backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数    sum -= candidates[i];   // 回溯    path.pop_back();        // 回溯&#125;</code></pre><p><strong>不用i+1了，表示可以重复读取当前的数</strong></p><p>相当于下一层递归循环 ,  i 还是从这一层的startIndex开始, 这样就实现可重复读取啦</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; res;    int sum = 0;    void backtracking(vector&lt;int&gt;&amp; candidates,int startIndex, int target, int sum)&#123;        if(sum == target)&#123;            res.push_back(path);            return;        &#125;        if(sum &gt; target)&#123;            return;        &#125;                // 每层遍历        for(int i = startIndex; i &lt;  candidates.size(); i++)&#123;            sum += candidates[i];            path.push_back(candidates[i]);            backtracking(candidates, i, target, sum);            //回溯            sum -= candidates[i];            path.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;         backtracking(candidates, 0, target, 0);         return res;             &#125;&#125;;</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    int sum = 0;    public void backtracking(int[] candidates, int target, int startIndex, int sum)&#123;        if(sum == target)&#123;            res.add(new ArrayList&lt;&gt;(path));            return;        &#125;        if(sum &gt; target)&#123;            return;        &#125;        // 单层遍历        for(int i = startIndex; i &lt; candidates.length; i++)&#123;            path.add(candidates[i]);            sum += candidates[i];            backtracking(candidates, target, i, sum);            sum -= candidates[i];            path.remove(path.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        backtracking(candidates, target, 0, 0);        return res;    &#125;&#125;</code></pre><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p><p>可以在for循环判断的终止条件中增加限制: </p><blockquote><p>如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了</p><p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p></blockquote><p>所以单层<code>for</code> 搜索可以改为 sum+&#x3D; candidates原本是在for循环里面 .在这里判断, 就会少走下面的递归函数, 完成剪枝的目的</p><pre><code class="c">for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++)</code></pre><h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>跟上一题不同的是, 本题candidates 中的每个数字在每个组合中只能使用一次。</p><p>本题数组candidates的元素<strong>是有重复</strong>的，而<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和 (opens new window)</a>是无重复元素的数组candidates</p><p><strong>所谓去重，其实就是使用过的元素不能重复选取</strong></p><p>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>回溯三部曲</strong></p><ul><li>递归函数参数</li></ul><p>加一个<code>used[]</code> 数组, 用来记录同一树枝上的元素是否使用过</p><p>用来记录同一数层上的元素是否使用过</p><pre><code class="c">vector&lt;vector&lt;int&gt;&gt; result; // 存放组合集合vector&lt;int&gt; path;           // 符合条件的组合void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;</code></pre><ul><li>递归终止条件</li></ul><p>跟上一题一样的</p><pre><code class="c">if (sum &gt; target) &#123; // 这个条件其实可以省略    return;&#125;if (sum == target) &#123;    result.push_back(path);    return;&#125;</code></pre><ul><li>单层搜索逻辑</li></ul><p><strong>这里与上一题最大的区别就是去重啦</strong>,<strong>一定一定!!要在开始先排序</strong></p><p>难点在于如何判断同一树层上的元素是否使用过</p><p>用<code>used</code> 数组, 0 代表没用过, 1 代表已经用过</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p>为什么 used[i - 1] &#x3D;&#x3D; false 就是同一树层呢?</p><p>因为同一树层，used[i - 1] &#x3D;&#x3D; false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。</p><pre><code class="c">for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;    // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过    // used[i - 1] == false，说明同一树层candidates[i - 1]使用过    // 要对同一树层使用过的元素进行跳过    if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) &#123;        continue;    &#125;    sum += candidates[i];    path.push_back(candidates[i]);    used[i] = true;    backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次    used[i] = false;    sum -= candidates[i];    path.pop_back();&#125;</code></pre><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    boolean[] used;    int sum = 0;    public void backtracking(int[] candidates, int target, int startIndex, int sum, boolean[] used)&#123;        if(sum == target)&#123;            res.add(new ArrayList&lt;&gt;(path));            return;        &#125;        if(sum &gt; target)&#123;            return;        &#125;              // 单层遍历        for(int i = startIndex; i &lt; candidates.length ; i++)&#123;            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过            // 要对同一树层使用过的元素进行跳过            if(i &gt; 0&amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; used[i - 1] == false) continue;            used[i] = true;            path.add(candidates[i]);            sum += candidates[i];            backtracking(candidates, target, i+1, sum, used);            sum -= candidates[i];            path.remove(path.size()-1);            used[i] = false;        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        used = new boolean[candidates.length];        // 加标志数组，用来辅助判断同层节点是否已经遍历        Arrays.fill(used, false);        // 为了将重复的数字都放到一起，所以先进行排序        Arrays.sort(candidates);        backtracking(candidates, target, 0, 0, used);        return res;    &#125;&#125;</code></pre><h2 id="语法小补充"><a href="#语法小补充" class="headerlink" title="语法小补充"></a>语法小补充</h2><pre><code class="cpp">  vector&lt;bool&gt; used(candidates.size(), false);</code></pre><p>在java中,可以这么实现</p><pre><code class="java">   Arrays.fill(used, false);</code></pre><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>两个关键问题:</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p><strong>切割问题类似于组合问题</strong></p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li></ul><p>递归纵向逐个切割, </p><p>for循环横向遍历切割</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><strong>回溯三部曲</strong></p><ul><li>递归函数参数</li></ul><p>path存放切割后的回文子串</p><p>二维数组res存放结果集</p><p>startIndex , 这里就一个集合,所以也要使用</p><pre><code class="c">vector&lt;vector&lt;string&gt;&gt; result;vector&lt;string&gt; path; // 放已经回文的子串void backtracking (const string&amp; s, int startIndex) &#123;</code></pre><ul><li>递归函数终止条件</li></ul><p>这个startIndex就可以看做是一个切割线</p><pre><code class="cpp">void backtracking (const string&amp; s, int startIndex) &#123;    // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了    if (startIndex &gt;= s.size()) &#123;        result.push_back(path);        return;    &#125;&#125;</code></pre><ul><li>单层搜索逻辑</li></ul><p><strong>主要是在递归循环中如何取子串</strong></p><p><code>startIndex =&gt; i</code> 就是子串</p><pre><code class="c">for (int i = startIndex; i &lt; s.size(); i++) &#123;    if (isPalindrome(s, startIndex, i)) &#123; // 是回文子串        // 获取[startIndex,i]在s中的子串        string str = s.substr(startIndex, i - startIndex + 1);        path.push_back(str);    &#125; else &#123;                // 如果不是则直接跳过        continue;    &#125;    backtracking(s, i + 1); // 寻找i+1为起始位置的子串    path.pop_back();        // 回溯过程，弹出本次已经添加的子串&#125;</code></pre><blockquote><p>因为不能切割在同一处, 遍历到下一层的时候, i+1</p></blockquote><ul><li>判断回文字符串</li></ul><pre><code class="c"> bool isPalindrome(const string&amp; s, int start, int end) &#123;     for (int i = start, j = end; i &lt; j; i++, j--) &#123;         if (s[i] != s[j]) &#123;             return false;         &#125;     &#125;     return true; &#125;</code></pre><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="c">class Solution &#123;private:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; path; // 放已经回文的子串    void backtracking (const string&amp; s, int startIndex) &#123;        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了        if (startIndex &gt;= s.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i = startIndex; i &lt; s.size(); i++) &#123;            if (isPalindrome(s, startIndex, i)) &#123;   // 是回文子串                // 获取[startIndex,i]在s中的子串                string str = s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            &#125; else &#123;                                // 不是回文，跳过                continue;            &#125;            backtracking(s, i + 1); // 寻找i+1为起始位置的子串            path.pop_back(); // 回溯过程，弹出本次已经添加的子串        &#125;    &#125;    bool isPalindrome(const string&amp; s, int start, int end) &#123;        for (int i = start, j = end; i &lt; j; i++, j--) &#123;            if (s[i] != s[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        result.clear();        path.clear();        backtracking(s, 0);        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-03-day24</title>
      <link href="/posts/8d4dbf4.html"/>
      <url>/posts/8d4dbf4.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题相当于是在</p><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a>多了一个判断找出的集合之和等于n的判断</p><p>因为数只能取从1 ~ 9</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>回溯三部曲</p><ul><li>第一曲:确定递归函数参数</li></ul><p>依然定义path 和 result为全局变量</p><pre><code class="c">vector&lt;vector&lt;int&gt;&gt; result; // 存放结果集vector&lt;int&gt; path; // 符合条件的结果</code></pre><blockquote><ul><li>targetSum（int）目标和，也就是题目中的n。</li><li>k（int）就是题目中要求k个数的集合。</li><li>sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li><li>startIndex（int）为下一层for循环搜索的起始位置。</li></ul></blockquote><pre><code class="c">vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backtracking(int targetSum, int k, int sum, int startIndex)</code></pre><p>补充一下: 回溯算法递归的参数很难一次确定,需要用到什么参数,填什么参数</p><ul><li>第二曲:确定终止条件</li></ul><p>跟组合一样,遍历到第k层其实就已经将树的深度遍历完了</p><pre><code class="c">if (path.size() == k) &#123;    if (sum == targetSum) result.push_back(path);    return; // 如果path.size() == k 但sum != targetSum 直接返回&#125;</code></pre><ul><li>第三曲: 单层搜索</li></ul><p>每一层都是遍历的数都是上一层的数<code>-1</code>,因为集合中不能出现重复的数</p><pre><code class="c">for (int i = startIndex; i &lt;= 9; i++) &#123;    sum += i;    path.push_back(i);    backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex    sum -= i; // 回溯    path.pop_back(); // 回溯&#125;</code></pre><p>思考这段代码的时候,暂时不要去考虑backtracking里面的过程,直接到<code>sum  -= i</code>和<code>pop.pop_back</code>,然后进行下一层for循环,这两个相当于是清理战场了,然后换一个<code>i</code>再打一遍</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt;res;    void backtracking(int targetSum, int k, int sum, int startIndex)&#123;        // 终止条件        if(path.size() == k)&#123;            if(targetSum == sum) &#123;                res.push_back(path);                return ;        &#125;        &#125;                      //单层搜索        for(int i = startIndex; i &lt;= 9 ; i++)&#123;            path.push_back(i);            sum += i;            backtracking(targetSum,k,sum,i+1);            sum -= i;            path.pop_back();        &#125;            &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;        backtracking(n, k, 0, 1);        return res;    &#125;&#125;;</code></pre><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>如果已经选的元素 已经大于<code>targetSum</code>了,那么也没有必要继续往下遍历了</p><pre><code class="c">// 剪枝操作if(sum) &gt; targetSum&#123;    return;&#125;</code></pre><p>最终代码</p><pre><code class="c">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt;res;    void backtracking(int targetSum, int k, int sum, int startIndex)&#123;        if(sum &gt; targetSum) return;        // 终止条件        if(path.size() == k)&#123;            if(targetSum == sum) &#123;                res.push_back(path);                return ;        &#125;        &#125;                      //单层搜索        for(int i = startIndex; i &lt;= 9 ; i++)&#123;            path.push_back(i);            sum += i;            backtracking(targetSum,k,sum,i+1);            sum -= i;            path.pop_back();        &#125;            &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;        backtracking(n, k, 0, 1);        return res;    &#125;&#125;;</code></pre><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>本题一眼看可以暴力,因为如果<code>digit = 2</code>, 那么两层for魂环酒后了. 但如果<code>digit=10086</code> 层呢,for循环是并不可能的. 这是和<a href="https://leetcode.cn/problems/combinations/">77. 组合</a>在刚开始分析时一样的问题</p><p>理解本题后，要解决如下三个问题：</p><ul><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以用<code>map</code>, 或者定义一个二维数组,</p><pre><code class="c">const string letterMap[10] = &#123;    &quot;&quot;, // 0    &quot;&quot;, // 1    &quot;abc&quot;, // 2    &quot;def&quot;, // 3    &quot;ghi&quot;, // 4    &quot;jkl&quot;, // 5    &quot;mno&quot;, // 6    &quot;pqrs&quot;, // 7    &quot;tuv&quot;, // 8    &quot;wxyz&quot;, // 9&#125;;</code></pre><h3 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="回溯法来解决n个for循环的问题"></a>回溯法来解决n个for循环的问题</h3><p>依然是: 深度就是字母集合的长度</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>第一曲: 确定回溯函数参数</li></ul><p>这个在实际做题中不可能一下子想出来,用到什么写什么</p><pre><code class="c">vector&lt;string&gt; result;//字符串数组result保存起来string s;//收集叶子节点的结果void backtracking(const string&amp; digits, int index)//记录遍历第几个数字</code></pre><p>const string&amp; digit相当于取了一个别名,引用digit但不改变其字符串内容</p><ul><li>确定终止条件</li></ul><pre><code class="c">if(intdex == digits.size())&#123;//遍历到树底了    result.push_back(s);    return;&#125;</code></pre><ul><li>确定单层遍历逻辑</li></ul><pre><code class="c">int digit = digits[index] - &#39;0&#39;;        // 将index指向的数字转为intstring letters = letterMap[digit];      // 取数字对应的字符集for (int i = 0; i &lt; letters.size(); i++) &#123;    s.push_back(letters[i]);            // 处理    backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了    s.pop_back();                       // 回溯&#125;</code></pre><p><strong>这里的for循环并不是从startIndex开始遍历的</strong> <strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</strong>，<strong>而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>都是求同一个集合中的组合！</strong></p><p>注意：输入1 * #按键等等异常情况</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="c">class Solution &#123;public:    const string letterMap[10] = &#123;        &quot;&quot;, // 0        &quot;&quot;, // 1        &quot;abc&quot;, // 2        &quot;def&quot;, // 3        &quot;ghi&quot;, // 4        &quot;jkl&quot;, // 5        &quot;mno&quot;, // 6        &quot;pqrs&quot;, // 7        &quot;tuv&quot;, // 8        &quot;wxyz&quot;, // 9    &#125;;    string s;    vector&lt;string&gt;res;    void backtracking(const string&amp; digits, int index)&#123;        if(index == digits.size())&#123;            res.push_back(s);            return;        &#125;        int digit = digits[index] - &#39;0&#39;;        string letters = letterMap[digit];        for(int i = 0; i &lt; letters.size(); i++)&#123;            s.push_back(letters[i]);            backtracking(digits, index + 1);            s.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if(digits.size() == 0) return res;        backtracking(digits,0) ;        return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–10-02-day23</title>
      <link href="/posts/30c745e3.html"/>
      <url>/posts/30c745e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果 <code>k = 2</code></p><p>就直接可以用两层for循环可以解决</p><pre><code class="c">int n = 4;for (int i = 1; i &lt;= n; i++) &#123;    for (int j = i + 1; j &lt;= n; j++) &#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;    &#125;&#125;</code></pre><p>但如果 <code> k = 10086呢</code> 不可能去用10086层for循环</p><p>这时候可以考虑取用回溯算法来解决暴力都解决不了的问题</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><blockquote><p>此时,在 <code>n = 100 , k = 50的时候</code> 就是递归50层</p></blockquote><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong></p><p>对于一个集合,相当于是递归树的宽度,而k相当于是递归的深度</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归的返回值以及参数</li></ul><p>先定义两个全局变量:</p><pre><code class="java">vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合vector&lt;int&gt; path; // 用来存放符合条件结果</code></pre><ul><li>回溯函数的三个参数</li></ul><p>n, 集合大小.   k 组合集合的大小(树的深度)</p><p><strong>startIndex</strong> 记录下一层递归从哪开始,避免重复</p><p>比如1,2,3,4下一层就要从2开始</p><pre><code class="c">vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合vector&lt;int&gt; path; // 用来存放符合条件单一结果void backtracking(int n, int k, int startIndex)</code></pre><ul><li>回溯终止条件</li></ul><p>path数组的大小等于k时,找到了一个子集大小为k的组合,在path存的就是根节点到叶子结点的路径</p><pre><code class="c">if (path.size() == k) &#123;    result.push_back(path);    return;&#125;</code></pre><ul><li>单层搜索的过程</li></ul><p>for循环, &#x3D;&gt;  横向遍历集合</p><p>递归 &#x3D;&gt; 纵向遍历</p><pre><code class="c">for (int i = startIndex; i &lt;= n; i++) &#123; // 控制树的横向遍历    path.push_back(i); // 处理节点    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始    path.pop_back(); // 回溯，撤销处理的节点&#125;</code></pre><h2 id="回溯模版"><a href="#回溯模版" class="headerlink" title="回溯模版"></a>回溯模版</h2><pre><code class="c">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><pre><code class="c">class Solution &#123;private:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; res;    void backtracking(int n, int k, int startIndex)&#123;        if(path.size() == k) &#123;            res.push_back(path);            return;        &#125;        for(int i = startIndex; i &lt;= n; i++)&#123;            path.push_back(i); // 处理结点            backtracking(n , k , i+1); //递归,不能使用++i改变原来的值            path.pop_back();        &#125;     &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtracking(n, k, 1);        return res;    &#125;&#125;;</code></pre><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    private LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    private void backtracking(int n, int k , int startIndex)&#123;        if(path.size() == k) &#123;            res.add(new ArrayList&lt;&gt;(path));            return ;        &#125;        for(int i = startIndex; i &lt;= n ; i++)&#123;            path.add(i);            backtracking(n, k , i + 1);            path.removeLast();        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;            backtracking(n , k , 1);            return res;    &#125;&#125;</code></pre><h1 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h1><p>回溯法虽然是暴力搜索,但有时候也是可以剪枝优化的</p><p>在遍历中</p><pre><code class="C++">for (int i = startIndex; i &lt;= n; i++) &#123;    path.push_back(i);    backtracking(n, k, i + 1);    path.pop_back();&#125;</code></pre><p>​当n &#x3D; 9, k &#x3D; 9, 那么 起始从2开始到9也不到9个数,</p><p>这个地方就可以剪枝了</p><ul><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ul><p>举一个<code>n = 9</code>  <code>k  - 4</code> 就知道上面三步操作是为什么了</p><p>for循环优化后</p><pre><code class="c">for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置</code></pre><h1 id="Code-剪枝优化"><a href="#Code-剪枝优化" class="headerlink" title="Code(剪枝优化)"></a>Code(剪枝优化)</h1><pre><code class="c">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int n, int k, int startIndex) &#123;        if (path.size() == k) &#123;            result.push_back(path);            return;        &#125;        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 优化的地方            path.push_back(i); // 处理节点            backtracking(n, k, i + 1);            path.pop_back(); // 回溯，撤销处理的节点        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtracking(n, k, 1);        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-21-day16</title>
      <link href="/posts/8d213e83.html"/>
      <url>/posts/8d213e83.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求最大深度, 首先可以想到,前序遍历和后序遍历</p><p>对于求深度,和求高度.都可以用后序遍历,因为一个二叉树的最大深度和最大的高度是相等的</p><p>那么如何求最大深度呢?</p><p>可以使用递归,即递归的求左右两节点的长度, 并将左右两节点的长度取最大值.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241939134.png" alt="image-20230924185157004"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int getdepth(TreeNode* node)&#123;        if(node == NULL) return 0;        int leftdepth = getdepth(node-&gt;left);        int rightdepth = getdepth(node-&gt;right);        int depth = 1 + max(leftdepth,rightdepth);        return depth;    &#125;    int maxDepth(TreeNode* root) &#123;        return getdepth(root);    &#125;    &#125;;</code></pre><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    private int getdepth(TreeNode node)&#123;        if(node == null) return 0;        int leftdepth = getdepth(node.left);        int rightdepth = getdepth(node.right);        int depth = 1 + Math.max(leftdepth,rightdepth);        return depth;    &#125;    public int maxDepth(TreeNode root) &#123;        return getdepth(root);    &#125;&#125;</code></pre><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一眼看其实和求<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>类似,但还是有很多细节的区别的</p><p>因为当在根结点有空的子节点的时候就会出现错误</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241856074.png" alt="image-20230924185607931"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int getDepth(TreeNode* node)&#123;        if(node == NULL ) return 0;        int leftDepth = getDepth(node-&gt;left);        int rightDepth = getDepth(node-&gt;right);        if(node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL)&#123;            return 1 + rightDepth;        &#125;        if(node-&gt;left != NULL &amp;&amp;node-&gt;right == NULL)&#123;            return 1 + leftDepth;        &#125;        int result = 1 + min(leftDepth,rightDepth);        return result;    &#125;    int minDepth(TreeNode* root) &#123;        return getDepth(root);    &#125;&#125;;</code></pre><h3 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    int getDepth(TreeNode node)&#123;        if(node == null)&#123;            return 0;        &#125;        int leftDepth = getDepth(node.left);        int rightDepth = getDepth(node.right);                if(node.left != null &amp;&amp; node.right == null)&#123;            return 1 + leftDepth;        &#125;        if(node.left == null &amp;&amp; node.right != null)&#123;            return 1 + rightDepth;        &#125;        int res = 1 + Math.min(leftDepth,rightDepth);        return res;    &#125;    public int minDepth(TreeNode root) &#123;        return getDepth(root);    &#125;&#125;</code></pre><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>比较容易想到的就是后序遍历,做法跟前两道是一样的.</p><p>但因为是一个完全二叉树,根据完全二叉树的性质,我们又可以采用另一种方法</p><p>:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309241941772.png" alt="image-20230924194150634"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h3><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    public int getCount(TreeNode node)&#123;          if(node == null)&#123;            return 0;        &#125;                int leftCount = getCount(node.left);        int rightCount = getCount(node.right);        int countNodes = leftCount + rightCount + 1;        return countNodes;    &#125;    public int countNodes(TreeNode root) &#123;      return getCount(root);    &#125;&#125;</code></pre><h3 id="利用完全二叉树性质"><a href="#利用完全二叉树性质" class="headerlink" title="利用完全二叉树性质"></a>利用完全二叉树性质</h3><pre><code class="cpp">class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        if (root == nullptr) return 0;        TreeNode* left = root-&gt;left;        TreeNode* right = root-&gt;right;        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便        while (left) &#123;  // 求左子树深度            left = left-&gt;left;            leftDepth++;        &#125;        while (right) &#123; // 求右子树深度            right = right-&gt;right;            rightDepth++;        &#125;        if (leftDepth == rightDepth) &#123;            return (2 &lt;&lt; leftDepth) - 1; // 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0        &#125;        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-19-day14</title>
      <link href="/posts/de4f162b.html"/>
      <url>/posts/de4f162b.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树理论基础"><a href="#1-二叉树理论基础" class="headerlink" title="1. 二叉树理论基础"></a>1. 二叉树理论基础</h1><h2 id="1-1-二叉树的种类"><a href="#1-1-二叉树的种类" class="headerlink" title="1.1 二叉树的种类"></a>1.1 二叉树的种类</h2><ul><li>满二叉树: 每一个节点的子节点都为0或2</li><li>完全二叉树: 除了最底层的结点,其他结点每层节点数都达到最大值</li><li>二叉搜索树:所有左结点的值都小于根结点</li><li>平衡二叉树: 左右两个子树高度最大值不能超过1</li></ul><h2 id="1-2-二叉树存储方式"><a href="#1-2-二叉树存储方式" class="headerlink" title="1.2 二叉树存储方式"></a>1.2 二叉树存储方式</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储的元素在内存中是连续分布的，通常用数组来存储。如果父节点的数组下标是 root，那么它的左孩子就是 root * 2 + 1，右孩子就是 root * 2 + 2。</p><h3 id="1-3-二叉树的遍历方式"><a href="#1-3-二叉树的遍历方式" class="headerlink" title="1.3 二叉树的遍历方式"></a>1.3 二叉树的遍历方式</h3><ul><li><p>深度优先遍历 </p></li><li><blockquote><p>前序遍历,中序遍历, 后序遍历</p></blockquote></li><li><p>广度优先遍历</p></li><li><blockquote><p>层序遍历</p></blockquote></li></ul><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><pre><code class="c">Struct twoTreeNode&#123;    int value;    twoTreeNode *left;    twoTreeNode *right;    twoTreeNode(int x): val(x),left(NULL),right(NULL);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-18-day13</title>
      <link href="/posts/e65c883c.html"/>
      <url>/posts/e65c883c.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为要求滑动窗口中的最大值,</p><p>所以比较容易实现的便是,自己定义一个结构,能够让队列头始终是滑动窗口中最大的:</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106567.png" alt="image-20230919010607211"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309190106585.png" alt="image-20230919010613196"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class MyQue&#123;    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    void poll(int value)&#123;        if(!deque.isEmpty() &amp;&amp; value == deque.peek())&#123;            deque.poll();        &#125;    &#125;        void add(int val)&#123;            while(!deque.isEmpty()  &amp;&amp; val &gt; deque.getLast())&#123;                deque.removeLast();            &#125;            deque.add(val);        &#125;        int peek()&#123;            return deque.peek();        &#125;    &#125;class Solution &#123;        public int[] maxSlidingWindow(int[] nums, int k) &#123;    if(nums.length == 1)&#123;        return nums;    &#125;    int len = nums.length - k  + 1;    // 存放结果元素的数组    int[] res = new int[len];    int num = 0;    MyQue myque = new MyQue();    for(int i = 0; i &lt; k; i++)&#123;        myque.add(nums[i]);    &#125;    res[num++] = myque.peek();    for(int i = k; i &lt; nums.length; i++)&#123;        myque.poll(nums[i-k]);        myque.add(nums[i]);        res[num++] = myque.peek();    &#125;    return res;    &#125;&#125;</code></pre><p>C++:</p><pre><code class="c">class MyQue&#123;    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    void poll(int value)&#123;        if(!deque.isEmpty() &amp;&amp; value == deque.peek())&#123;            deque.poll();        &#125;    &#125;        void add(int val)&#123;            while(!deque.isEmpty()  &amp;&amp; val &gt; deque.getLast())&#123;                deque.removeLast();            &#125;            deque.add(val);        &#125;        int peek()&#123;            return deque.peek();        &#125;    &#125;class Solution &#123;        public int[] maxSlidingWindow(int[] nums, int k) &#123;    if(nums.length == 1)&#123;        return nums;    &#125;    int len = nums.length - k  + 1;    // 存放结果元素的数组    int[] res = new int[len];    int num = 0;    MyQue myque = new MyQue();    for(int i = 0; i &lt; k; i++)&#123;        myque.add(nums[i]);    &#125;    res[num++] = myque.peek();    for(int i = k; i &lt; nums.length; i++)&#123;        myque.poll(nums[i-k]);        myque.add(nums[i]);        res[num++] = myque.peek();    &#125;    return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session区别</title>
      <link href="/posts/6bead416.html"/>
      <url>/posts/6bead416.html</url>
      
        <content type="html"><![CDATA[<p>Cookie和Session都用于管理用户的状态和身份，但它们在存储位置、数据容量、安全性和传输方式等方面存在一些关键区别，下面通过具体示例来说明这些区别：</p><ol><li><p>存储位置：</p><ul><li><strong>Cookie</strong>：Cookie数据存储在用户的浏览器中。这意味着服务器可以将一些信息存储在用户的计算机上，以便在后续请求中使用。</li><li><strong>Session</strong>：Session数据存储在服务器上，不会在用户浏览器中留下痕迹。</li></ul></li><li><p>数据容量：</p><ul><li><strong>Cookie</strong>：Cookie的存储容量通常较小，一般限制在几KB。这适用于存储少量的文本数据，如用户首选项或购物车中的几个商品。</li><li><strong>Session</strong>：Session的存储容量通常较大，不受明确定义的限制，因为它们可以利用服务器的资源，用于存储更多的数据，如用户登录状态、购物车内容等。</li></ul></li><li><p>安全性：</p><ul><li><strong>Cookie</strong>：由于Cookie存储在用户浏览器中，它们容易受到安全威胁。例如，Cookie可以被用户查看和修改，从而可能引发安全漏洞。</li><li><strong>Session</strong>：Session数据存储在服务器上，不容易被用户直接访问或篡改，因此相对更安全。</li></ul></li><li><p>传输方式：</p><ul><li><strong>Cookie</strong>：每次用户向服务器发送HTTP请求时，浏览器会自动将相关的Cookie信息附加到请求头中，以便服务器可以提取这些信息。</li><li><strong>Session</strong>：通常，Session ID会存储在Cookie中或者通过URL参数传递给服务器。服务器使用Session ID来查找并还原用户的会话数据。</li></ul></li></ol><p>示例：<br>假设有一个在线购物网站，用户在登录后可以将商品添加到购物车。以下是Cookie和Session在这个场景中的应用：</p><ul><li><p><strong>Cookie的应用</strong>：当用户登录后，服务器可以创建一个包含用户ID和购物车内容的Cookie，并在用户的浏览器中存储。每次用户浏览不同商品或查看购物车时，浏览器都会自动将Cookie信息发送到服务器，服务器通过Cookie中的用户ID来识别用户，并获取购物车内容。然而，由于Cookie易于修改，用户可能尝试篡改购物车中的商品数量。</p></li><li><p><strong>Session的应用</strong>：当用户登录后，服务器创建一个与该用户相关联的Session，其中包含用户ID和购物车内容等信息。Session数据存储在服务器上，而不会发送到用户浏览器中。每次用户进行操作时，服务器使用Session ID（通常存储在Cookie中）来查找并还原用户的购物车内容，而用户无法直接修改Session数据，因为它们位于服务器上，更加安全。</p></li></ul><p>综上所述，Cookie和Session在不同情况下用于管理用户状态和身份，具有各自的优势和限制，开发人员应根据应用程序的需求和安全性考虑选择合适的机制。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-15-day10</title>
      <link href="/posts/1e82b846.html"/>
      <url>/posts/1e82b846.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先应该先明确队列是先进先出,</p><p>而栈是先进后出,而如果想用栈实现队列,就可以尝试用两个栈</p><p>进栈和出栈</p><ul><li>进栈模拟入队列</li><li>出栈模拟先出队列</li></ul><p>画图如下</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171830073.png" alt="image-20230917183021976"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class MyQueue &#123;                                Stack&lt;Integer&gt; stIn;                Stack&lt;Integer&gt; stOut;    public MyQueue() &#123;      stIn = new Stack&lt;&gt;();            stOut = new Stack&lt;&gt;();    &#125;        public void push(int x) &#123;                        stIn.push(x);    &#125;        public int pop() &#123;                               if(stOut.isEmpty())&#123;                            while(!stIn.isEmpty())&#123;                                stOut.push(stIn.pop());                            &#125;                         &#125;                        return stOut.pop();    &#125;        public int peek() &#123;                            int res = this.pop();                            stOut.push(res);                            return res;                                &#125;        public boolean empty() &#123;                            return stOut.isEmpty()&amp;&amp;stIn.isEmpty();    &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">class MyQueue &#123;public:                stack&lt;int&gt; stIn;                stack&lt;int&gt; stOut;                    MyQueue() &#123;    &#125;        void push(int x) &#123;                        stIn.push(x);    &#125;        int pop() &#123;                            if(stOut.empty())&#123;                                while(!stIn.empty())&#123;                                    stOut.push(stIn.top());                                    stIn.pop();                                &#125;                            &#125;                            int result = stOut.top();                            stOut.pop();                            return result;    &#125;        int peek() &#123;                        int res = this-&gt;pop();                        stOut.push(res);                        return res;    &#125;         bool empty() &#123;                        return stIn.empty()&amp;&amp;stOut.empty();    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */</code></pre><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度: push和empty为O(1), pop和peek为O(n)</p><p>空间复杂度: O(n)</p><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>队列是先进先出原则,</p><p>而栈是先进后出原则</p><p>因此,可以使用两个队列来实现栈</p><p><strong>可以使用一个队列来实现栈</strong></p><p>满足先进后出的方法就是; 入队列之后,就将这个数放到队首</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309171847163.png" alt="image-20230917184757095"></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code class="c">class MyStack &#123;public:                queue&lt;int&gt; que;    MyStack() &#123;    &#125;        void push(int x) &#123;                        que.push(x);    &#125;        int pop() &#123;                        int size = que.size();                        size--;                        while(size--)&#123;                            que.push(que.front());                            que.pop();                        &#125;                        int res = que.front();                        que.pop();                        return res;    &#125;        int top() &#123;                    return que.back();    &#125;        bool empty() &#123;                        return que.empty();    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><pre><code class="java">class MyStack &#123;    Queue&lt;Integer&gt; que = new LinkedList&lt;&gt;();    public MyStack() &#123;    &#125;        public void push(int x) &#123;            que.add(x);    &#125;        public int pop() &#123;        rePosition();        return que.poll();    &#125;        public int top() &#123;        rePosition();        int res = que.poll();        que.add(res);        return res;    &#125;        public boolean empty() &#123;        return que.isEmpty();    &#125;    public void rePosition()&#123;        int size = que.size();        size--; // 不包括刚刚添加的数        while(size-- &gt; 0)&#123;            que.add(que.poll());        &#125;    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */</code></pre><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: pop为O(n)，其他为O(1)</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-13-day8</title>
      <link href="/posts/23a5053d.html"/>
      <url>/posts/23a5053d.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="Problem-344-反转字符串"><a href="#Problem-344-反转字符串" class="headerlink" title="Problem: 344. 反转字符串"></a>Problem: <a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义两个指针,分别初始化为指向左端点和指向右端点,</p><p>当<code>l &lt; r</code>的时候,说明二者已将字符转遍历完</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140023893.png" alt="image-20230914002307799"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public void reverseString(char[] s) &#123;                int l = 0;                int r = s.length - 1;               while(l&lt;r)&#123;                char temp = s[l];                s[l] = s[r];                s[r] = temp;                l++;                r--;                &#125;    &#125;&#125;</code></pre><h1 id="Problem-541-反转字符串-II"><a href="#Problem-541-反转字符串-II" class="headerlink" title="Problem: 541. 反转字符串 II"></a>Problem: <a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符,所以可以定义一个指针 i ,来从起点,以2k的长度来遍历,</p><p>在遍历的同时,需要判断此时的位置是否超出字符串的长度</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140114051.png" alt="image-20230914003144804"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140032858.png" alt="image-20230914003241823"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140038341.png" alt="image-20230914003825298"></p><blockquote><p>比较容易疑惑的就是边界问题</p><p>例如:<code>if(i + k &lt;= ch.length)</code>在这个判断条件下,<code>ch.length - 1</code>也能通过,</p><p>这是因为,这一步边界的判断是为了操作最后剩余的数,事实上,在for循环里,循环条件便是i &lt; ch.length,所以到最后一步后,操作是统一的,都是<code> reverse(ch, i, ch.length-1); reverse(ch, i, ch.length-1);</code>这里的reverse是自己实现的左闭右闭原则</p></blockquote><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public String reverseStr(String s, int k) &#123;        char[] ch = s.toCharArray();        for(int i = 0; i &lt; ch.length; i += 2*k)&#123;            if(i + k &lt;= ch.length)&#123;                reverse(ch , i, i+k-1);                continue;            &#125;            reverse(ch, i, ch.length-1); //这里自己实现的reverse是左闭右闭原则,所以ch.length-1        &#125;        return new String(ch);    &#125;    public void reverse(char[] ch, int i, int j)&#123;        for(; i &lt;= j; i++,j--)&#123;            char temp = ch[i];            ch[i] = ch[j];            ch[j] = temp;        &#125;    &#125;&#125;</code></pre><h1 id="Problem-题目：剑指Offer-05-替换空格"><a href="#Problem-题目：剑指Offer-05-替换空格" class="headerlink" title="Problem: 题目：剑指Offer 05.替换空格"></a>Problem: <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">题目：剑指Offer 05.替换空格</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为要把空格替换为“%20”, 所以容易知道:</p><p>数组的长度是需要扩大的,可以在原数组增大,或者创建一个新的数组</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140049824.png" alt="image-20230914004917681"></p><p>可以定义两个指针,从新数组最后往前遍历,和从老数组后往前遍历,这样可以省去从前往后每次遇到空格需要挪动数组的操作</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309140058237.png" alt="image-20230914005831852"></p><p>将 <code>j</code>遍历的字符赋值给<code>i</code>, 如果遇到空格, <code>i</code>就独自往前赋值为“%20”, 然后和<code>j</code>继续重复以上操作</p><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c++">class Solution &#123;public:    string replaceSpace(string s) &#123;        int count = 0; // 统计空格的个数        int sOldSize = s.size();        for (int i = 0; i &lt; s.size(); i++) &#123;            if (s[i] == &#39; &#39;) &#123;                count++;            &#125;        &#125;        // 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小        s.resize(s.size() + count * 2);        int sNewSize = s.size();        // 从后先前将空格替换为&quot;%20&quot;        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--) &#123;            if (s[j] != &#39; &#39;) &#123;                s[i] = s[j];            &#125; else &#123;                s[i] = &#39;0&#39;;                s[i - 1] = &#39;2&#39;;                s[i - 2] = &#39;%&#39;;                i -= 2;            &#125;        &#125;        return s;    &#125;&#125;;</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>可以利用StringBuilder来从前往后遍历,如果遇到空格,就<code>append(&quot;%20&quot;)</code></p><p>其余就<code>qppend(&quot;字符&quot;)</code></p><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;            if(s == null)&#123;                return null;            &#125;            StringBuilder sb = new StringBuilder();            for(int i = 0; i &lt; s.length(); i++)&#123;                if(s.charAt(i) == &#39; &#39;)&#123;                    sb.append(&quot;%20&quot;);                &#125;else&#123;                    sb.append(s.charAt(i));                &#125;                      &#125;               return sb.toString();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-11-day6</title>
      <link href="/posts/89d58931.html"/>
      <url>/posts/89d58931.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="242-有效字母的异位词"><a href="#242-有效字母的异位词" class="headerlink" title="242.有效字母的异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效字母的异位词</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>简单的两层for循环,同时记录字符是否重复出现,很明显时间复杂度是$O(n^2)$</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>再遍历 字符串s的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。</strong> 这样就将字符串s中字符出现的次数，统计出来了。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142128713.png" alt="image-20230914212802619"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142130536.png" alt="image-20230914213003490"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">class Solution &#123;    public boolean isAnagram(String s, String t) &#123;      int[] record = new int[26];      for(int i = 0; i&lt;s.length(); i++)&#123;        record[s.charAt(i) - &#39;a&#39;]++;      &#125;      for(int i = 0; i &lt; t.length(); i++)&#123;        record[t.charAt(i)-&#39;a&#39;]--;      &#125;      for(int i = 0; i &lt; 26; i++)&#123;        if(record[i] != 0)&#123;          return false;        &#125;      &#125;      return true;    &#125;     &#125;</code></pre><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为是找 <strong>交集</strong>, 所以可以先去重:</p><ul><li>先将nums1放在Set容器中,(不包含重复元素)</li><li>然后遍历nums2元素,查看Set容器中是否包含nums2元素</li><li>如果包括:就放在另一个resSet集合中</li></ul><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(mn)</li><li>空间复杂度: O(n)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class Solution &#123;    public int[] intersection(int[] nums1, int[] nums2) &#123;        if(nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0)&#123;            return new int[0];        &#125;        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();        Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;();        for(int i: nums1)&#123;            set1.add(i);        &#125;        for(int i: nums2)&#123;            if(set1.contains(i))            set2.add(i);        &#125;        // return set2.stream().mapToInt(x-&gt;x).toArray();        //方法二: 再申请一个数组        int[] arr = new int[set2.size()];        int j = 0;        for(int i:set2)&#123;            arr[j++] = i;        &#125;        return arr;    &#125;&#125;</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="C++">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; resSet;        unordered_set&lt;int&gt; numsSet(nums1.begin(), nums1.end());        for(int  i: nums2)&#123;            if(numsSet.find(i) != numsSet.end())&#123;                resSet.insert(i);            &#125;        &#125;        return vector&lt;int&gt;(resSet.begin(),resSet.end()); //强制转化为数组    &#125;&#125;;</code></pre><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以可以考虑哈希法</p><ul><li><p>第一步: 首先可以定义一个<code>set</code>存放数据,避免重复.</p></li><li><p>第二步: 然后再while(true)中无限循环,先求出一个数各单数平方的和相加</p></li><li><p>第三步:如果这个数为1, 直接返回true </p></li><li><p>第四步:否则继续向下判断:在set中是否出现过,如果出现过,说明这个数永远不能到1, 即不是一个快乐数.  如果没出现过,那么就将这个和</p></li></ul><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class Solution &#123;    public int getSum(int n)&#123;        int sum = 0;        while(n != 0)&#123;            sum += (n%10)*(n%10);            n = n/10;               &#125;        return sum;    &#125;    public boolean isHappy(int n) &#123;        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        while(true)&#123;            int sum = getSum(n);            if(sum == 1)&#123;                return true;            &#125;            if(set.contains(sum))            &#123;                return false;            &#125; else set.add(sum);            n = sum;        &#125;        &#125;&#125;</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C+&#x3D;"></a>C+&#x3D;</h3><pre><code class="c++">class Solution &#123;public: int getSum(int n)&#123;            int sum = 0;            while(n)&#123;                sum+=(n%10)*(n%10);                n/=10;            &#125;            return sum;        &#125;    bool isHappy(int n) &#123;    unordered_set&lt;int&gt; set;    while(1)&#123;        int sum = getSum(n);        if(sum == 1)&#123;            return true;        &#125;        if(set.find(sum) != set.end())&#123;            return false;        &#125;else&#123;            set.insert(sum);        &#125;        n = sum;     &#125;    &#125;&#125;;</code></pre><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>再回想一下为什么使用哈希法?</strong></p><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>选用map来存储key value,为了寻找两个数,将数的值作为<code>key</code> 数的下标作为<code>value</code></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142234874.png" alt="image-20230914223409718"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309142234658.png" alt="image-20230914223416547"></p><h2 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><pre><code class="c++">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        std::unordered_map&lt;int,int&gt; map;        for(int i = 0; i &lt; nums.size(); i++)&#123;            auto iter = map.find(target - nums[i]);            // 看是否与target匹配的ket            if(iter != map.end())&#123;                return &#123;iter-&gt;second,i&#125;;            &#125;            //如果没找到匹配对,就把访问过的下标加入到map中            map.insert(pair&lt;int,int&gt;(nums[i],i));        &#125;        return &#123;&#125;;    &#125;&#125;;</code></pre><h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h3><pre><code class="java">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int[] res = new int[2];        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i = 0; i &lt; nums.length; i++)&#123;            if(map.containsKey(target - nums[i]))&#123;                res[0] = i;                res[1] = map.get(target-nums[i]);                break;            &#125;            map.put(nums[i],i);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo n 算法60天训练–9-10-day5</title>
      <link href="/posts/c5f5785.html"/>
      <url>/posts/c5f5785.html</url>
      
        <content type="html"><![CDATA[<h1 id="周日-休息日"><a href="#周日-休息日" class="headerlink" title="周日,休息日"></a>周日,休息日</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-8-day3</title>
      <link href="/posts/7f126f49.html"/>
      <url>/posts/7f126f49.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="算法60天训练–9-8-day3"><a href="#算法60天训练–9-8-day3" class="headerlink" title="算法60天训练–9-8-day3"></a>算法60天训练–9-8-day3</h1><p>[TOC]</p><p>(画图有些不规范)</p><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先删除一个链表元素,无非就是将要删除的链表结点的上一个结点指向这个被删除链表的下一个结点</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101051269.png" alt="image-20230910105127232"></p><p>这里在刚开始将<code>cur = dummy_head</code>,是为了将删除头结点的操作和其他结点的操作统一</p><p>即永远操作的结点都为<code>cur-&gt;next</code></p><p>直到为空,在这个过程中找到要被删除的结点,执行删除操作</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code(JAVA)"></a>Code(JAVA)</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeElements(ListNode head, int val) &#123;        ListNode dummy_Node = new ListNode(0);        dummy_Node.next = head;        ListNode cur = dummy_Node;        while(cur.next != null)&#123;            if(cur.next.val == val)            cur.next = cur.next.next;            else cur  = cur.next;        &#125;        return dummy_Node.next;    &#125;&#125;</code></pre><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">707. 设计链表</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这是一个比较综合的题目</p><h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p>这个跟其他链表元素有区别,将<code>cur = dummyhead-&gt;next</code> 是为了解决index等于0的情况,避免没有进入while循环而造成直接返回return cur-&gt;val; </p><h4 id="addAtHead"><a href="#addAtHead" class="headerlink" title="addAtHead"></a>addAtHead</h4><p>在 链表头插入时要注意顺序问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101053274.png" alt="image-20230910105320233"></p><h4 id="addAtTail"><a href="#addAtTail" class="headerlink" title="addAtTail"></a>addAtTail</h4><p>直接在结尾插入即可</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101053862.png" alt="image-20230910105345821"></h4><h4 id="addAtIndex"><a href="#addAtIndex" class="headerlink" title="addAtIndex"></a>addAtIndex</h4><p>还是注意插入的顺序问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101054396.png" alt="image-20230910105438357"></p><h4 id="deleteAtIndex"><a href="#deleteAtIndex" class="headerlink" title="deleteAtIndex"></a>deleteAtIndex</h4><p>找到要删除的结点,将该结点的上一个结点指向下一个结点</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101050621.png" alt="image-20230910011347372"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度: 涉及 index 的相关操作为 O(index), 其余为 O(1)</p><p>空间复杂度: O(n)</p><h3 id="Code-C"><a href="#Code-C" class="headerlink" title="Code(C++)"></a>Code(C++)</h3><pre><code class="c++">class MyLinkedList &#123;public:    struct ListNode&#123;        int val;        ListNode* next;        ListNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;    MyLinkedList() &#123;        dummy_head = new ListNode(0);        _size = 0;    &#125;       int get(int index) &#123;        if(index &gt; (_size-1) || index &lt; 0)&#123;            return -1;        &#125;        ListNode* cur = dummy_head-&gt;next;//要在虚拟头节点的下一个结点,以解决index等于0的情况        while(index--)&#123;            cur = cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;        void addAtHead(int val) &#123;         ListNode* newNode = new ListNode(val);         newNode-&gt;next = dummy_head-&gt;next;         dummy_head-&gt;next = newNode;          _size++;      &#125;        void addAtTail(int val) &#123;         ListNode* cur = dummy_head;         ListNode* newNode = new ListNode(val);         while(cur-&gt;next != nullptr)&#123;             cur = cur-&gt;next;         &#125;         cur-&gt;next = newNode;         _size++;    &#125;        void addAtIndex(int index, int val) &#123;        ListNode* newNode = new ListNode(val);        ListNode* cur = dummy_head;        if(index &gt; _size) return;        while(index--)&#123;           cur = cur-&gt;next;        &#125;         newNode-&gt;next = cur-&gt;next;//要保证操作的节点是cur-&gt;next;         cur-&gt;next = newNode;        _size++;    &#125;        void deleteAtIndex(int index) &#123;        if (index &gt; _size-1 || index &lt; 0) &#123;            return;        &#125;        // 要保证第n个结点一定要是cur-&gt;next;        ListNode* cur = dummy_head;        ListNode* temp = NULL;        while(index--)&#123;          cur = cur-&gt;next;        &#125;        temp = cur-&gt;next;        cur-&gt;next = cur-&gt;next-&gt;next;         delete temp;        temp = nullptr;        _size--;    &#125;private:    int _size;    ListNode* dummy_head;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */</code></pre><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>定义一个temp,来临时存放cur-&gt;next,这样在cur-&gt;next &#x3D; pre之后,才能将cur &#x3D; temp到下一个结点去</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101050994.png" alt="image-20230910012140226"></p><h3 id="Code-JAVA-1"><a href="#Code-JAVA-1" class="headerlink" title="Code(JAVA)"></a>Code(JAVA)</h3><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode cur = head;        ListNode temp = new ListNode();        while(cur != null)&#123;            temp = cur.next; //因为如果将cur指向pre后就无法找到cur的下一个节点了            cur.next = pre;            pre = cur;            cur = temp;        &#125;        return pre;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-9-day4</title>
      <link href="/posts/2a2a294f.html"/>
      <url>/posts/2a2a294f.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="Problem-24-两两交换链表中的节点"><a href="#Problem-24-两两交换链表中的节点" class="headerlink" title="Problem: 24. 两两交换链表中的节点"></a>Problem: <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两两交换结点.首先要定义一个虚拟头结点,还有cur起始指向虚拟头结点,来将对于链表的所有操作进行统一,</p><p>然后按照以下的图演示步骤进行操作.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130032243.png" alt="image-20230913003224212"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130030359.png" alt="img"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>●时间复杂度: O(n) </p><p>● 空间复杂度: O(1)</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;  public ListNode swapPairs(ListNode head) &#123;    ListNode dummy_head = new ListNode(0);    dummy_head.next = head;    ListNode cur = dummy_head;    ListNode temp1;            while(cur.next != null &amp;&amp; cur.next.next!=null)&#123;      temp1 = cur.next;      temp2 = cur.next.next.next;      cur.next = cur.next.next; //步骤一      cur.next.next = temp1;//步骤二      temp1.next = temp2;//步骤三      cur = cur.next.next;//步骤四    &#125;    return dummy_head.next;  &#125;&#125;</code></pre><p>C++</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummy_head = new ListNode(0);        dummy_head-&gt;next = head;        ListNode* cur = dummy_head;        while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next!=nullptr )&#123;//注意顺序,避免空指针异常            ListNode* temp1 = cur-&gt;next; //保留相对第一个结点            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next; //保留结点            cur-&gt;next = cur-&gt;next-&gt;next;//第一步            cur-&gt;next-&gt;next = temp1;//第二步            cur-&gt;next-&gt;next-&gt;next = temp2;//第三步                        cur = cur-&gt;next-&gt;next; // cur移动两位,准备下一轮交换        &#125;        return dummy_head-&gt;next;    &#125;&#125;;</code></pre><h1 id="Problem-19-删除链表的倒数第-N-个结点"><a href="#Problem-19-删除链表的倒数第-N-个结点" class="headerlink" title="Problem: 19. 删除链表的倒数第 N 个结点"></a>Problem: <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>让fast先移动n位,然后再往后移动一位,之后和slow一起移动,直到fast指向为空</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309110905335.png" alt="img"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309110905639.png" alt="img"></p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy_head = new ListNode(0);        dummy_head.next = head;        ListNode fast = dummy_head;        ListNode slow = dummy_head;        while(n-- &gt; 0)&#123;            fast = fast.next;        &#125;        fast = fast.next;        while(fast != null)&#123;            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return dummy_head.next;    &#125;&#125;</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummy_head = new ListNode(0);        dummy_head-&gt;next = head;        ListNode* fast = dummy_head;        ListNode* slow = dummy_head;                while(n--)&#123;            fast = fast-&gt;next;        &#125;        fast = fast-&gt;next; // 让fast多走一位,使得slow指向被删除结点的前一个结点        while(fast != nullptr)&#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        ListNode* temp = slow-&gt;next;        slow-&gt;next = slow-&gt;next-&gt;next;        return dummy_head-&gt;next;    &#125;&#125;;</code></pre><h1 id="Problem-142-环形链表-II"><a href="#Problem-142-环形链表-II" class="headerlink" title="Problem: 142. 环形链表 II"></a>Problem: <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130031788.png" alt="image-20230913001419393">fast走两步,slow走一步<br>所以fast永远相对slow走一步</p><ul><li><p>所以二者一定在第一圈相遇</p></li><li><p>要求环形链表入口点</p></li><li><p>因为两指针相遇,</p></li><li><p><strong>fast &#x3D; x + y + n (y + z)</strong>,</p></li><li><blockquote><p> n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A</p></blockquote></li><li><p><strong>slow &#x3D; x + y</strong></p></li></ul><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p><pre><code>(x + y) * 2 = x + y + n (y + z)</code></pre><p>将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>因为y+z是一圈,所以, 可将(n - 1) (y + z)看作0, </p><p>这个时候灯饰就为: <strong>x &#x3D; 0 + z</strong> <strong>即x  &#x3D; z</strong></p><p> 这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p><p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309130031171.png" alt="image-20230913002319285"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li><li>空间复杂度: O(1)</li></ul><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><pre><code class="java">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode detectCycle(ListNode head) &#123;        ListNode fast = head;        ListNode slow = head;        while(fast != null &amp;&amp; fast.next != null)&#123; //在有环的前提下            fast = fast.next.next;            slow = slow.next;            if(fast == slow)&#123; //相遇,说明有环                ListNode index1 = fast;                ListNode index2 = head;                while(index1 != index2)&#123;                    index1 = index1.next;                    index2 = index2.next;                &#125;                return index1;            &#125;        &#125;        return null;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9.7(day2)</title>
      <link href="/posts/aede4b42.html"/>
      <url>/posts/aede4b42.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="算法60天训练–9-7-day2"><a href="#算法60天训练–9-7-day2" class="headerlink" title="算法60天训练–9.7(day2)"></a>算法60天训练–9.7(day2)</h1><p>[TOC]</p><h2 id="Problem977-有序数组的平方"><a href="#Problem977-有序数组的平方" class="headerlink" title="Problem977. 有序数组的平方"></a>Problem<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></h2><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><blockquote><p>因为<strong>非递减数组</strong>,在两边的平方要么是最大,要么是最小,一定是在两边,所以这时候可以用双指针,</p><p>在数组两边定义两个指针,当左边的平方小于右边的平方,就往一个新数组放,放在最大索引处,然后左边++,同理,右边–.直到左边小于右边</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fcd55d8be8c8386bbb805e6f7155dd30.png" alt="image-20230907214610773"></p></blockquote><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度:</li></ul><blockquote><p>$O(n)$</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><pre><code class="Java">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        int[] res = nums;        for(int i = 0 ; i &lt; nums.length; i++)&#123;            res[i] *= nums[i];        &#125;                           Arrays.sort(res) ;//如果递减就  Arrays.sort(a, Collections.reverseOrder());        return res;    &#125;  &#125;</code></pre><p>时间复杂度:$O(n + nlog n)$</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><pre><code class="Java">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        int []res = new int[nums.length]; //递增存到新数组中        int k = nums.length-1; //新数组的索引                for(int l = 0, r = nums.length-1; l &lt;= r; )&#123;            if(nums[l]*nums[l] &lt;= nums[r]*nums[r]) &#123;                 res[k--] = nums[r]*nums[r];                 r --;            &#125;                           else&#123;                res[k--] = nums[l]*nums[l];                l++;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p>时间复杂度:$O(n)$</p><h2 id="Problem-209-长度最小的子数组"><a href="#Problem-209-长度最小的子数组" class="headerlink" title="Problem: 209. 长度最小的子数组"></a>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="直接暴力"><a href="#直接暴力" class="headerlink" title="直接暴力"></a>直接暴力</h3><p>两层for循环,比较简单,不做演示</p><h3 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h3><p>使用一个for循环完成操作:</p><p>所谓滑动窗口,就是不断调节子序列的起始位置和终止位置,从而得出我们想要的结果</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2f78be28a0f2fc7596c032b7706bdbd7.png" alt="image-20230907220554936"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/806b60109cf14179c01840ca94112367.png" alt="image-20230907220606299"></p><h3 id="代码-java"><a href="#代码-java" class="headerlink" title="代码(java)"></a>代码(java)</h3><pre><code class="java">class Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;                            // 使用滑动窗口解法                            int i = 0;// 起始位置                            int j = 0; // 滑动窗口右端点                            int sum = 0;                            int subL = 0; //滑动窗口长度                            int result = Integer.MAX_VALUE;                            for(j = 0 ; j &lt; nums.length; j++)&#123;                                sum += nums[j];                                while(sum &gt;= target)&#123;//开始缩小窗口,注意这里是while循环，缩小滑动窗口操作是一个持续性的操作                                  subL = j - i + 1;                                  result = Math.min(result,subL);                                sum = sum - nums[i];                                  i++;                                &#125;                                                            &#125;                            return result == Integer.MAX_VALUE ? 0 : result; // 注意有没有被赋值    &#125;&#125;</code></pre><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><h2 id="Problem-59-螺旋矩阵-II"><a href="#Problem-59-螺旋矩阵-II" class="headerlink" title="Problem: 59. 螺旋矩阵 II"></a>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题无非就是遍历二维数组,一层层向里遍历,但是不统一规定遍历每一条边的边界,会非常的混乱</p><p>所以本题采用循环不变量,对于判断每次螺旋的边界麻烦,不妨都采取左闭又开的原则</p><p>第一个不太好理解的地方就是为什么循环n&#x2F;2圈?是因为最后循环结束的时候StartX一定是在相对于第一条边中间的位置,那么循环了多少圈就可以由这个点对两边的竖边的条数进行分割.两边的条数一定是相等的,有就是转了多少圈.</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202309072228459.png" alt="image-20230907221135198"></p><p><strong>由图可以发现,转了3圈</strong></p><p>第二个地方就是左开右闭,每到一个节点就进入下一个边的循环.</p><p>在每个圈数结束后,更新起点,横纵坐标都加一.startX+1;startY+1</p><p>如果n&#x2F;2等于一,说明最中间有单独的数,直接单独赋值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><pre><code class="java">class Solution &#123;    public int[][] generateMatrix(int n) &#123;        int loop = 0; // 控制循环次数        int [][] res = new int[n][n];        int start = 0; //每次循环的开始点(start, start)        int count = 1; //定义填充数字        int i,j;        while(loop ++ &lt; n/2)&#123;//判断边界后,loop从1开始        //模拟上侧从左到右        for(j = start; j&lt;n-loop; j++)&#123;// n-loop 是为了左闭又开            res[start][j] = count++;        &#125;        //模拟右侧从上到下        for(i = start; i &lt; n-loop; i++)&#123;            res[i][j] = count++;        &#125;                for(;j&gt;=loop;j--)&#123;//此时loop等于一,startX+1的位置            res[i][j] = count++;        &#125;        // 模拟从下到上        for(;i&gt;=loop;i--)&#123; //此时loop等于一,startY+1的位置            res[i][j] = count++;        &#125;        start++;        &#125;        if(n%2 == 1)&#123;            res[start][start] = count;        &#125;        return res;    &#125;&#125;</code></pre><p>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间<br>空间复杂度 O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法60天训练–9-6-day1</title>
      <link href="/posts/ab166f15.html"/>
      <url>/posts/ab166f15.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[TOC]</p><h1 id="算法60天训练–9-6-day1"><a href="#算法60天训练–9-6-day1" class="headerlink" title="算法60天训练–9-6-day1"></a>算法60天训练–9-6-day1</h1><h2 id="Problem-704-二分查找"><a href="#Problem-704-二分查找" class="headerlink" title="Problem: 704. 二分查找"></a>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>从题目中可以看出,数组中的元素是<strong>有序的</strong>,而且是<strong>不重复的</strong>,很满足二分法的使用条件,所以使用二分法来解决这道题,同时二分有两种情况,一种是左闭右闭,一种是左闭右开,而这两种情况在代码的形式上是不一样的.</p></blockquote><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><blockquote><p>以right &#x3D;&#x3D; left(两边顶点)为终止条件,根据左闭又开或左闭右闭来调整每一轮循环之后right和left两边端点的位置.始终将target在端点之间,直到right &#x3D; left.</p></blockquote><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101538656.png" alt="image-20230910153841532"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度:</li></ul><blockquote><p>O(log n)</p></blockquote><ul><li>空间复杂度:</li></ul><blockquote><p>O(1)</p></blockquote><h3 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code[JAVA]"></a>Code[JAVA]</h3><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int left = 0, right = nums.length;        while(left &lt; right) &#123;            int mid = right+left &gt;&gt; 1;            if(nums[mid] &gt; target)&#123;                right = mid;            &#125;            else if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;            else return mid;        &#125;        return -1;    &#125;&#125;</code></pre><h3 id="Code-C"><a href="#Code-C" class="headerlink" title="Code[C++]"></a>Code[C++]</h3><pre><code class="C++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;                int left = 0;        int right = nums.size()-1;        while(left &lt;= right)&#123;            int middle  = left + ((right-left)&gt;&gt;1);            if(nums[middle] &lt; target)&#123;                left = middle+1;            &#125;            if(nums[middle] &gt; target)&#123;                right = middle-1;//右开            &#125;           if(nums[middle] == target)&#123;              return middle;           &#125;        &#125;        return -1;    &#125;&#125;;</code></pre><h2 id="Problem-27-移除元素"><a href="#Problem-27-移除元素" class="headerlink" title="Problem: 27. 移除元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先可以两个for循环遍历.很简单</p><p>但是如果要减小时间复杂度,可以采用双指针解法</p><h3 id="双指针方法"><a href="#双指针方法" class="headerlink" title="双指针方法"></a>双指针方法</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101546315.png" alt="image-20230910154659274"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/imags/202309101547470.png" alt="image-20230910154707431"></p><p>首先定义两个指针<strong>fast,slow,<strong>如果fast指针指向的元素不等于要删除的元素,那么slow跟随fas</strong>t一起往右移动</strong>,,如果fast指向的元素<strong>等于要被删除的元素,</strong></p><p>那么slow不动,fast向右移动,<strong>直到fast-&gt;val不等于要被删除的元素</strong>,然后将其值赋<strong>值给slow指向的元素</strong>,如此循环,直到最右边,达到前面的等于2的元素被删除的目的.</p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度: </p><blockquote><p>添加时间复杂度： $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>添加空间复杂度： $O(1)$</p></blockquote></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int fastIndex = 0;        int slowIndex = 0;        for(fastIndex; fastIndex &lt; nums.size(); fastIndex++)&#123;            if(nums[fastIndex] != val)&#123;                nums[slowIndex]  = nums[fastIndex];                slowIndex++;            &#125;                    &#125;        return slowIndex;//移动几次说明有几个重复元素    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器Interceptor</title>
      <link href="/posts/13c6d42e.html"/>
      <url>/posts/13c6d42e.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>什么是拦截器？ </p><p>是一种动态拦截方法调用的机制，类似于过滤器。 拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。 </p><p>拦截器的作用： </p><p>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。 在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请 求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且 是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令 牌，就可以直接给前端响应未登录的错误信息。</p><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>实现HandlerInterceptor接口，并重写其所有方法</p><pre><code class="java">//自定义拦截器@Componentpublic class LoginCheckInterceptor implements HandlerInterceptor &#123;//目标资源方法执行前执行。 返回true：放行 返回false：不放行@Overridepublic boolean preHandle(HttpServletRequest request,HttpServletResponse response, Object handler) throws Exception &#123;System.out.println(&quot;preHandle .... &quot;);return true; //true表示放行 &#125;//目标资源方法执行后执行@Overridepublic void postHandle(HttpServletRequest request,HttpServletResponse response, Object handler, ModelAndViewmodelAndView) throws Exception &#123;System.out.println(&quot;postHandle ... &quot;); &#125;//视图渲染完毕后执行，最后执行@Overridepublic void afterCompletion(HttpServletRequest request,HttpServletResponse response, Object handler, Exception ex) throwsException &#123;System.out.println(&quot;afterCompletion .... &quot;); &#125;&#125;</code></pre><blockquote><p>注意： preHandle方法：目标资源方法执行前执行。 返回true：放行 返回false：不放行 postHandle方法：目标资源方法执行后执行 afterCompletion方法：视图渲染完毕后执行，最后执行</p></blockquote><h2 id="注册配置拦截器"><a href="#注册配置拦截器" class="headerlink" title="注册配置拦截器"></a>注册配置拦截器</h2><p>实现WebMvcConfigurer接口，并重写addInterceptors方法</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;//自定义的拦截器对象    @Autowired    private LoginCheckInterceptor loginCheckInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;    //注册自定义拦截器对象    registry.addInterceptor(loginCheckInterceptor).addPathPatterns(&quot;/**    &quot;);//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）     &#125;&#125;</code></pre><h2 id="Interceptor详解"><a href="#Interceptor详解" class="headerlink" title="Interceptor详解"></a>Interceptor详解</h2><h2 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h2><p>首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径， 通过 <code>addPathPatterns</code>(“要拦截路径”) 方法，就可以指定要拦截哪些资源。 在入门程序中我们配置的是 &#x2F;** ，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资 源，还可以指定不拦截哪些资源，只需要调用 <code>excludePathPatterns</code>(“不拦截路径”) 方法，指定哪些 资源不需要拦截。</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    //拦截器对象    @Autowired    private LoginCheckInterceptor loginCheckInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;    //注册自定义拦截器对象    registry.addInterceptor(loginCheckInterceptor)     .addPathPatterns(&quot;/**&quot;)//设置拦截器拦截的请求路径（ /**    表示拦截所有请求）     .excludePathPatterns(&quot;/login&quot;);//设置不拦截的请求路径     &#125;&#125;</code></pre><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261811132.png" alt="image-20230826181149973"></p><ul><li>当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到 这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当 前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我 们所定义的controller当中的接口方法。</li><li>Tomcat并不识别所编写的Controller程序，但是它识别<code>Servlet</code>程序，所以在Spring的Web环 境中提供了一个非常核心的<code>Servlet：DispatcherServlet</code>（前端控制器），所有请求都会先 进行到&#96;&#96;DispatcherServlet&#96;，再将请求转给Controller。</li><li>当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行 <code>preHandle() </code>方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回<code>true</code>，就表示放 行本次操作，才会继续访问controller中的方法；如果返回<code>false</code>，则不会放行（controller 中的方法也不会执行）。</li><li>在controller当中的方法执行完毕之后，再回过来执行 <code>postHandle() </code>这个方法以及 <code>afterCompletion()</code> 方法，然后再返回给<code>DispatcherServlet</code>，最终再来执行过滤器当中放 行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。</li></ul><p>参考黑马程序员课程</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT令牌详解</title>
      <link href="/posts/52c52e8d.html"/>
      <url>/posts/52c52e8d.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JWT全称：JSON Web Token （官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。 自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt 令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。 简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在 通信双方安全的进行信息传输了。</p></blockquote><h2 id="JWT的组成："><a href="#JWT的组成：" class="headerlink" title="JWT的组成："></a>JWT的组成：</h2><p>（JWT令牌由三个部分组成，三个部分之间使用英文的点来分割） 第一部分：Header(头）， 记录令牌类型、签名算法等。 例如： {“alg”:”HS256”,”type”:”JWT”} 第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如： {“id”:”1”,”username”:”Tom”} 第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加 入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在， 所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡 改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。</p></blockquote><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261527163.png" alt="image-20230826152706061"></p><blockquote><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？ 其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码 Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味 着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是 64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符 号，那就是等号。等号它是一个补位的符号 需要注意的是Base64是编码方式，而不是加密方式。</p></blockquote><p><strong>既然这样, 编码和加密的区别是什么呢?</strong></p><p><strong>加密</strong>是对数据进行安全<strong>编码</strong>的过程，以便只有知道密钥或密码的授权用户才能为其他人检索原始数据，这只是垃圾。 <strong>编码</strong>是将数据转换为这样一种格式的过程，该格式可以由不同类型的系统使用公开可用的算法进行。 <strong>加密</strong>的目的是转换数据以使其对他人保密。 <strong>编码</strong>主要目的是保护数据的完整性。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>JWT令牌最典型的应用场景就是登录认证：</p><ul><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成 一个jwt令牌，将生成的 jwt令牌返回给前端。 </li><li>前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服 务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接 拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处 理。</li></ul><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作： </p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><h2 id="生成和校验"><a href="#生成和校验" class="headerlink" title="生成和校验"></a>生成和校验</h2><p>首先需要映入JWT的依赖</p><pre><code class="xml">&lt;!-- JWT依赖--&gt;&lt;dependency&gt;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&lt;artifactId&gt;jjwt&lt;/artifactId&gt;&lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>生成JWT代码实现</p><pre><code class="java">@Testpublic void genJwt()&#123;Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;();claims.put(&quot;id&quot;,1);claims.put(&quot;username&quot;,&quot;Tom&quot;);String jwt = Jwts.builder() .setClaims(claims) //自定义内容(载荷) .signWith(SignatureAlgorithm.HS256, &quot;itheima&quot;) //签名算法 .setExpiration(new Date(System.currentTimeMillis() +24*3600*1000)) //有效期 .compact();//使其返回一个对象System.out.println(jwt);&#125;</code></pre><p>运行测试方法：</p><pre><code>eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk</code></pre><p>输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割，我们可以将生成的令牌复制 一下，然后打开JWT的官网，将生成的令牌直接放在Encoded位置，此时就会自动的将令牌解析出来。</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308261534117.png" alt="image-20230826153437066"></p><blockquote><p>第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。 第二个部分是我们自定义的数据，之前我们自定义的数据就是id，还有一个exp代表的是我们所设 置的过期时间。 由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编 码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。</p></blockquote><p><strong>校验JWT令牌(解析生成的令牌)：</strong></p><pre><code class="java">@Testpublic void parseJwt()&#123;Claims claims = Jwts.parser() .setSigningKey(&quot;itheima&quot;)//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥）.parseClaimsJws(&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk&quot;) .getBody();System.out.println(claims);&#125;</code></pre><p>(以上参考了黑马程序员B站教程)</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接数据库ERROR</title>
      <link href="/posts/6989f668.html"/>
      <url>/posts/6989f668.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="解决报错“Loading-class-com-mysql-jdbc-Driver’-This-is-deprecated”"><a href="#解决报错“Loading-class-com-mysql-jdbc-Driver’-This-is-deprecated”" class="headerlink" title="解决报错“Loading class &#96;com.mysql.jdbc.Driver’. This is deprecated”"></a>解决报错“Loading class &#96;com.mysql.jdbc.Driver’. This is deprecated”</h1><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308141056315.png" alt="image-20230814105654242"></p><pre><code class="yml">driver-class-name: com.mysql.jdbc.Driver</code></pre><p>在这个基础上,改为</p><pre><code class="yml">driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><p>除此之外</p><p>将url地址:</p><p>原本是<code>url: jdbc:mysql://127.0.0.1:3306/</code></p><p>改为:</p><p><code>jdbc:mysql://127.0.0.1:3306/tlias?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8</code></p><p><code>tlias</code>是数据库名</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308141059868.png" alt="image-20230814105914802"></p><p>然后就可以尝试测试,问题就可以解决啦</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/posts/dc7fb504.html"/>
      <url>/posts/dc7fb504.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="思想分析"><a href="#思想分析" class="headerlink" title="思想分析"></a>思想分析</h2><p>如果在一个类对象上方法太多,可以通过代理来减轻自己的负担,就比如黑马阿玮PPT的一张图</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308091949765.png" alt="image-20230809183336178"></p><p>对于代理如何知道对象的方法.可以让对象和代理都实现一个接口来达成目的</p><p>&#x3D;&#x3D;为什么需要代理&#x3D;&#x3D;</p><p>代理可以无侵入式的给对象增加其他的共能</p><p>调用者 -&gt; 代理 -&gt; 对象</p><p>&#x3D;&#x3D;代理长什么样&#x3D;&#x3D;</p><p>就是对象要被代理的方法</p><p>&#x3D;&#x3D;java通过什么来保证代理的样子&#x3D;&#x3D;</p><p>通过接口保证,后面的对象和代理需要实现同一个接口,接口中就是要被代理的方法</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308091949245.png" alt="image-20230809192308305"></p><pre><code class="java">// 对象和代理的接口package DaiLi;public interface Star &#123;    public abstract String sing(String name);    public abstract void dance();&#125;</code></pre><pre><code class="java">//BigStar 对象 package DaiLi;public class BigStar implements Star&#123;    String name;    public BigStar() &#123;    &#125;    public BigStar(String name) &#123;        this.name = name;    &#125;    @Override    public String sing(String name)&#123;        System.out.println(this.name + &quot;正在唱&quot; +name);        return &quot;谢谢大家&quot;;    &#125;    @Override    public void dance()&#123;        System.out.println(this.name + &quot;正在跳舞&quot;);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;BigStar&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><pre><code class="java">//创建代理package DaiLi;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyUtile&#123;    public static Star createProxy(BigStar bigStar)&#123;        Star star = (Star) Proxy.newProxyInstance(                ProxyUtile.class.getClassLoader(),                new Class[]&#123;Star.class&#125;,                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        if (&quot;sing&quot;.equals(method.getName()))&#123;                            System.out.println(&quot;准备话筒,收钱&quot;);                        &#125;else if(&quot;dance&quot;.equals(method.getName())) System.out.println(&quot;准备场地收钱&quot;);                        return method.invoke(bigStar, args);                    &#125;                &#125;        );                return star;    &#125;&#125;</code></pre><pre><code class="java">//测试类package DaiLi;public class test &#123;    public static void main(String[] args) &#123;        BigStar bigStar = new BigStar(&quot;鸡哥&quot;);        Star proxy = ProxyUtile.createProxy(bigStar);        String result = proxy.sing(&quot;只因你太美&quot;);        System.out.println(result);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除倒数第n个结点</title>
      <link href="/posts/28e1f509.html"/>
      <url>/posts/28e1f509.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>双指针,首先让快指针先走n个点.这时候和slow的距离便是从最后一个点到要删的点的距离</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个fast指针,和一个slow指针,指向dummyhead(虚头结点,便于统一操作),<br>首先让快指针先走n个点.这时候和slow的距离便是从最后一个点到要删的点的距离</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308082341781.png" alt="image-20230808234135646"></p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummyHead = new ListNode(0);        dummyHead.next = head;        ListNode fastIndex = dummyHead;        ListNode slowIndex = dummyHead;          n++; //让fast指针多走一步,从而让slow-&gt;next指向被删的点        while(n-- != 0&amp;&amp; fastIndex!=null)&#123;            fastIndex = fastIndex.next;        &#125;        while(fastIndex != null)&#123;            slowIndex = slowIndex.next;            fastIndex = fastIndex.next;        &#125;        slowIndex.next = slowIndex.next.next;        return dummyHead.next;      &#125;&#125;</code></pre><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* fast = dummyHead; // 快指针        ListNode* slow = dummyHead;        n++; //因为要操作的是slow-&gt;next,同时也为了避免fast为空指针的情况        while(n-- &amp;&amp; fast != NULL)&#123;            fast = fast-&gt;next;        &#125;        while(fast != NULL)&#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        slow-&gt;next = slow-&gt;next-&gt;next;        return dummyHead-&gt;next;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的节点</title>
      <link href="/posts/71a5c331.html"/>
      <url>/posts/71a5c331.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>定义一个虚拟头结点, 赋值给一个临时节点cur,操作后两个节点.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>比如节点0(虚拟)-&gt;1-&gt;2-&gt;3,这时候如果实现两两交换,就需要一下操作,用tmp和tmp1保存1和3节点, 然后将0-&gt;2,2-&gt;1,1-&gt;3,然后将0往后依次这样执行,直到(cur-&gt;next !&#x3D;null &amp;&amp; cur-&gt;next-&gt;next) (分奇数和偶数节点的判断),不能颠倒,避免报错空指针异常</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode dummyHead = new ListNode(0);        dummyHead.next = head;        ListNode cur = dummyHead;        while(cur.next!=null &amp;&amp; cur.next.next != null)&#123;            ListNode tmp = cur.next;            ListNode tmp1 = cur.next.next.next;            cur.next = cur.next.next;            cur.next.next = tmp;            cur.next.next.next = tmp1;            cur = cur.next.next;        &#125;        return dummyHead.next;    &#125;&#125;</code></pre><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* temp = new ListNode(0);        ListNode* cur = dummyHead;        while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr)&#123;            temp = cur-&gt;next;            ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;            cur-&gt;next = cur-&gt;next-&gt;next;            cur-&gt;next-&gt;next = temp;            cur-&gt;next-&gt;next-&gt;next = temp1;                        cur = cur-&gt;next-&gt;next;        &#125;     return dummyHead-&gt;next;//不能返回head,因为已经被改变了    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/posts/82b7a1a9.html"/>
      <url>/posts/82b7a1a9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>双指针算法,定义pre,和cur,来遍历链表.然后进行反转</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个temp记录cur-&gt;next的位置,当反转通过<code>cur-&gt;next=pre</code>来完成,<br>所以之后pre &#x3D; cur, cur&#x3D;tmep(向后移动),直到cur为空,即达到遍历完成的效果</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;        ListNode cur = head;        ListNode temp = new ListNode(0);        while(cur != null)&#123;            temp = cur.next; // 在cur.next改变之前            cur.next = pre;            pre = cur;            cur = temp;        &#125;        return pre;    &#125;&#125;</code></pre><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* cur = head;        ListNode* pre = NULL;        ListNode* temp = new ListNode(0);        while(cur)&#123;            temp = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = temp;        &#125;        return pre;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用mybatis实现查询报错解决</title>
      <link href="/posts/c2ad3d31.html"/>
      <url>/posts/c2ad3d31.html</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息“Unable-to-resolve-column-‘id’”"><a href="#报错信息“Unable-to-resolve-column-‘id’”" class="headerlink" title="报错信息“Unable to resolve column ‘id’”"></a>报错信息“Unable to resolve column ‘id’”</h2><p>​<img src="/../imgs/202308051939669.png" alt="image-20230805193945623"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li></li></ol><p><img src="/../imgs/202308051940228.png" alt="image-20230805194016190"></p><p>2.<img src="/../imgs/202308051940483.png" alt="image-20230805194036432"></p><ol start="3"><li></li></ol><p><img src="/../imgs/202308051941479.png" alt="image-20230805194105422"></p><p>4 . 更改为使用的表</p><p><img src="/../imgs/202308051941020.png" alt="image-20230805194133971"></p><p>然后报错就消失啦</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键</title>
      <link href="/posts/54a358a7.html"/>
      <url>/posts/54a358a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="主键概述"><a href="#主键概述" class="headerlink" title="主键概述"></a>主键概述</h1><p>主键值是每一行记录的唯一标识(就是类似不能重复的身份证号)</p><p><img src="/../imgs/202308051618449.png" alt="image-20230805153904522"></p><p><strong>任何一张表都应该有主键,没有主键表无效</strong>,</p><p>主键的特征: not null + unique (不能为空,且不重复)</p><p>给一张表添加主键:</p><pre><code class="mysql">create table t_vip(    id int primary key,//列级约束    name varchar(255));create table t_vip(    id int ,    name varchar(255),    primary key(id)  //表级约束);</code></pre><p><img src="/../imgs/202308051618117.png" alt="image-20230805154406943"></p><h1 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h1><p>id 和name 联合起来做主键,叫做复合主键</p><pre><code class="mysql">create table t_vip(    id int ,    name varchar(255),    primary key(id,name)  //表级约束);</code></pre><p><img src="/../imgs/202308051547340.png" alt="image-20230805154756288"></p><p>在实际开发中不建议使用复合主键</p><p>因为主键值存在的意义就是一行的唯一标识</p><h1 id="主键数量"><a href="#主键数量" class="headerlink" title="主键数量"></a>主键数量</h1><p><img src="/../imgs/202308051619294.png" alt="image-20230805154917751"></p><p>主键只能有一个,刚刚说的联合主键和这个情况不一样</p><h1 id="主键值"><a href="#主键值" class="headerlink" title="主键值"></a>主键值</h1><p>建议使用,<code>int</code> <code>bigint</code> <code>char</code> 等类型</p><p>不建议使用<code>varchar</code>来做主键.主键值一般都是数字,一般都是定长的1</p><h1 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h1><p><strong>根据主键字段的字段数量来划分：</strong><br>            单一主键（推荐的，常用的。）<br>            复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）<br>        <strong>根据主键性质来划分：</strong><br>            自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）<br>            业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）<br>                          最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要<br>                          随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。<br>    <strong>mysql提供主键值自增：</strong></p><pre><code class="mysql">drop table if exists t_user;        create table t_user(            id int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。            username varchar(255)        );        insert into t_user(username) values(&#39;a&#39;);        insert into t_user(username) values(&#39;b&#39;);        insert into t_user(username) values(&#39;c&#39;);        insert into t_user(username) values(&#39;d&#39;);        insert into t_user(username) values(&#39;e&#39;);        insert into t_user(username) values(&#39;f&#39;);        select * from t_user;        提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="/posts/c2ed89bf.html"/>
      <url>/posts/c2ed89bf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历链表,如果相等,需要删除的元素的左边节点指向删除元素的右边节点.<br>如果删除的是表头元素,为了统一,建立一个虚拟头结点</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>定义一个虚拟头结点dummyHead,和遍历需要的指针cur,进入循环,遍历链表元素,如果相等就将删除的元素的左边节点指向删除元素的右边节点.<br>如果删除的是表头元素,为了统一,建立一个虚拟头结点.直到cur-&gt;next !&#x3D; null.因为cur &#x3D;&#x3D; dummyHead. 实际上我们操作的也一直是cur-&gt;next;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeElements(ListNode head, int val) &#123;        ListNode dummyHead  = new ListNode();        dummyHead.next = head;        ListNode cur = dummyHead;        while(cur.next != null)&#123;            if(cur.next.val == val)&#123;                cur.next = cur.next.next;            &#125;            else&#123;                cur = cur.next;            &#125;        &#125;        return dummyHead.next;    &#125;&#125;</code></pre><h1 id="Code-C"><a href="#Code-C" class="headerlink" title="Code(C++)"></a>Code(C++)</h1><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;      ListNode* dummyHead = new ListNode(0);      dummyHead-&gt;next = head; //这里要从虚节点的下一个操作      ListNode* cur = dummyHead;      while(cur-&gt;next != NULL)&#123;          if(cur-&gt;next-&gt;val == val)&#123;// 操作的永远是 cur-&gt;next              ListNode* tmp = cur-&gt;next; // 操作的永远是 cur-&gt;next              cur-&gt;next = cur-&gt;next-&gt;next;              delete tmp;          &#125;else&#123;              cur = cur-&gt;next;          &#125;      &#125;      head = dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵||</title>
      <link href="/posts/7ff36c5c.html"/>
      <url>/posts/7ff36c5c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>本体采用循环不变量,对于判断每次螺旋的边界麻烦,不妨都采取左闭又开的原则</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>第一个不太好理解的地方就是为什么循环n&#x2F;2圈?是因为最后循环结束的时候StartX一定是在相对于第一条边中间的位置,那么循环了多少圈就可以由这个点对两边的竖边的条数进行分割.两边的条数一定是相等的,有就是转了多少圈.<br>第二个地方就是左开右闭,每到一个节点就进入下一个边的循环.<br>在每个圈数结束后,更新起点,横纵坐标都加一.startX+1;startY+1</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $n(2)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">class Solution &#123;    public int[][] generateMatrix(int n) &#123;        int loop = 0; // 控制循环次数        int [][] res = new int[n][n];        int start = 0; //每次循环的开始点(start, start)        int count = 1; //定义填充数字        int i,j;        while(loop ++ &lt; n/2)&#123;//判断边界后,loop从1开始        //模拟上侧从左到右        for(j = start; j&lt;n-loop; j++)&#123;// n-loop 是为了左闭又开            res[start][j] = count++;        &#125;        //模拟右侧从上到下        for(i = start; i &lt; n-loop; i++)&#123;            res[i][j] = count++;        &#125;                for(;j&gt;=loop;j--)&#123;//此时loop等于一,startX+1的位置            res[i][j] = count++;        &#125;        // 模拟从下到上        for(;i&gt;=loop;i--)&#123; //此时loop等于一,startY+1的位置            res[i][j] = count++;        &#125;        start++;        &#125;        if(n%2 == 1)&#123;            res[start][start] = count;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot初学相关配置问题</title>
      <link href="/posts/1bb4388d.html"/>
      <url>/posts/1bb4388d.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot初学相关配置问题"><a href="#SpringBoot初学相关配置问题" class="headerlink" title="SpringBoot初学相关配置问题"></a>SpringBoot初学相关配置问题</h1><p>如果下了多个JDK版本要对应</p><p><img src="/../imgs/image-20230802223518620-16912480524331.png" alt="image-20230802223518620"></p><p><img src="/../imgs/image-20230802223544161-16912480560582.png" alt="image-20230802223544161"></p><p><img src="/../imgs/image-20230802223559402-16912480586283.png" alt="image-20230802223559402"></p><p><img src="/../imgs/image-20230802223615199-16912480613534.png" alt="image-20230802223615199"></p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven配置相关问题</title>
      <link href="/posts/cfbe3ed9.html"/>
      <url>/posts/cfbe3ed9.html</url>
      
        <content type="html"><![CDATA[<h3 id="解决-Unresolved-plugin-‘org-apache-maven-plugins-maven-clean-plugin-2-5’-问题"><a href="#解决-Unresolved-plugin-‘org-apache-maven-plugins-maven-clean-plugin-2-5’-问题" class="headerlink" title="解决 (Unresolved plugin: ‘org.apache.maven.plugins:maven-clean-plugin:2.5’)问题"></a>解决 (Unresolved plugin: ‘org.apache.maven.plugins:maven-clean-plugin:2.5’)问题</h3><p>首先要先下载maven相关包,遇到这种问题一般是在创建maven项目之后,</p><p>这时候先看settings中maven ,其中相关路径以及经典配置</p><p>如果仍出现这种problems,</p><p>可以看maven配置的 Local respository下面的对钩有没有勾上,勾上之后重新加载就可以解决问题啦</p><p><img src="/../imgs/image-20230801212737931.png" alt="image-20230801212737931"></p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/posts/50cab45.html"/>
      <url>/posts/50cab45.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先是暴力,通过两层for循环遍历所有情况,取最小;<br>然后就是滑动窗口, 因为本体取的是子数组, 就不能出现跨越的情况.通过滑动窗口来优化</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>首先定义一个滑动窗口的右端点, 然后计算sum , 如果满足条件, 就将左端点往右移动,直到sum &lt; target, 然后继续往右挪动右端点. 不断更新最小值result;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(n) 暴力 O(n^2)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><pre><code class="Java">class Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;        int result = Integer.MAX_VALUE;        int sum = 0;        for(int st = 0; st &lt; nums.length; st++)&#123;            sum = 0;            for(int l = st; l &lt; nums.length; l++)&#123;                sum += nums[l];                if(sum &gt;= target)&#123;                    int len = l - st + 1;                    result = Math.min(len, result);                    break;                &#125;            &#125;        &#125;         // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列        return result == Integer.MAX_VALUE ? 0 : result;    &#125;&#125;</code></pre><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><pre><code class="Java">class Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;        int result = Integer.MAX_VALUE;        int sum = 0;        int st = 0;        int len = 0;        for(int la = 0; la &lt; nums.length; la++)&#123; // 遍历终止点            sum += nums[la];            while(sum &gt;= target)&#123; //满足条件就一直通过左端点往右移动                len = la - st + 1; //取子序列的长度                //result = Math.min(len, result);                result = result &lt; len ? result : len;                sum -= nums[st++];            &#125;        &#125;        return result == Integer.MAX_VALUE ? 0 :result;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/posts/3a42db2d.html"/>
      <url>/posts/3a42db2d.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="1-vue语法初探"><a href="#1-vue语法初探" class="headerlink" title="1.vue语法初探"></a>1.vue语法初探</h2><h3 id="1-1-HelloWord"><a href="#1-1-HelloWord" class="headerlink" title="1.1 HelloWord"></a>1.1 HelloWord</h3><pre><code class="Vue">    &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script&gt;    // 从面向dom编程到面向数据编程    Vue.createApp(&#123;    data()&#123;    return &#123;    content: 1    &#125;    &#125;,    // 当页面加载完成,会自动调用mounted    mounted() &#123;    setInterval( ()=&gt;&#123;    this.content++    &#125;,1000)    &#125;,    template: `&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;`    &#125;).mount(&#39;#root&#39;)    &lt;/script&gt;     &lt;/body&gt;</code></pre><p>这里要引用<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></p><p>&#x3D;&#x3D;要慢慢将思维由面向dom到面向数据&#x3D;&#x3D;</p><h3 id="1-2-反转和隐藏"><a href="#1-2-反转和隐藏" class="headerlink" title="1.2 反转和隐藏"></a>1.2 反转和隐藏</h3><pre><code class="Vue">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script&gt;    // 从面向dom编程到面向数据编程    Vue.createApp(&#123;    data()&#123;    return &#123;    content: &#39;helloworld&#39;    &#125;    &#125;,    methods:&#123;    handClick()&#123;    this.content  = this.content.split(&#39;&#39;).reverse().join(&#39;&#39;)    &#125;    &#125;,    // 绑定反转函数,实习写在methods里面    template: `    &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;    &lt;button @click = &quot;handClick&quot;&gt;反转&lt;/button&gt;    `     &#125;).mount(&#39;#root&#39;)    &lt;/script&gt;     &lt;/body&gt;</code></pre><pre><code class="Vue">    &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script&gt;    // 从面向dom编程到面向数据编程    Vue.createApp(&#123;    data()&#123;    return &#123;    show: true    &#125;    &#125;,    methods:&#123;    handClick()&#123;    // 面向数据编程,改变数据的值    this.show = !this.show    &#125;    &#125;,    template: `    &lt;span v-if = &quot;show&quot;&gt;hello&lt;/span&gt;    &lt;button @click = &quot;handClick&quot;&gt;隐藏/出现&lt;/button&gt;    `     &#125;).mount(&#39;#root&#39;)    &lt;/script&gt;     &lt;/body&gt;</code></pre><h3 id="1-3-todolist"><a href="#1-3-todolist" class="headerlink" title="1.3 todolist"></a>1.3 todolist</h3><pre><code class="Vue">    &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script&gt;    // 从面向dom编程到面向数据编程    Vue.createApp(&#123;    data()&#123;    return &#123;    list: [],    inputValue: &#39;&#39;    &#125;    &#125;,    methods:&#123;    handClick()&#123;    this.list.push(this.inputValue)        inputValue = &#39;&#39;    &#125;    &#125;,    template: `    &lt;input v-model = &quot;inputValue&quot;&gt;    &lt;button @click = &quot;handClick&quot;&gt;增加&lt;/button&gt;    &lt;ul&gt;    &lt;li v-for = &quot;(item,index) of list&quot;&gt;&#123;&#123;item&#125;&#125; &#123;&#123;index&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    `     &#125;).mount(&#39;#root&#39;)    &lt;/script&gt;     &lt;/body&gt;</code></pre><p>index ,是item遍历的索引</p><p><code>&lt;button @click = &quot;handClick&quot; title = &quot;222&quot;&gt;增加&lt;/button&gt;</code></p><p>这样不对,如果title要和数据绑定,需要使用v-bind指令 :title&#x3D;   </p><h3 id="1-4-组件概念初探"><a href="#1-4-组件概念初探" class="headerlink" title="1,4 组件概念初探"></a>1,4 组件概念初探</h3><p>如果<code>.mount(&#39;#root&#39;)</code>挂载了组件之后再去<code>qpp.component()</code>去创建组件就来不及了</p><p>展示组件:定义完组件之后再去挂载<code>app.mount(&#39;#root&#39;)</code></p><pre><code class="vue">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script&gt;    // 从面向dom编程到面向数据编程    const app = Vue.createApp(&#123;    data()&#123;    return &#123;    list: [],    inputValue: &#39;&#39;    &#125;    &#125;,    methods:&#123;    handClick()&#123;    this.list.push(this.inputValue)    &#125;    &#125;,    template: `    &lt;input v-model = &quot;inputValue&quot;&gt;    &lt;button @click = &quot;handClick&quot;&gt;增加&lt;/button&gt;    &lt;ul&gt;    &lt;todo-item v-for = &quot;(item, index) of list&quot;    :content = &quot;item&quot;    :index = &quot;index&quot;    &gt;&lt;/todo-item&gt;    &lt;/ul&gt;    `     &#125;);    app.component(&#39;todo-item&#39;, &#123;    props: [&#39;content&#39;, &#39;index&#39;],    template: &#39;&lt;div&gt;&#123;&#123;content&#125;&#125;----&#123;&#123;index&#125;&#125;&lt;/div&gt;&#39;    &#125;)    app.mount(&#39;#root&#39;)    &lt;/script&gt;     &lt;/body&gt;</code></pre><p>在这里,将li标签的属性通过组件化展示出来,:index :content分别绑定两个变量, 在组件中,由<code>props:[绑定值1,绑定值2...]</code>去接收</p><h2 id="2-Vue基础语法"><a href="#2-Vue基础语法" class="headerlink" title="2. Vue基础语法"></a>2. Vue基础语法</h2><h3 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h3><p>获取数据要用<code>vm.$data.xxx</code></p><p>createApp 表示创建一个Vue应用, 存储到app变量中, 传入的参数表示,这个应用最外层的组件应该如何展示</p><p>&#x3D;&#x3D;mvvm&#x3D;&#x3D;模式, m-&gt;model 数据 v-&gt;view 视图 vm -&gt; viewModel视图数据连接层</p><p>这也是为什么 const vm &#x3D; app.mount(‘#root’) vm代表的就是Vue的根组件</p><h3 id="2-2-生命周期函数"><a href="#2-2-生命周期函数" class="headerlink" title="2.2 生命周期函数"></a>2.2 生命周期函数</h3><p><strong>在某一时刻会自动执行的函数</strong></p><p>比如之前的 mounted(){}</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550391.png" alt="image-20230730205903567"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550672.png" alt="image-20230730210033959"></p><p>图里面的判断意思是. 如果没有template 就去root挂载的根节点去找innerHtml结构</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550645.png" alt="image-20230730210226446"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550175.png" alt="image-20230730210418348"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031550137.png" alt="image-20230730210503916"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551822.png" alt="image-20230730210625949"></p><p><code>beforeUpdate</code>是在数据改变(页面还没有渲染时调用)</p><p><code>updated</code>是在页面重新渲染完之后调用,注意二者区别!</p><p><code>beforeUnmount</code>当Vue应用失效时,自动执行的函数</p><p><code>unmounted</code> 当Vue应用失效时,且dom完全销毁之后,自动执行的函数</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551739.png" alt="image-20230730211407402"></p><h3 id="2-3-常用模版语法"><a href="#2-3-常用模版语法" class="headerlink" title="2.3 常用模版语法"></a>2.3 常用模版语法</h3><p>template: <code>&lt;div v-html = &quot;message&quot;&lt;/div&gt;</code></p><p>避免转义</p><p>v-bind:(属性或变量) &#x3D; …  与data中的数据绑定 , 不知道起什么名可以**:[data中的属性名]**</p><p>template: <code>&lt;div v-html = &quot;message&quot;&gt;&#123;&#123;在这里面可以写类似于Max(,)这样的js表达式&#125;&#125;&lt;/div&gt;</code>但是如果是if(){}就不行,这是js语句,不是表达式</p><p> <code>&lt;div v-once&gt;&#123;&#123;m&#125;&#125;&lt;/div&gt; </code>只显示一次,当m再变化,页面渲染</p><p><code>v-if = &#39;show&#39;</code>  show是data:{} 中的bool</p><p>v-on  点击绑定</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551231.png" alt="image-20230731214451194"></p><p>@[event] , 而event可以在data中 event: ‘click’ &#x2F;‘ mouseenter’ 绑定其他事件</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031551123.png" alt="image-20230731215311197"></p><p>阻止默认行为  @click.prevent &#x3D; “函数名”</p><h3 id="2-4-数据-方法-计算属性-侦听器"><a href="#2-4-数据-方法-计算属性-侦听器" class="headerlink" title="2.4 数据,方法,计算属性,侦听器"></a>2.4 数据,方法,计算属性,侦听器</h3><pre><code class="vue">   methods:&#123;     formatString(string)&#123;       return string.toUpperCase();     &#125;   &#125;,   template: `&lt;div&gt;&#123;&#123;formatString(message)&#125;&#125;&lt;/div&gt;` &#125;).mount(&#39;#root&#39;)</code></pre><pre><code class="Vue"> &lt;script&gt;   const vm = Vue.createApp(&#123;     data()&#123;       return &#123;         message: &#39;hello world&#39;,         count: 2,         price: 5       &#125;     &#125;,     computed:&#123;       // 当计算属性依赖的内容发生改变,才会重新执行计算       total()&#123;         // 注意计算属性别漏了this         // return this.count * this.price;        &#125;     &#125;,     methods:&#123;       formatString(string)&#123;         return string.toUpperCase();       &#125;,       // 只要页面重新渲染,就会重新计算                Date.now();         // return this.count * this.price;        &#125;     &#125;,     template: `&lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;`   &#125;).mount(&#39;#root&#39;) &lt;/script&gt; </code></pre><p> total()(在computed中)</p><p>   &#x2F;当计算属性依赖的内容发生改变,才会重新执行计算<br>getTotal()(在函数方法中)</p><p> 只要页面重新渲染,就会重新计算</p><p><strong>侦听器</strong></p><p>如果想数据改变隔五秒打印一些东西,用computed肯定是不行的,这是后就需要加一个watch侦听器</p><pre><code class="Vue">&lt;script&gt;  const vm = Vue.createApp(&#123;    data()&#123;      return &#123;        message: &#39;hello world&#39;,        count: 2,        price: 5      &#125;    &#125;,    computed:&#123;      // 当计算属性依赖的内容发生改变,才会重新执行计算      total()&#123;        // 注意计算属性别漏了this         return this.count * this.price;       &#125;    &#125;,    watch: &#123;      price()&#123;        setTimeout(() =&gt; &#123;          console.log(&#39;price changed&#39;)        &#125;,3000)      &#125;    &#125;,    methods:&#123;      formatString(string)&#123;        return string.toUpperCase();      &#125;,      // 只要页面重新渲染,就会重新计算      getTotal()&#123;        Date.now();        // return this.count * this.price;       &#125;    &#125;,    template: `&lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;`  &#125;).mount(&#39;#root&#39;)</code></pre><p><strong>computed 和 method 都能实现的一个功能,建议使用computed,因为有缓存, computed 和 watcher 都能实现的功能,建议使用computed,因为更加简洁. watched 也可以监听price改变,然后对页面重新与安然,但是麻烦,不如computed</strong></p><p>异步可以在watch 里面, 但同步不如在computed里面更简洁</p><h3 id="2-5-样式绑定语法"><a href="#2-5-样式绑定语法" class="headerlink" title="2.5.样式绑定语法"></a>2.5.样式绑定语法</h3><pre><code class="Vue"> &lt;script&gt;   const app = Vue.createApp(&#123;     data()&#123;       return&#123;         classString: &#39;red&#39;       &#125;     &#125;,     template: `&lt;div :class = &#39;classString&#39;&gt; hello&lt;/div&gt;`   &#125;)   const vm =  app.mount(&#39;#root&#39;)</code></pre><p>通过字符串绑定来改变style样式</p><p><img src="/../imgs/image-20230802133154875.png" alt="image-20230802133154875"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552596.png" alt="image-20230802135424710"></p><p>添加子组件</p><pre><code class="Vue">&lt;script&gt;  const app = Vue.createApp(&#123;    data()&#123;      return&#123;        classString: &#39;red&#39;      &#125;    &#125;,    template: `&lt;div :class = &#39;classString&#39;&gt; hello      &lt;demo /&gt;      &lt;/div&gt;`  &#125;)  // 创建组件  app.component(&#39;demo&#39;, &#123;    template: &#39; &lt;div class = &quot;green&quot; &gt; single &lt;/div&gt;&#39;  &#125;)  const vm =  app.mount(&#39;#root&#39;)&lt;/script&gt; </code></pre><p>如果子组件有两个div. 当把class加到父组件demo中时,可以控制显示哪个div:</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552559.png" alt="image-20230802140326043"></p><p><strong>通过style的方式写样式:</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552543.png" alt="image-20230802140537613"></p><p>这里简写写styleObject 可读性更强</p><h3 id="2-6-条件渲染"><a href="#2-6-条件渲染" class="headerlink" title="2.6 条件渲染"></a>2.6 条件渲染</h3><pre><code class="Vue"> &lt;script&gt;   const app = Vue.createApp(&#123;     data()&#123;       return&#123;         show : false       &#125;     &#125;,     template: `       &lt;div v-if = &#39;show&#39;&gt; hello&lt;/div&gt;       &lt;div v-show = &#39;show&#39;&gt; hello&lt;/div&gt;     `   &#125;);   const vm =  app.mount(&#39;#root&#39;) &lt;/script&gt; </code></pre><p>v-if 是直接在DOM上添加或者删除,而v-show值通过冬至<code>display:none属性</code>来控制是否显示</p><p>如果频繁改变的话还是建议使用v-show</p><p>除此之外,在vue中还可以使用if else if else逻辑</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552914.png" alt="image-20230802141746575"></p><p>表示如果<code>conditionOne</code> 是True的话就展示<code>if</code>,如果不是,就看<code>conditionTwo</code>是true的话就显示<code>else if</code>, 否则就展示<code>else</code></p><h3 id="2-7-列表渲染"><a href="#2-7-列表渲染" class="headerlink" title="2.7 列表渲染"></a>2.7 列表渲染</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>可以对list 循环,也可以对对象循环:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031552486.png" alt="image-20230802144335089"></p><p>这里的value 代表对应的变量值, key代表<code>firstname</code>这些等等</p><p>index是索引, 从0开始往后一次增加 </p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553397.png" alt="image-20230802144744201"></p><p><strong>循环的时候尽量使用key值,避免重复渲染带来的性能问题</strong></p><h4 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h4><p> <img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553233.png" alt="image-20230802144910942"></p><p>实现页面的添加和删除</p><p>pop索引大的开始删,shift从小的开始删除,unshift会忘头部(索引开头)添加东西</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/202308031540064.png" alt="image-20230802145058175"></p><p><code>reverse</code>可以变更顺序</p><p><strong>2-直接替换数组</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553962.png" alt="image-20230802145323072"></p><h4 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553459.png" alt="image-20230802145551010"></p><p>在老版本的vue中出直接修改对象里面的内容可能会有一定的问题</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553828.png" alt="image-20230802145822932"></p><p>这个是实现不展示lastName,但是要注意 <strong>循环和判断不要写在一个标签上,循环的优先级会更高,如果要筛序性展示,则新创建一个div标签,来选择是否展示</strong>  </p><p>为了避免每一层多一个div标签</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031553409.png" alt="image-20230802150211640"></p><p>这列<code>template</code> 知识占位符,并不会影响渲染效果</p><h3 id="2-8-事件绑定"><a href="#2-8-事件绑定" class="headerlink" title="2.8 事件绑定"></a>2.8 事件绑定</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554966.png" alt="image-20230802161607518"></p><p>如果要传参,且还要原生的event事件,就可以在event前面加一个$传递过去</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554472.png" alt="image-20230802161831118"></p><p>如果要使用多个函数,就不能只写函数名了,要加上括号</p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>stop:避免冒泡</p><p><code>@click.stop = &quot;方法&quot;</code></p><p>.self 只有点自己才会执行,点子标签里面的其他元素则不会执行</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554812.png" alt="image-20230802162356544"></p><p>.prevent组织默认行为</p><p>.capture 捕获</p><p>once 只执行一次,再点击就不会执行</p><p>@scroll.passive</p><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554363.png" alt="image-20230802162853911"></p><p>exact是只按ctrl这个键再点击执行的,精确执行</p><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p><strong>v-model</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554224.png" alt="image-20230802163233015"></p><p>输入框的值变,页面渲染的值跟着改变</p><p><strong>textarea</strong></p><p>​<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554954.png" alt="image-20230802163655598"></p><p>checkbox:<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554461.png" alt="image-20230802163733528"></p><p> false跟着点击 变成true再变回来</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031554729.png" alt="image-20230802171339552"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555260.png" alt="image-20230802163853755"></p><p>自定义值取代false True</p><p>多个checkbox会往数组里面存Value</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555383.png" alt="image-20230802164001558"></p><p><strong>radio</strong></p><p>是单选,不能都放到数组中</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555570.png" alt="image-20230802163946958"></p><p>初始值要变成字符串,选谁变成谁</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555611.png" alt="image-20230802164057819"></p><p><strong>select</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555088.png" alt="image-20230802164357563"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555997.png" alt="image-20230802164204475"></p><p><strong>加上multiple变成多选</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555900.png" alt="image-20230802164631503"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555807.png" alt="image-20230802164650502"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031555841.png" alt="image-20230802164838310"></p><p>最终存储会将value里面的对象作为存储的值</p><p>帮助我吗做项目临时转化</p><h4 id="表单中双向绑定的使用"><a href="#表单中双向绑定的使用" class="headerlink" title="表单中双向绑定的使用"></a>表单中双向绑定的使用</h4><p>lazy</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556984.png" alt="image-20230802171443748"></p><p>当失去焦点的时候渲染页面展示的值,跟v-model不一样的地方在于不实时渲染</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556604.png" alt="image-20230802171603688"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556448.png" alt="image-20230802171623240"></p><p>输入内容的时候由String变成number</p><p><strong>trim</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031549888.png" alt="image-20230802171807151"></p><p>只去除字符串前后字符,中间的不会去除</p><h2 id="3-探索组件的概念"><a href="#3-探索组件的概念" class="headerlink" title="3.探索组件的概念"></a>3.探索组件的概念</h2><h3 id="3-1-组件的定义及复用性"><a href="#3-1-组件的定义及复用性" class="headerlink" title="3.1 组件的定义及复用性"></a>3.1 组件的定义及复用性</h3><p> <img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031556849.png" alt="image-20230803152607203"></p><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;script&gt;    const app = Vue.createApp(&#123;      template: `&lt;div&gt;&lt;hello /&gt;&lt;world /&gt;&lt;/div&gt;`,    &#125;)    app.component(&#39;hello&#39;, &#123;      template: `&lt;div&gt;hello&lt;/div&gt;`    &#125;)    app.component(&#39;world&#39;, &#123;    template: `&lt;div&gt;world&lt;/div&gt;`    &#125;)        const vm =  app.mount(&#39;#root&#39;)  &lt;/script&gt; &lt;/body&gt;</code></pre><p>组件可以被复用,但不会和其他组件共享</p><p>独享</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031616842.png" alt="image-20230803161654775"></p><p>app.component定义的组件是全局的,不仅在父组件可以用,在其他的组件里也可以用,</p><p>就算不用组件,但仍会挂载到app上,影响性能,使用简单</p><h3 id="3-2-局部组件"><a href="#3-2-局部组件" class="headerlink" title="3.2 局部组件"></a>3.2 局部组件</h3><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;script&gt;  const hello = &#123;    template: `&lt;div&gt;hello&lt;/div&gt;`  &#125;  const counter = &#123;   data()&#123;     return&#123;       count: 1     &#125;   &#125;,   template:   `&lt;div @click = &quot;count += 1&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;` &#125;    const app = Vue.createApp(&#123;      components: &#123;&#39;counter&#39;: counter,                  &#39;hello&#39;:hello                   &#125;,  // counter ES6      template: `&lt;div&gt;&lt;counter /&gt;&lt;hello /&gt;&lt;/div&gt;`,    &#125;)    const vm = app.mount(&#39;#root&#39;)  &lt;/script&gt; &lt;/body&gt;</code></pre><p>全局组件建议小写字母单词,中间横线连接</p><p>一般将局部组件首字母大写,驼峰命名法: HelloWorld;</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031632348.png" alt="image-20230803163246287"></p><p>可以略写X部分,系统会自动映射,只把组件名写上去也可以</p><p>局部组件:定义了.要注册之后才能使用,性能比较高,使用起来有些麻烦</p><p>局部组件使用时,要做一个名字和组件间的映射印象</p><h3 id="3-3-组件间传值及传值校验"><a href="#3-3-组件间传值及传值校验" class="headerlink" title="3.3 组件间传值及传值校验"></a>3.3 组件间传值及传值校验</h3><p><code>props:[]</code></p><p><strong>动态传参</strong></p><pre><code class="vue">&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;script&gt;    const app = Vue.createApp(&#123;      data()&#123;        return &#123;num:132&#125;      &#125;,      template: `&lt;div&gt;&lt;test :content = &quot;num&quot;/&gt;&lt;/div&gt;`    &#125;)        app.component(&#39;test&#39;,&#123;      props: [&#39;content&#39;],      template:`        &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;      `    &#125;)    const vm =  app.mount(&#39;#root&#39;)  &lt;/script&gt; &lt;/body&gt;</code></pre><p>通过父组件中的content与data中的num绑定,来实现动态的传参</p><pre><code class="vue"> app.component(&#39;test&#39;,&#123;   props: &#123;     content: String   &#125;,</code></pre><p>意思是需要传递字符串进来,其他类型会警告</p><p><strong>函数传递</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031731183.png" alt="image-20230803173120103"></p><p>​<strong>其他的参数:</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031732207.png" alt="image-20230803173247168"></p><p>required:需要传值但是没传</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031734583.png" alt="image-20230803173412544"></p><p>default可以是数,也可以是函数,代表不传参的时候显示什么</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308031735607.png" alt="image-20230803173525564"></p><p>需要&lt;1000, &gt;1000会警告</p><h3 id="3-4-单项数据流的理解"><a href="#3-4-单项数据流的理解" class="headerlink" title="3.4 单项数据流的理解"></a>3.4 单项数据流的理解</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032131494.png" alt="image-20230803213149393"></p><p>这样写太麻烦,可以通过对象来简化</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032135225.png" alt="image-20230803213528186"></p><p><code>v-bind = “params”</code>等价于 :content &#x3D; “params.content”依次往后</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032138022.png" alt="image-20230803213821963"></p><p>父组件里面用“-” ,子组件要用驼峰来接收</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032140887.png" alt="image-20230803214049744"></p><p>这样写会报错</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032143297.png" alt="image-20230803214321237"></p><p>可以这样写,复制一份数组再修改</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308032144072.png" alt="image-20230803214434014"></p><p>如果子组件改父组件里面的数据,那么其他接收data中的数据也会改变,应该避免数据间的耦合.避免以后潜在的bug</p><h3 id="3-5-Non-Props属性"><a href="#3-5-Non-Props属性" class="headerlink" title="3.5 Non-Props属性"></a>3.5 Non-Props属性</h3><p>​父组件像子组件传值的时候,这些不用的属性该怎么用<img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042035421.png" alt="image-20230804203533322">如果接收参数,那么就会如图所示等价</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042038978.png" alt="image-20230804203806926"></p><p>加上这个,就不会添加msg属性值了</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042040385.png" alt="image-20230804204033308"></p><p><code>$attrs</code>的意思是父组件传的所有值都可以放到这个标签上来</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042041031.png" alt="image-20230804204148993"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042042054.png" alt="image-20230804204230991"></p><h3 id="3-6-父子组件通过事件通信"><a href="#3-6-父子组件通过事件通信" class="headerlink" title="3.6 父子组件通过事件通信"></a>3.6 父子组件通过事件通信</h3><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042050874.png" alt="image-20230804205040790"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042051498.png" alt="image-20230804205117437"></p><p><strong>v-model简化操作</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042101724.png" alt="image-20230804210143645"></p><p>这里的modelValue都是固定的,怒等改编成其他的值</p><p>但如果叫其他值,可以按下面的来写</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308042102990.png" alt="image-20230804210239629"></p><h3 id="3-7-插槽"><a href="#3-7-插槽" class="headerlink" title="3.7 插槽"></a>3.7 插槽</h3><p>如果传递dom或者标签元素时,用props是非常麻烦,这时候就可以采用插槽</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051245440.png" alt="image-20230805124502379"></p><p>如果父组件想给子组件传递dom元素或者节点时,可以通过插槽来完成</p><pre><code class="Vue">&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;script&gt;    const app = Vue.createApp(&#123;            template: `&lt;myform&gt;         &lt;div&gt;提交&lt;/div&gt;        &lt;/myform&gt;        &lt;myform&gt;          &lt;button&gt;提交&lt;/button&gt;        &lt;/myform&gt;        `,    &#125;)    app.component(&#39;myform&#39;,&#123;      methods:&#123;        handleClick()&#123;          alert(123)        &#125;      &#125;,      template:`      &lt;div&gt;        &lt;input /&gt;        &lt;span @click = &quot;handleClick&quot;&gt;          &lt;slot&gt;&lt;/slot&gt;         &lt;/span&gt;        &lt;/div&gt;      `    &#125;)    const vm = app.mount(&#39;#root&#39;)</code></pre><p>但slot不能绑定事件,如果要绑定事件,可以写在被绑定事件的span标签里面</p><ul><li>slot插槽</li><li>slot 中使用的数据,作用域的问题</li><li>父模版里调用的数据属性, 使用的都是父模版里面的数据</li><li>子模版里调用的数据属性,使用的都是子模版里面的数据</li></ul><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051251218.png" alt="image-20230805125142156"></p><p>如果slot没有接收到元素,会使用中间的默认元素</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051255773.png" alt="image-20230805125547696"></p><p>template是占位符</p><p><strong>给slot命名</strong></p><pre><code class="vUE"> &lt;script&gt;   const app = Vue.createApp(&#123;          template: `     &lt;myform&gt;       &lt;template v-slot:header&gt;        &lt;div&gt;提交1&lt;/div&gt;       &lt;/template&gt;       &lt;template v-slot:footer&gt;         &lt;button&gt;提交2&lt;/button&gt;       &lt;/template&gt;     &lt;/myform&gt;       `,   &#125;)   app.component(&#39;myform&#39;,&#123;     methods:&#123;       handleClick()&#123;         alert(123)       &#125;     &#125;,     template:`     &lt;div&gt;       &lt;span @click = &quot;handleClick&quot;&gt;         &lt;slot name = &quot;footer&quot;&gt;&lt;/slot&gt;          &lt;slot name = &quot;header&quot;&gt;&lt;/slot&gt;        &lt;/span&gt;       &lt;/div&gt;     `   &#125;)   const vm = app.mount(&#39;#root&#39;) &lt;/script&gt; </code></pre><p><strong>作用域插槽</strong></p><p>父组件使用子组件里面的数据</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308051339916.png" alt="image-20230805133945833"></p><h3 id="3-8-动态组件和异步组件"><a href="#3-8-动态组件和异步组件" class="headerlink" title="3.8 动态组件和异步组件"></a>3.8 动态组件和异步组件</h3><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>两个组件,实现:点一个组件,另一个组件小时.反之亦然</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061312887.png" alt="image-20230806130836900"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061312268.png" alt="image-20230806131217319"></p><h4 id="异步组件-用得少"><a href="#异步组件-用得少" class="headerlink" title="异步组件(用得少)"></a>异步组件(用得少)</h4><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061316337.png" alt="image-20230806131626259"></p><ul><li>根据数据的变化,结合component这个标签, 来随时动态切换组件的现实</li><li>异步组件:是异步执行某些组件的逻辑,这叫做异步组件</li></ul><h3 id="3-9-基础语法知识点查缺补漏"><a href="#3-9-基础语法知识点查缺补漏" class="headerlink" title="3.9 基础语法知识点查缺补漏"></a>3.9 基础语法知识点查缺补漏</h3><p><strong>v-once</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061501613.png" alt="image-20230806150110546"></p><p><strong>ref</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061505195.png" alt="image-20230806150502129"></p><p><strong>provide &#x2F; inject</strong></p><p>解决多层值的传递</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308061509364.png" alt="image-20230806150918260"></p><h2 id="4-动画"><a href="#4-动画" class="headerlink" title="4. 动画"></a>4. 动画</h2><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><p> 一个简单的动画形式</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071647566.png" alt="image-20230807164657444"></p><p>用Vue来控制</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071648045.png" alt="image-20230807164817981"></p><p><strong>过渡效果</strong></p><p>背景切换的一个操作</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071651110.png" alt="image-20230807165144060"></p><p>transition表示背景切换,3s缓慢变动</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071653304.png" alt="image-20230807165347203"></p><p><strong>带点Vue特色来实现</strong></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071659956.png" alt="image-20230807165929874"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071701963.png" alt="image-20230807170129879"></p><p>其实和原生js并没有太大区别,只是从面向dom到面向数据</p><h4 id="使用单元素组件实现过渡"><a href="#使用单元素组件实现过渡" class="headerlink" title="使用单元素组件实现过渡"></a>使用单元素组件实现过渡</h4><p>使用transition标签来实现入场和出场动画</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071709596.png" alt="image-20230807170928536"></p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071713080.png" alt="image-20230807171307031"></p><p>对v-重命名</p><p><img src="https://gitee.com/coderlyj916/picture/raw/master/img/202308071715562.png" alt="image-20230807171531515"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方</title>
      <link href="/posts/838a73b0.html"/>
      <url>/posts/838a73b0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先这道题可以直接用暴力,for循环.加一个函数方法sort<br>但会提高实践复杂度,用双指针会优化</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>因为非递减数组,在两边的平方要么是最大,要么是最小,一定是在两边,所以这时候可以用双指针,在数组两边定义两个指针,当左边的平方小于右边的平方,就往一个新数组放,放在最大索引处,然后左边++,同理,右边–.直到左边小于右边</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: <blockquote><p>$O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><pre><code class="Java">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        int[] res = nums;        for(int i = 0 ; i &lt; nums.length; i++)&#123;            res[i] *= nums[i];        &#125;                           Arrays.sort(res) ;//如果递减就  Arrays.sort(a, Collections.reverseOrder());        return res;    &#125;  &#125;</code></pre><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre><code class="Java">class Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        int []res = new int[nums.length]; //递增存到新数组中        int k = nums.length-1; //新数组的索引                for(int l = 0, r = nums.length-1; l &lt;= r; )&#123;            if(nums[l]*nums[l] &lt;= nums[r]*nums[r]) &#123;                 res[k--] = nums[r]*nums[r];                 r --;            &#125;                           else&#123;                res[k--] = nums[l]*nums[l];                l++;            &#125;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/posts/c6873e6d.html"/>
      <url>/posts/c6873e6d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先可以用暴力,两层for循环.但O(n^2)<br>快慢双指针:通过两个指针,来对数组进行处理</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>首先定义一个慢指针si,然后再循环中定义一个快指针fi,然后通过判断fi和val1是否相等,如果相等,说明这个值要被覆盖,所以慢指针停止,快指针向后,直到快指针和对应的val2不相等,就可一将这个值覆盖到val1的位置上,然后将<code>si++</code>,直到遍历完整个数组</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>$O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">class Solution &#123;    public int removeElement(int[] nums, int val) &#123;        // 定义快指针和慢指针        int si = 0; //慢指针,快指针因为要不断更新,所以要在for中        for(int fi = 0; fi &lt; nums.length; fi++)&#123;            if(nums[fi] != val)&#123; //慢指针更新的条件                nums[si++] = nums[fi]; // 将符合条件的元素往不符合条件的元素覆盖            &#125;        &#125;        return si;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/posts/472eec12.html"/>
      <url>/posts/472eec12.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-二分-一-date-2023-07-28-21-51-36找数"><a href="#title-二分-一-date-2023-07-28-21-51-36找数" class="headerlink" title="title: 二分(一)date: 2023-07-28 21:51:36找数"></a>title: 二分(一)<br>date: 2023-07-28 21:51:36<br>找数</h2><blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>从题目中可以看出,数组中的元素是<strong>有序的</strong>,而且是<strong>不重复的</strong>,很满足二分法的使用条件,所以使用二分法来解决这道题,同时二分有两种情况,一种是左闭右闭,一种是左闭右开,而这两种情况在代码的形式上是不一样的.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>以right &#x3D;&#x3D; left(两边顶点)为终止条件,根据左闭又开或左闭右闭来调整每一轮循环之后right和left两边端点的位置.始终将target在端点之间,直到right &#x3D; left.</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(log n)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code-JAVA"><a href="#Code-JAVA" class="headerlink" title="Code[JAVA]"></a>Code[JAVA]</h1><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int left = 0, right = nums.length;        while(left &lt; right) &#123;            int mid = right+left &gt;&gt; 1;            if(nums[mid] &gt; target)&#123;                right = mid;            &#125;            else if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;            else return mid;        &#125;        return -1;    &#125;&#125;</code></pre><h1 id="Code-C"><a href="#Code-C" class="headerlink" title="Code[C++]"></a>Code[C++]</h1><pre><code class="C++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;                int left = 0;        int right = nums.size()-1;        while(left &lt;= right)&#123;            int middle  = left + ((right-left)&gt;&gt;1);            if(nums[middle] &lt; target)&#123;                left = middle+1;            &#125;            if(nums[middle] &gt; target)&#123;                right = middle-1;//右开            &#125;           if(nums[middle] == target)&#123;              return middle;           &#125;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/posts/654572fa.html"/>
      <url>/posts/654572fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
